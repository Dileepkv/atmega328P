   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 145               	prvCopyDataToQueue:
 146               		.stabd	46,0,0
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****     FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:FreeRTOS/Source/queue.c ****     All rights reserved
   4:FreeRTOS/Source/queue.c **** 
   5:FreeRTOS/Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:FreeRTOS/Source/queue.c **** 
   7:FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
   8:FreeRTOS/Source/queue.c **** 
   9:FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:FreeRTOS/Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  12:FreeRTOS/Source/queue.c **** 
  13:FreeRTOS/Source/queue.c **** 	***************************************************************************
  14:FreeRTOS/Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:FreeRTOS/Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:FreeRTOS/Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:FreeRTOS/Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:FreeRTOS/Source/queue.c **** 	***************************************************************************
  19:FreeRTOS/Source/queue.c **** 
  20:FreeRTOS/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:FreeRTOS/Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:FreeRTOS/Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:FreeRTOS/Source/queue.c ****     link: http://www.freertos.org/a00114.html
  24:FreeRTOS/Source/queue.c **** 
  25:FreeRTOS/Source/queue.c ****     ***************************************************************************
  26:FreeRTOS/Source/queue.c ****      *                                                                       *
  27:FreeRTOS/Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:FreeRTOS/Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:FreeRTOS/Source/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:FreeRTOS/Source/queue.c ****      *    is the industry's de facto standard.                               *
  31:FreeRTOS/Source/queue.c ****      *                                                                       *
  32:FreeRTOS/Source/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:FreeRTOS/Source/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:FreeRTOS/Source/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:FreeRTOS/Source/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:FreeRTOS/Source/queue.c ****      *                                                                       *
  37:FreeRTOS/Source/queue.c ****     ***************************************************************************
  38:FreeRTOS/Source/queue.c **** 
  39:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:FreeRTOS/Source/queue.c **** 	the FAQ page "My application does not run, what could be wrong?".  Have you
  41:FreeRTOS/Source/queue.c **** 	defined configASSERT()?
  42:FreeRTOS/Source/queue.c **** 
  43:FreeRTOS/Source/queue.c **** 	http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:FreeRTOS/Source/queue.c **** 	embedded software for free we request you assist our global community by
  45:FreeRTOS/Source/queue.c **** 	participating in the support forum.
  46:FreeRTOS/Source/queue.c **** 
  47:FreeRTOS/Source/queue.c **** 	http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:FreeRTOS/Source/queue.c **** 	be as productive as possible as early as possible.  Now you can receive
  49:FreeRTOS/Source/queue.c **** 	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:FreeRTOS/Source/queue.c **** 	Ltd, and the world's leading authority on the world's leading RTOS.
  51:FreeRTOS/Source/queue.c **** 
  52:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:FreeRTOS/Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:FreeRTOS/Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:FreeRTOS/Source/queue.c **** 
  56:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:FreeRTOS/Source/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:FreeRTOS/Source/queue.c **** 
  59:FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:FreeRTOS/Source/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:FreeRTOS/Source/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:FreeRTOS/Source/queue.c **** 
  63:FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:FreeRTOS/Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:FreeRTOS/Source/queue.c ****     mission critical applications that require provable dependability.
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  68:FreeRTOS/Source/queue.c **** */
  69:FreeRTOS/Source/queue.c **** 
  70:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  71:FreeRTOS/Source/queue.c **** #include <string.h>
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  76:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:FreeRTOS/Source/queue.c **** 
  78:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  79:FreeRTOS/Source/queue.c **** #include "task.h"
  80:FreeRTOS/Source/queue.c **** #include "queue.h"
  81:FreeRTOS/Source/queue.c **** 
  82:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  84:FreeRTOS/Source/queue.c **** #endif
  85:FreeRTOS/Source/queue.c **** 
  86:FreeRTOS/Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:FreeRTOS/Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:FreeRTOS/Source/queue.c **** header files above, but not in this file, in order to generate the correct
  89:FreeRTOS/Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** 
  93:FreeRTOS/Source/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  94:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( BaseType_t ) -1 )
  95:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
  96:FreeRTOS/Source/queue.c **** 
  97:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:FreeRTOS/Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:FreeRTOS/Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:FreeRTOS/Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:FreeRTOS/Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:FreeRTOS/Source/queue.c **** against the coding standard (although an exception to the standard has been
 106:FreeRTOS/Source/queue.c **** permitted where the dual use also significantly changes the type of the
 107:FreeRTOS/Source/queue.c **** structure member). */
 108:FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
 109:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
 110:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:FreeRTOS/Source/queue.c **** 
 112:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:FreeRTOS/Source/queue.c **** zero. */
 114:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:FreeRTOS/Source/queue.c **** 
 117:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
 120:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:FreeRTOS/Source/queue.c **** #else
 122:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:FreeRTOS/Source/queue.c **** #endif
 124:FreeRTOS/Source/queue.c **** 
 125:FreeRTOS/Source/queue.c **** /*
 126:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
 127:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:FreeRTOS/Source/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:FreeRTOS/Source/queue.c ****  */
 130:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 131:FreeRTOS/Source/queue.c **** {
 132:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:FreeRTOS/Source/queue.c **** 
 136:FreeRTOS/Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:FreeRTOS/Source/queue.c **** 	{
 138:FreeRTOS/Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:FreeRTOS/Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:FreeRTOS/Source/queue.c **** 	} u;
 141:FreeRTOS/Source/queue.c **** 
 142:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:FreeRTOS/Source/queue.c **** 
 149:FreeRTOS/Source/queue.c **** 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from 
 150:FreeRTOS/Source/queue.c **** 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the
 151:FreeRTOS/Source/queue.c **** 
 152:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 153:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 154:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 155:FreeRTOS/Source/queue.c **** 	#endif
 156:FreeRTOS/Source/queue.c **** 
 157:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 158:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 159:FreeRTOS/Source/queue.c **** 	#endif
 160:FreeRTOS/Source/queue.c **** 
 161:FreeRTOS/Source/queue.c **** } xQUEUE;
 162:FreeRTOS/Source/queue.c **** 
 163:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 164:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 165:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 166:FreeRTOS/Source/queue.c **** 
 167:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 168:FreeRTOS/Source/queue.c **** 
 169:FreeRTOS/Source/queue.c **** /*
 170:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 171:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 172:FreeRTOS/Source/queue.c ****  */
 173:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 174:FreeRTOS/Source/queue.c **** 
 175:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 176:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 177:FreeRTOS/Source/queue.c **** 	more user friendly. */
 178:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 179:FreeRTOS/Source/queue.c **** 	{
 180:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 181:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 182:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 183:FreeRTOS/Source/queue.c **** 
 184:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 185:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 186:FreeRTOS/Source/queue.c **** 	debuggers. */
 187:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 188:FreeRTOS/Source/queue.c **** 
 189:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 190:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 191:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 192:FreeRTOS/Source/queue.c **** 	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 193:FreeRTOS/Source/queue.c **** 
 194:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 198:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 199:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 200:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 201:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 202:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 203:FreeRTOS/Source/queue.c ****  */
 204:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 205:FreeRTOS/Source/queue.c **** 
 206:FreeRTOS/Source/queue.c **** /*
 207:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 208:FreeRTOS/Source/queue.c ****  *
 209:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 210:FreeRTOS/Source/queue.c ****  */
 211:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 212:FreeRTOS/Source/queue.c **** 
 213:FreeRTOS/Source/queue.c **** /*
 214:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 215:FreeRTOS/Source/queue.c ****  *
 216:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 217:FreeRTOS/Source/queue.c ****  */
 218:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 219:FreeRTOS/Source/queue.c **** 
 220:FreeRTOS/Source/queue.c **** /*
 221:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 222:FreeRTOS/Source/queue.c ****  * back of the queue.
 223:FreeRTOS/Source/queue.c ****  */
 224:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 225:FreeRTOS/Source/queue.c **** 
 226:FreeRTOS/Source/queue.c **** /*
 227:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 228:FreeRTOS/Source/queue.c ****  */
 229:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 230:FreeRTOS/Source/queue.c **** 
 231:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 232:FreeRTOS/Source/queue.c **** 	/*
 233:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 234:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 235:FreeRTOS/Source/queue.c **** 	 */
 236:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 237:FreeRTOS/Source/queue.c **** #endif
 238:FreeRTOS/Source/queue.c **** 
 239:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 240:FreeRTOS/Source/queue.c **** 
 241:FreeRTOS/Source/queue.c **** /*
 242:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 243:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 244:FreeRTOS/Source/queue.c ****  */
 245:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 246:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 247:FreeRTOS/Source/queue.c **** 	{														\
 248:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 249:FreeRTOS/Source/queue.c **** 		{													\
 250:FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 251:FreeRTOS/Source/queue.c **** 		}													\
 252:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 253:FreeRTOS/Source/queue.c **** 		{													\
 254:FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 255:FreeRTOS/Source/queue.c **** 		}													\
 256:FreeRTOS/Source/queue.c **** 	}														\
 257:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 258:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 259:FreeRTOS/Source/queue.c **** 
 260:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 261:FreeRTOS/Source/queue.c **** {
 262:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 263:FreeRTOS/Source/queue.c **** 
 264:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 265:FreeRTOS/Source/queue.c **** 
 266:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 267:FreeRTOS/Source/queue.c **** 	{
 268:FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 269:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 270:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 271:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 272:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 273:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 274:FreeRTOS/Source/queue.c **** 
 275:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 276:FreeRTOS/Source/queue.c **** 		{
 277:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 278:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 279:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 280:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 281:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 282:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 283:FreeRTOS/Source/queue.c **** 			{
 284:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 285:FreeRTOS/Source/queue.c **** 				{
 286:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 287:FreeRTOS/Source/queue.c **** 				}
 288:FreeRTOS/Source/queue.c **** 				else
 289:FreeRTOS/Source/queue.c **** 				{
 290:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 				}
 292:FreeRTOS/Source/queue.c **** 			}
 293:FreeRTOS/Source/queue.c **** 			else
 294:FreeRTOS/Source/queue.c **** 			{
 295:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 296:FreeRTOS/Source/queue.c **** 			}
 297:FreeRTOS/Source/queue.c **** 		}
 298:FreeRTOS/Source/queue.c **** 		else
 299:FreeRTOS/Source/queue.c **** 		{
 300:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 301:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 302:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 303:FreeRTOS/Source/queue.c **** 		}
 304:FreeRTOS/Source/queue.c **** 	}
 305:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 306:FreeRTOS/Source/queue.c **** 
 307:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 308:FreeRTOS/Source/queue.c **** 	versions. */
 309:FreeRTOS/Source/queue.c **** 	return pdPASS;
 310:FreeRTOS/Source/queue.c **** }
 311:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 312:FreeRTOS/Source/queue.c **** 
 313:FreeRTOS/Source/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 314:FreeRTOS/Source/queue.c **** {
 315:FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 316:FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 317:FreeRTOS/Source/queue.c **** QueueHandle_t xReturn = NULL;
 318:FreeRTOS/Source/queue.c **** int8_t *pcAllocatedBuffer;
 319:FreeRTOS/Source/queue.c **** 
 320:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 321:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 322:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 323:FreeRTOS/Source/queue.c **** 
 324:FreeRTOS/Source/queue.c **** 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 325:FreeRTOS/Source/queue.c **** 
 326:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 327:FreeRTOS/Source/queue.c **** 	{
 328:FreeRTOS/Source/queue.c **** 		/* There is not going to be a queue storage area. */
 329:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) 0;
 330:FreeRTOS/Source/queue.c **** 	}
 331:FreeRTOS/Source/queue.c **** 	else
 332:FreeRTOS/Source/queue.c **** 	{
 333:FreeRTOS/Source/queue.c **** 		/* The queue is one byte longer than asked for to make wrap checking
 334:FreeRTOS/Source/queue.c **** 		easier/faster. */
 335:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA 
 336:FreeRTOS/Source/queue.c **** 	}
 337:FreeRTOS/Source/queue.c **** 
 338:FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure and storage area. */
 339:FreeRTOS/Source/queue.c **** 	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 340:FreeRTOS/Source/queue.c **** 
 341:FreeRTOS/Source/queue.c **** 	if( pcAllocatedBuffer != NULL )
 342:FreeRTOS/Source/queue.c **** 	{
 343:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be to small be
 344:FreeRTOS/Source/queue.c **** 
 345:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 346:FreeRTOS/Source/queue.c **** 		{
 347:FreeRTOS/Source/queue.c **** 			/* No RAM was allocated for the queue storage area, but PC head
 348:FreeRTOS/Source/queue.c **** 			cannot be set to NULL because NULL is used as a key to say the queue
 349:FreeRTOS/Source/queue.c **** 			is used as a mutex.  Therefore just set pcHead to point to the queue
 350:FreeRTOS/Source/queue.c **** 			as a benign value that is known to be within the memory map. */
 351:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 352:FreeRTOS/Source/queue.c **** 		}
 353:FreeRTOS/Source/queue.c **** 		else
 354:FreeRTOS/Source/queue.c **** 		{
 355:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 356:FreeRTOS/Source/queue.c **** 			storage area - adding the padding bytes to get a better alignment. */
 357:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
 358:FreeRTOS/Source/queue.c **** 		}
 359:FreeRTOS/Source/queue.c **** 
 360:FreeRTOS/Source/queue.c **** 		/* Initialise the queue members as described above where the queue type
 361:FreeRTOS/Source/queue.c **** 		is defined. */
 362:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxLength = uxQueueLength;
 363:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxItemSize = uxItemSize;
 364:FreeRTOS/Source/queue.c **** 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 365:FreeRTOS/Source/queue.c **** 
 366:FreeRTOS/Source/queue.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
 367:FreeRTOS/Source/queue.c **** 		{
 368:FreeRTOS/Source/queue.c **** 			pxNewQueue->ucQueueType = ucQueueType;
 369:FreeRTOS/Source/queue.c **** 		}
 370:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_TRACE_FACILITY */
 371:FreeRTOS/Source/queue.c **** 
 372:FreeRTOS/Source/queue.c **** 		#if( configUSE_QUEUE_SETS == 1 )
 373:FreeRTOS/Source/queue.c **** 		{
 374:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxQueueSetContainer = NULL;
 375:FreeRTOS/Source/queue.c **** 		}
 376:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_QUEUE_SETS */
 377:FreeRTOS/Source/queue.c **** 
 378:FreeRTOS/Source/queue.c **** 		traceQUEUE_CREATE( pxNewQueue );
 379:FreeRTOS/Source/queue.c **** 		xReturn = pxNewQueue;
 380:FreeRTOS/Source/queue.c **** 	}
 381:FreeRTOS/Source/queue.c **** 	else
 382:FreeRTOS/Source/queue.c **** 	{
 383:FreeRTOS/Source/queue.c **** 		mtCOVERAGE_TEST_MARKER();
 384:FreeRTOS/Source/queue.c **** 	}
 385:FreeRTOS/Source/queue.c **** 
 386:FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 387:FreeRTOS/Source/queue.c **** 
 388:FreeRTOS/Source/queue.c **** 	return xReturn;
 389:FreeRTOS/Source/queue.c **** }
 390:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 391:FreeRTOS/Source/queue.c **** 
 392:FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 393:FreeRTOS/Source/queue.c **** 
 394:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 395:FreeRTOS/Source/queue.c **** 	{
 396:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 397:FreeRTOS/Source/queue.c **** 
 398:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 399:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 400:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 401:FreeRTOS/Source/queue.c **** 
 402:FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 403:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 404:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 405:FreeRTOS/Source/queue.c **** 		{
 406:FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 407:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 408:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 409:FreeRTOS/Source/queue.c **** 
 410:FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 411:FreeRTOS/Source/queue.c **** 			of the queue. */
 412:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 413:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 414:FreeRTOS/Source/queue.c **** 
 415:FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 416:FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 417:FreeRTOS/Source/queue.c **** 			of the mutex. */
 418:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 419:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 420:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 421:FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 422:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 423:FreeRTOS/Source/queue.c **** 
 424:FreeRTOS/Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 425:FreeRTOS/Source/queue.c **** 			{
 426:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 427:FreeRTOS/Source/queue.c **** 			}
 428:FreeRTOS/Source/queue.c **** 			#endif
 429:FreeRTOS/Source/queue.c **** 
 430:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 431:FreeRTOS/Source/queue.c **** 			{
 432:FreeRTOS/Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 433:FreeRTOS/Source/queue.c **** 			}
 434:FreeRTOS/Source/queue.c **** 			#endif
 435:FreeRTOS/Source/queue.c **** 
 436:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 437:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 438:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 439:FreeRTOS/Source/queue.c **** 
 440:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 441:FreeRTOS/Source/queue.c **** 
 442:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 443:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 444:FreeRTOS/Source/queue.c **** 		}
 445:FreeRTOS/Source/queue.c **** 		else
 446:FreeRTOS/Source/queue.c **** 		{
 447:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 448:FreeRTOS/Source/queue.c **** 		}
 449:FreeRTOS/Source/queue.c **** 
 450:FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 451:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 452:FreeRTOS/Source/queue.c **** 	}
 453:FreeRTOS/Source/queue.c **** 
 454:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 455:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 456:FreeRTOS/Source/queue.c **** 
 457:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 458:FreeRTOS/Source/queue.c **** 
 459:FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 460:FreeRTOS/Source/queue.c **** 	{
 461:FreeRTOS/Source/queue.c **** 	void *pxReturn;
 462:FreeRTOS/Source/queue.c **** 
 463:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 464:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 465:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 466:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 467:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 468:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 469:FreeRTOS/Source/queue.c **** 		{
 470:FreeRTOS/Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 471:FreeRTOS/Source/queue.c **** 			{
 472:FreeRTOS/Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 473:FreeRTOS/Source/queue.c **** 			}
 474:FreeRTOS/Source/queue.c **** 			else
 475:FreeRTOS/Source/queue.c **** 			{
 476:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 477:FreeRTOS/Source/queue.c **** 			}
 478:FreeRTOS/Source/queue.c **** 		}
 479:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 480:FreeRTOS/Source/queue.c **** 
 481:FreeRTOS/Source/queue.c **** 		return pxReturn;
 482:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 483:FreeRTOS/Source/queue.c **** 
 484:FreeRTOS/Source/queue.c **** #endif
 485:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 486:FreeRTOS/Source/queue.c **** 
 487:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 488:FreeRTOS/Source/queue.c **** 
 489:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 490:FreeRTOS/Source/queue.c **** 	{
 491:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 492:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 493:FreeRTOS/Source/queue.c **** 
 494:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 495:FreeRTOS/Source/queue.c **** 
 496:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 497:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 498:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 499:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 500:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 501:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 502:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 503:FreeRTOS/Source/queue.c **** 		{
 504:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 505:FreeRTOS/Source/queue.c **** 
 506:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 507:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 508:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 509:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 510:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 511:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 512:FreeRTOS/Source/queue.c **** 
 513:FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 514:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 515:FreeRTOS/Source/queue.c **** 			{
 516:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 517:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 518:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 519:FreeRTOS/Source/queue.c **** 			}
 520:FreeRTOS/Source/queue.c **** 			else
 521:FreeRTOS/Source/queue.c **** 			{
 522:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 523:FreeRTOS/Source/queue.c **** 			}
 524:FreeRTOS/Source/queue.c **** 
 525:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 526:FreeRTOS/Source/queue.c **** 		}
 527:FreeRTOS/Source/queue.c **** 		else
 528:FreeRTOS/Source/queue.c **** 		{
 529:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 530:FreeRTOS/Source/queue.c **** 			holder. */
 531:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 532:FreeRTOS/Source/queue.c **** 
 533:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 534:FreeRTOS/Source/queue.c **** 		}
 535:FreeRTOS/Source/queue.c **** 
 536:FreeRTOS/Source/queue.c **** 		return xReturn;
 537:FreeRTOS/Source/queue.c **** 	}
 538:FreeRTOS/Source/queue.c **** 
 539:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 540:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 541:FreeRTOS/Source/queue.c **** 
 542:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 545:FreeRTOS/Source/queue.c **** 	{
 546:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 547:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 548:FreeRTOS/Source/queue.c **** 
 549:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 550:FreeRTOS/Source/queue.c **** 
 551:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 552:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 553:FreeRTOS/Source/queue.c **** 
 554:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 555:FreeRTOS/Source/queue.c **** 
 556:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 557:FreeRTOS/Source/queue.c **** 		{
 558:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 559:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 560:FreeRTOS/Source/queue.c **** 		}
 561:FreeRTOS/Source/queue.c **** 		else
 562:FreeRTOS/Source/queue.c **** 		{
 563:FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 564:FreeRTOS/Source/queue.c **** 
 565:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 566:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 567:FreeRTOS/Source/queue.c **** 			before reaching here. */
 568:FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 569:FreeRTOS/Source/queue.c **** 			{
 570:FreeRTOS/Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 571:FreeRTOS/Source/queue.c **** 			}
 572:FreeRTOS/Source/queue.c **** 			else
 573:FreeRTOS/Source/queue.c **** 			{
 574:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 575:FreeRTOS/Source/queue.c **** 			}
 576:FreeRTOS/Source/queue.c **** 		}
 577:FreeRTOS/Source/queue.c **** 
 578:FreeRTOS/Source/queue.c **** 		return xReturn;
 579:FreeRTOS/Source/queue.c **** 	}
 580:FreeRTOS/Source/queue.c **** 
 581:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 582:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 583:FreeRTOS/Source/queue.c **** 
 584:FreeRTOS/Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 585:FreeRTOS/Source/queue.c **** 
 586:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 587:FreeRTOS/Source/queue.c **** 	{
 588:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 589:FreeRTOS/Source/queue.c **** 
 590:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 591:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 592:FreeRTOS/Source/queue.c **** 
 593:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 594:FreeRTOS/Source/queue.c **** 
 595:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 596:FreeRTOS/Source/queue.c **** 		{
 597:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 598:FreeRTOS/Source/queue.c **** 
 599:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 600:FreeRTOS/Source/queue.c **** 		}
 601:FreeRTOS/Source/queue.c **** 		else
 602:FreeRTOS/Source/queue.c **** 		{
 603:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 604:FreeRTOS/Source/queue.c **** 		}
 605:FreeRTOS/Source/queue.c **** 
 606:FreeRTOS/Source/queue.c **** 		configASSERT( xHandle );
 607:FreeRTOS/Source/queue.c **** 		return xHandle;
 608:FreeRTOS/Source/queue.c **** 	}
 609:FreeRTOS/Source/queue.c **** 
 610:FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 611:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 612:FreeRTOS/Source/queue.c **** 
 613:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 614:FreeRTOS/Source/queue.c **** {
 615:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 616:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 617:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 618:FreeRTOS/Source/queue.c **** 
 619:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 620:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 621:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 622:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 623:FreeRTOS/Source/queue.c **** 	{
 624:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 625:FreeRTOS/Source/queue.c **** 	}
 626:FreeRTOS/Source/queue.c **** 	#endif
 627:FreeRTOS/Source/queue.c **** 
 628:FreeRTOS/Source/queue.c **** 
 629:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 630:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 631:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 632:FreeRTOS/Source/queue.c **** 	for( ;; )
 633:FreeRTOS/Source/queue.c **** 	{
 634:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 635:FreeRTOS/Source/queue.c **** 		{
 636:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 637:FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 638:FreeRTOS/Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 639:FreeRTOS/Source/queue.c **** 			not matter if the queue is full. */
 640:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 641:FreeRTOS/Source/queue.c **** 			{
 642:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 643:FreeRTOS/Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 644:FreeRTOS/Source/queue.c **** 
 645:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 646:FreeRTOS/Source/queue.c **** 				{
 647:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 648:FreeRTOS/Source/queue.c **** 					{
 649:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 650:FreeRTOS/Source/queue.c **** 						{
 651:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 652:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 653:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 654:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 655:FreeRTOS/Source/queue.c **** 						}
 656:FreeRTOS/Source/queue.c **** 						else
 657:FreeRTOS/Source/queue.c **** 						{
 658:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 659:FreeRTOS/Source/queue.c **** 						}
 660:FreeRTOS/Source/queue.c **** 					}
 661:FreeRTOS/Source/queue.c **** 					else
 662:FreeRTOS/Source/queue.c **** 					{
 663:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 664:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 665:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 666:FreeRTOS/Source/queue.c **** 						{
 667:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 668:FreeRTOS/Source/queue.c **** 							{
 669:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 670:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 671:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 672:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 673:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 674:FreeRTOS/Source/queue.c **** 							}
 675:FreeRTOS/Source/queue.c **** 							else
 676:FreeRTOS/Source/queue.c **** 							{
 677:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 678:FreeRTOS/Source/queue.c **** 							}
 679:FreeRTOS/Source/queue.c **** 						}
 680:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 681:FreeRTOS/Source/queue.c **** 						{
 682:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 683:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 684:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 685:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 686:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 687:FreeRTOS/Source/queue.c **** 						}
 688:FreeRTOS/Source/queue.c **** 						else
 689:FreeRTOS/Source/queue.c **** 						{
 690:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 691:FreeRTOS/Source/queue.c **** 						}
 692:FreeRTOS/Source/queue.c **** 					}
 693:FreeRTOS/Source/queue.c **** 				}
 694:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 695:FreeRTOS/Source/queue.c **** 				{
 696:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 697:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 698:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 699:FreeRTOS/Source/queue.c **** 					{
 700:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 701:FreeRTOS/Source/queue.c **** 						{
 702:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 703:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 704:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 705:FreeRTOS/Source/queue.c **** 							takes care of that. */
 706:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 707:FreeRTOS/Source/queue.c **** 						}
 708:FreeRTOS/Source/queue.c **** 						else
 709:FreeRTOS/Source/queue.c **** 						{
 710:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 711:FreeRTOS/Source/queue.c **** 						}
 712:FreeRTOS/Source/queue.c **** 					}
 713:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 714:FreeRTOS/Source/queue.c **** 					{
 715:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 716:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 717:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 718:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 719:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 720:FreeRTOS/Source/queue.c **** 					}
 721:FreeRTOS/Source/queue.c **** 					else
 722:FreeRTOS/Source/queue.c **** 					{
 723:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 724:FreeRTOS/Source/queue.c **** 					}
 725:FreeRTOS/Source/queue.c **** 				}
 726:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 727:FreeRTOS/Source/queue.c **** 
 728:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 729:FreeRTOS/Source/queue.c **** 				return pdPASS;
 730:FreeRTOS/Source/queue.c **** 			}
 731:FreeRTOS/Source/queue.c **** 			else
 732:FreeRTOS/Source/queue.c **** 			{
 733:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 734:FreeRTOS/Source/queue.c **** 				{
 735:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 736:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 737:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 738:FreeRTOS/Source/queue.c **** 
 739:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 740:FreeRTOS/Source/queue.c **** 					the function. */
 741:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 742:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 743:FreeRTOS/Source/queue.c **** 				}
 744:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 745:FreeRTOS/Source/queue.c **** 				{
 746:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 747:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 748:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 749:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 750:FreeRTOS/Source/queue.c **** 				}
 751:FreeRTOS/Source/queue.c **** 				else
 752:FreeRTOS/Source/queue.c **** 				{
 753:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 754:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 755:FreeRTOS/Source/queue.c **** 				}
 756:FreeRTOS/Source/queue.c **** 			}
 757:FreeRTOS/Source/queue.c **** 		}
 758:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 759:FreeRTOS/Source/queue.c **** 
 760:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 761:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 762:FreeRTOS/Source/queue.c **** 
 763:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 765:FreeRTOS/Source/queue.c **** 
 766:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 767:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 768:FreeRTOS/Source/queue.c **** 		{
 769:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 770:FreeRTOS/Source/queue.c **** 			{
 771:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 772:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 773:FreeRTOS/Source/queue.c **** 
 774:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 775:FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 776:FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 777:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 778:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 779:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 780:FreeRTOS/Source/queue.c **** 
 781:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 782:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 783:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 784:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 785:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 786:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 787:FreeRTOS/Source/queue.c **** 				{
 788:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 789:FreeRTOS/Source/queue.c **** 				}
 790:FreeRTOS/Source/queue.c **** 			}
 791:FreeRTOS/Source/queue.c **** 			else
 792:FreeRTOS/Source/queue.c **** 			{
 793:FreeRTOS/Source/queue.c **** 				/* Try again. */
 794:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 795:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 796:FreeRTOS/Source/queue.c **** 			}
 797:FreeRTOS/Source/queue.c **** 		}
 798:FreeRTOS/Source/queue.c **** 		else
 799:FreeRTOS/Source/queue.c **** 		{
 800:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 801:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 802:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 803:FreeRTOS/Source/queue.c **** 
 804:FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 805:FreeRTOS/Source/queue.c **** 			function. */
 806:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 807:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 808:FreeRTOS/Source/queue.c **** 		}
 809:FreeRTOS/Source/queue.c **** 	}
 810:FreeRTOS/Source/queue.c **** }
 811:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 812:FreeRTOS/Source/queue.c **** 
 813:FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 814:FreeRTOS/Source/queue.c **** 
 815:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_
 816:FreeRTOS/Source/queue.c **** 	{
 817:FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 818:FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 819:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 820:FreeRTOS/Source/queue.c **** 
 821:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 822:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 823:FreeRTOS/Source/queue.c **** 
 824:FreeRTOS/Source/queue.c **** 		for( ;; )
 825:FreeRTOS/Source/queue.c **** 		{
 826:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 827:FreeRTOS/Source/queue.c **** 			{
 828:FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 829:FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 830:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 831:FreeRTOS/Source/queue.c **** 				{
 832:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 833:FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:FreeRTOS/Source/queue.c **** 
 835:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 837:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 838:FreeRTOS/Source/queue.c **** 					{
 839:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 840:FreeRTOS/Source/queue.c **** 						{
 841:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 843:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 844:FreeRTOS/Source/queue.c **** 						}
 845:FreeRTOS/Source/queue.c **** 						else
 846:FreeRTOS/Source/queue.c **** 						{
 847:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 848:FreeRTOS/Source/queue.c **** 						}
 849:FreeRTOS/Source/queue.c **** 					}
 850:FreeRTOS/Source/queue.c **** 					else
 851:FreeRTOS/Source/queue.c **** 					{
 852:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 853:FreeRTOS/Source/queue.c **** 					}
 854:FreeRTOS/Source/queue.c **** 
 855:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 856:FreeRTOS/Source/queue.c **** 					return pdPASS;
 857:FreeRTOS/Source/queue.c **** 				}
 858:FreeRTOS/Source/queue.c **** 				else
 859:FreeRTOS/Source/queue.c **** 				{
 860:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 861:FreeRTOS/Source/queue.c **** 					{
 862:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 863:FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 864:FreeRTOS/Source/queue.c **** 					}
 865:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 866:FreeRTOS/Source/queue.c **** 					{
 867:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 868:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 869:FreeRTOS/Source/queue.c **** 					}
 870:FreeRTOS/Source/queue.c **** 				}
 871:FreeRTOS/Source/queue.c **** 			}
 872:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 873:FreeRTOS/Source/queue.c **** 
 874:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 875:FreeRTOS/Source/queue.c **** 			{
 876:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 877:FreeRTOS/Source/queue.c **** 				{
 878:FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 879:FreeRTOS/Source/queue.c **** 					{
 880:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 881:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 882:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 883:FreeRTOS/Source/queue.c **** 					}
 884:FreeRTOS/Source/queue.c **** 					else
 885:FreeRTOS/Source/queue.c **** 					{
 886:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 887:FreeRTOS/Source/queue.c **** 					}
 888:FreeRTOS/Source/queue.c **** 				}
 889:FreeRTOS/Source/queue.c **** 				else
 890:FreeRTOS/Source/queue.c **** 				{
 891:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 892:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 893:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 894:FreeRTOS/Source/queue.c **** 				}
 895:FreeRTOS/Source/queue.c **** 			}
 896:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 897:FreeRTOS/Source/queue.c **** 		}
 898:FreeRTOS/Source/queue.c **** 	}
 899:FreeRTOS/Source/queue.c **** 
 900:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 901:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 902:FreeRTOS/Source/queue.c **** 
 903:FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 904:FreeRTOS/Source/queue.c **** 
 905:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicks
 906:FreeRTOS/Source/queue.c **** 	{
 907:FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 908:FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 909:FreeRTOS/Source/queue.c **** 	int8_t *pcOriginalReadPosition;
 910:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 911:FreeRTOS/Source/queue.c **** 
 912:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 913:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 914:FreeRTOS/Source/queue.c **** 
 915:FreeRTOS/Source/queue.c **** 		for( ;; )
 916:FreeRTOS/Source/queue.c **** 		{
 917:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 918:FreeRTOS/Source/queue.c **** 			{
 919:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 920:FreeRTOS/Source/queue.c **** 				{
 921:FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 922:FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 923:FreeRTOS/Source/queue.c **** 
 924:FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 925:FreeRTOS/Source/queue.c **** 
 926:FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 927:FreeRTOS/Source/queue.c **** 					{
 928:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 929:FreeRTOS/Source/queue.c **** 
 930:FreeRTOS/Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 931:FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 932:FreeRTOS/Source/queue.c **** 
 933:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 934:FreeRTOS/Source/queue.c **** 						{
 935:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 936:FreeRTOS/Source/queue.c **** 							{
 937:FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 938:FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 939:FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
 940:FreeRTOS/Source/queue.c **** 							}
 941:FreeRTOS/Source/queue.c **** 							else
 942:FreeRTOS/Source/queue.c **** 							{
 943:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 944:FreeRTOS/Source/queue.c **** 							}
 945:FreeRTOS/Source/queue.c **** 						}
 946:FreeRTOS/Source/queue.c **** 						#endif
 947:FreeRTOS/Source/queue.c **** 
 948:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 949:FreeRTOS/Source/queue.c **** 						{
 950:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 951:FreeRTOS/Source/queue.c **** 							{
 952:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 953:FreeRTOS/Source/queue.c **** 							}
 954:FreeRTOS/Source/queue.c **** 							else
 955:FreeRTOS/Source/queue.c **** 							{
 956:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 957:FreeRTOS/Source/queue.c **** 							}
 958:FreeRTOS/Source/queue.c **** 						}
 959:FreeRTOS/Source/queue.c **** 					}
 960:FreeRTOS/Source/queue.c **** 					else
 961:FreeRTOS/Source/queue.c **** 					{
 962:FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 963:FreeRTOS/Source/queue.c **** 
 964:FreeRTOS/Source/queue.c **** 						/* The data is not being removed, so reset our read
 965:FreeRTOS/Source/queue.c **** 						pointer. */
 966:FreeRTOS/Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 967:FreeRTOS/Source/queue.c **** 
 968:FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 969:FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 970:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 971:FreeRTOS/Source/queue.c **** 						{
 972:FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 973:FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 974:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 975:FreeRTOS/Source/queue.c **** 							{
 976:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 977:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 978:FreeRTOS/Source/queue.c **** 							}
 979:FreeRTOS/Source/queue.c **** 							else
 980:FreeRTOS/Source/queue.c **** 							{
 981:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 982:FreeRTOS/Source/queue.c **** 							}
 983:FreeRTOS/Source/queue.c **** 						}
 984:FreeRTOS/Source/queue.c **** 						else
 985:FreeRTOS/Source/queue.c **** 						{
 986:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 987:FreeRTOS/Source/queue.c **** 						}
 988:FreeRTOS/Source/queue.c **** 					}
 989:FreeRTOS/Source/queue.c **** 
 990:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 991:FreeRTOS/Source/queue.c **** 					return pdPASS;
 992:FreeRTOS/Source/queue.c **** 				}
 993:FreeRTOS/Source/queue.c **** 				else
 994:FreeRTOS/Source/queue.c **** 				{
 995:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 996:FreeRTOS/Source/queue.c **** 					{
 997:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 998:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 999:FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
1000:FreeRTOS/Source/queue.c **** 					}
1001:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
1002:FreeRTOS/Source/queue.c **** 					{
1003:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
1004:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
1005:FreeRTOS/Source/queue.c **** 					}
1006:FreeRTOS/Source/queue.c **** 				}
1007:FreeRTOS/Source/queue.c **** 			}
1008:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1009:FreeRTOS/Source/queue.c **** 
1010:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
1011:FreeRTOS/Source/queue.c **** 			{
1012:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1013:FreeRTOS/Source/queue.c **** 				{
1014:FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1015:FreeRTOS/Source/queue.c **** 					{
1016:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1017:FreeRTOS/Source/queue.c **** 
1018:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
1019:FreeRTOS/Source/queue.c **** 						{
1020:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1021:FreeRTOS/Source/queue.c **** 							{
1022:FreeRTOS/Source/queue.c **** 								taskENTER_CRITICAL();
1023:FreeRTOS/Source/queue.c **** 								{
1024:FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1025:FreeRTOS/Source/queue.c **** 								}
1026:FreeRTOS/Source/queue.c **** 								taskEXIT_CRITICAL();
1027:FreeRTOS/Source/queue.c **** 							}
1028:FreeRTOS/Source/queue.c **** 							else
1029:FreeRTOS/Source/queue.c **** 							{
1030:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1031:FreeRTOS/Source/queue.c **** 							}
1032:FreeRTOS/Source/queue.c **** 						}
1033:FreeRTOS/Source/queue.c **** 						#endif
1034:FreeRTOS/Source/queue.c **** 
1035:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1036:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
1037:FreeRTOS/Source/queue.c **** 					}
1038:FreeRTOS/Source/queue.c **** 					else
1039:FreeRTOS/Source/queue.c **** 					{
1040:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1041:FreeRTOS/Source/queue.c **** 					}
1042:FreeRTOS/Source/queue.c **** 				}
1043:FreeRTOS/Source/queue.c **** 				else
1044:FreeRTOS/Source/queue.c **** 				{
1045:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1046:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1047:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1048:FreeRTOS/Source/queue.c **** 				}
1049:FreeRTOS/Source/queue.c **** 			}
1050:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1051:FreeRTOS/Source/queue.c **** 		}
1052:FreeRTOS/Source/queue.c **** 	}
1053:FreeRTOS/Source/queue.c **** 
1054:FreeRTOS/Source/queue.c **** 
1055:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1056:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1057:FreeRTOS/Source/queue.c **** 
1058:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1059:FreeRTOS/Source/queue.c **** {
1060:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1061:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1062:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1063:FreeRTOS/Source/queue.c **** 
1064:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1065:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1066:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1067:FreeRTOS/Source/queue.c **** 
1068:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1069:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1070:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1071:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1072:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1073:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1074:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1075:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1076:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1077:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1078:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1079:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1080:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1081:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1082:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1083:FreeRTOS/Source/queue.c **** 
1084:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
1085:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
1086:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1087:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1088:FreeRTOS/Source/queue.c **** 	post). */
1089:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1090:FreeRTOS/Source/queue.c **** 	{
1091:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
1092:FreeRTOS/Source/queue.c **** 		{
1093:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1094:FreeRTOS/Source/queue.c **** 
1095:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1096:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1097:FreeRTOS/Source/queue.c **** 			given from an ISR.  Therefore, unlike the xQueueGenericGive()
1098:FreeRTOS/Source/queue.c **** 			function, there is no need to determine the need for priority
1099:FreeRTOS/Source/queue.c **** 			disinheritance here or to clear the mutex holder TCB member. */
1100:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1101:FreeRTOS/Source/queue.c **** 
1102:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1103:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1104:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
1105:FreeRTOS/Source/queue.c **** 			{
1106:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1107:FreeRTOS/Source/queue.c **** 				{
1108:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1109:FreeRTOS/Source/queue.c **** 					{
1110:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1111:FreeRTOS/Source/queue.c **** 						{
1112:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1113:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1114:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1115:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1116:FreeRTOS/Source/queue.c **** 							{
1117:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1118:FreeRTOS/Source/queue.c **** 							}
1119:FreeRTOS/Source/queue.c **** 							else
1120:FreeRTOS/Source/queue.c **** 							{
1121:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1122:FreeRTOS/Source/queue.c **** 							}
1123:FreeRTOS/Source/queue.c **** 						}
1124:FreeRTOS/Source/queue.c **** 						else
1125:FreeRTOS/Source/queue.c **** 						{
1126:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1127:FreeRTOS/Source/queue.c **** 						}
1128:FreeRTOS/Source/queue.c **** 					}
1129:FreeRTOS/Source/queue.c **** 					else
1130:FreeRTOS/Source/queue.c **** 					{
1131:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1132:FreeRTOS/Source/queue.c **** 						{
1133:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1134:FreeRTOS/Source/queue.c **** 							{
1135:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1136:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1137:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1138:FreeRTOS/Source/queue.c **** 								{
1139:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1140:FreeRTOS/Source/queue.c **** 								}
1141:FreeRTOS/Source/queue.c **** 								else
1142:FreeRTOS/Source/queue.c **** 								{
1143:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1144:FreeRTOS/Source/queue.c **** 								}
1145:FreeRTOS/Source/queue.c **** 							}
1146:FreeRTOS/Source/queue.c **** 							else
1147:FreeRTOS/Source/queue.c **** 							{
1148:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1149:FreeRTOS/Source/queue.c **** 							}
1150:FreeRTOS/Source/queue.c **** 						}
1151:FreeRTOS/Source/queue.c **** 						else
1152:FreeRTOS/Source/queue.c **** 						{
1153:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1154:FreeRTOS/Source/queue.c **** 						}
1155:FreeRTOS/Source/queue.c **** 					}
1156:FreeRTOS/Source/queue.c **** 				}
1157:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1158:FreeRTOS/Source/queue.c **** 				{
1159:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1160:FreeRTOS/Source/queue.c **** 					{
1161:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1162:FreeRTOS/Source/queue.c **** 						{
1163:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1164:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1165:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1166:FreeRTOS/Source/queue.c **** 							{
1167:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1168:FreeRTOS/Source/queue.c **** 							}
1169:FreeRTOS/Source/queue.c **** 							else
1170:FreeRTOS/Source/queue.c **** 							{
1171:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1172:FreeRTOS/Source/queue.c **** 							}
1173:FreeRTOS/Source/queue.c **** 						}
1174:FreeRTOS/Source/queue.c **** 						else
1175:FreeRTOS/Source/queue.c **** 						{
1176:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1177:FreeRTOS/Source/queue.c **** 						}
1178:FreeRTOS/Source/queue.c **** 					}
1179:FreeRTOS/Source/queue.c **** 					else
1180:FreeRTOS/Source/queue.c **** 					{
1181:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1182:FreeRTOS/Source/queue.c **** 					}
1183:FreeRTOS/Source/queue.c **** 				}
1184:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1185:FreeRTOS/Source/queue.c **** 			}
1186:FreeRTOS/Source/queue.c **** 			else
1187:FreeRTOS/Source/queue.c **** 			{
1188:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1189:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1190:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
1191:FreeRTOS/Source/queue.c **** 			}
1192:FreeRTOS/Source/queue.c **** 
1193:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1194:FreeRTOS/Source/queue.c **** 		}
1195:FreeRTOS/Source/queue.c **** 		else
1196:FreeRTOS/Source/queue.c **** 		{
1197:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1198:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1199:FreeRTOS/Source/queue.c **** 		}
1200:FreeRTOS/Source/queue.c **** 	}
1201:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1202:FreeRTOS/Source/queue.c **** 
1203:FreeRTOS/Source/queue.c **** 	return xReturn;
1204:FreeRTOS/Source/queue.c **** }
1205:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1206:FreeRTOS/Source/queue.c **** 
1207:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1208:FreeRTOS/Source/queue.c **** {
1209:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1210:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1211:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1212:FreeRTOS/Source/queue.c **** 
1213:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1214:FreeRTOS/Source/queue.c **** 
1215:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used in the item size is not 0. */
1216:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1217:FreeRTOS/Source/queue.c **** 
1218:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1219:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1220:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1221:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1222:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1223:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1224:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1225:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1226:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1227:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1228:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1229:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1230:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1231:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1232:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1233:FreeRTOS/Source/queue.c **** 
1234:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1235:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1236:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1237:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1238:FreeRTOS/Source/queue.c **** 	post). */
1239:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1240:FreeRTOS/Source/queue.c **** 	{
1241:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1242:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1243:FreeRTOS/Source/queue.c **** 		space'. */
1244:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1245:FreeRTOS/Source/queue.c **** 		{
1246:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1247:FreeRTOS/Source/queue.c **** 
1248:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1249:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1250:FreeRTOS/Source/queue.c **** 			given from an ISR.  Therefore, unlike the xQueueGenericGive()
1251:FreeRTOS/Source/queue.c **** 			function, there is no need to determine the need for priority
1252:FreeRTOS/Source/queue.c **** 			disinheritance here or to clear the mutex holder TCB member. */
1253:FreeRTOS/Source/queue.c **** 
1254:FreeRTOS/Source/queue.c **** 			++( pxQueue->uxMessagesWaiting );
1255:FreeRTOS/Source/queue.c **** 
1256:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1257:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1258:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
1259:FreeRTOS/Source/queue.c **** 			{
1260:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1261:FreeRTOS/Source/queue.c **** 				{
1262:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1263:FreeRTOS/Source/queue.c **** 					{
1264:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1265:FreeRTOS/Source/queue.c **** 						{
1266:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1267:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1268:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1269:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1270:FreeRTOS/Source/queue.c **** 							{
1271:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1272:FreeRTOS/Source/queue.c **** 							}
1273:FreeRTOS/Source/queue.c **** 							else
1274:FreeRTOS/Source/queue.c **** 							{
1275:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1276:FreeRTOS/Source/queue.c **** 							}
1277:FreeRTOS/Source/queue.c **** 						}
1278:FreeRTOS/Source/queue.c **** 						else
1279:FreeRTOS/Source/queue.c **** 						{
1280:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1281:FreeRTOS/Source/queue.c **** 						}
1282:FreeRTOS/Source/queue.c **** 					}
1283:FreeRTOS/Source/queue.c **** 					else
1284:FreeRTOS/Source/queue.c **** 					{
1285:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1286:FreeRTOS/Source/queue.c **** 						{
1287:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1288:FreeRTOS/Source/queue.c **** 							{
1289:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1290:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1291:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1292:FreeRTOS/Source/queue.c **** 								{
1293:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1294:FreeRTOS/Source/queue.c **** 								}
1295:FreeRTOS/Source/queue.c **** 								else
1296:FreeRTOS/Source/queue.c **** 								{
1297:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1298:FreeRTOS/Source/queue.c **** 								}
1299:FreeRTOS/Source/queue.c **** 							}
1300:FreeRTOS/Source/queue.c **** 							else
1301:FreeRTOS/Source/queue.c **** 							{
1302:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1303:FreeRTOS/Source/queue.c **** 							}
1304:FreeRTOS/Source/queue.c **** 						}
1305:FreeRTOS/Source/queue.c **** 						else
1306:FreeRTOS/Source/queue.c **** 						{
1307:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1308:FreeRTOS/Source/queue.c **** 						}
1309:FreeRTOS/Source/queue.c **** 					}
1310:FreeRTOS/Source/queue.c **** 				}
1311:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1312:FreeRTOS/Source/queue.c **** 				{
1313:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1314:FreeRTOS/Source/queue.c **** 					{
1315:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1316:FreeRTOS/Source/queue.c **** 						{
1317:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1318:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1319:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1320:FreeRTOS/Source/queue.c **** 							{
1321:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1322:FreeRTOS/Source/queue.c **** 							}
1323:FreeRTOS/Source/queue.c **** 							else
1324:FreeRTOS/Source/queue.c **** 							{
1325:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1326:FreeRTOS/Source/queue.c **** 							}
1327:FreeRTOS/Source/queue.c **** 						}
1328:FreeRTOS/Source/queue.c **** 						else
1329:FreeRTOS/Source/queue.c **** 						{
1330:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1331:FreeRTOS/Source/queue.c **** 						}
1332:FreeRTOS/Source/queue.c **** 					}
1333:FreeRTOS/Source/queue.c **** 					else
1334:FreeRTOS/Source/queue.c **** 					{
1335:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1336:FreeRTOS/Source/queue.c **** 					}
1337:FreeRTOS/Source/queue.c **** 				}
1338:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1339:FreeRTOS/Source/queue.c **** 			}
1340:FreeRTOS/Source/queue.c **** 			else
1341:FreeRTOS/Source/queue.c **** 			{
1342:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1343:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1344:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
1345:FreeRTOS/Source/queue.c **** 			}
1346:FreeRTOS/Source/queue.c **** 
1347:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1348:FreeRTOS/Source/queue.c **** 		}
1349:FreeRTOS/Source/queue.c **** 		else
1350:FreeRTOS/Source/queue.c **** 		{
1351:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1352:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1353:FreeRTOS/Source/queue.c **** 		}
1354:FreeRTOS/Source/queue.c **** 	}
1355:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1356:FreeRTOS/Source/queue.c **** 
1357:FreeRTOS/Source/queue.c **** 	return xReturn;
1358:FreeRTOS/Source/queue.c **** }
1359:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1360:FreeRTOS/Source/queue.c **** 
1361:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1362:FreeRTOS/Source/queue.c **** {
1363:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1364:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1365:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1366:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1367:FreeRTOS/Source/queue.c **** 
1368:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1369:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1370:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1371:FreeRTOS/Source/queue.c **** 	{
1372:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1373:FreeRTOS/Source/queue.c **** 	}
1374:FreeRTOS/Source/queue.c **** 	#endif
1375:FreeRTOS/Source/queue.c **** 
1376:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1377:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1378:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1379:FreeRTOS/Source/queue.c **** 
1380:FreeRTOS/Source/queue.c **** 	for( ;; )
1381:FreeRTOS/Source/queue.c **** 	{
1382:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1383:FreeRTOS/Source/queue.c **** 		{
1384:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1385:FreeRTOS/Source/queue.c **** 			must be	the highest priority task wanting to access the queue. */
1386:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1387:FreeRTOS/Source/queue.c **** 			{
1388:FreeRTOS/Source/queue.c **** 				/* Remember the read position in case the queue is only being
1389:FreeRTOS/Source/queue.c **** 				peeked. */
1390:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1391:FreeRTOS/Source/queue.c **** 
1392:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1393:FreeRTOS/Source/queue.c **** 
1394:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
1395:FreeRTOS/Source/queue.c **** 				{
1396:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1397:FreeRTOS/Source/queue.c **** 
1398:FreeRTOS/Source/queue.c **** 					/* Actually removing data, not just peeking. */
1399:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1400:FreeRTOS/Source/queue.c **** 
1401:FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1402:FreeRTOS/Source/queue.c **** 					{
1403:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1404:FreeRTOS/Source/queue.c **** 						{
1405:FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
1406:FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
1407:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
1408:FreeRTOS/Source/queue.c **** 						}
1409:FreeRTOS/Source/queue.c **** 						else
1410:FreeRTOS/Source/queue.c **** 						{
1411:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1412:FreeRTOS/Source/queue.c **** 						}
1413:FreeRTOS/Source/queue.c **** 					}
1414:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1415:FreeRTOS/Source/queue.c **** 
1416:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1417:FreeRTOS/Source/queue.c **** 					{
1418:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1419:FreeRTOS/Source/queue.c **** 						{
1420:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1421:FreeRTOS/Source/queue.c **** 						}
1422:FreeRTOS/Source/queue.c **** 						else
1423:FreeRTOS/Source/queue.c **** 						{
1424:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1425:FreeRTOS/Source/queue.c **** 						}
1426:FreeRTOS/Source/queue.c **** 					}
1427:FreeRTOS/Source/queue.c **** 					else
1428:FreeRTOS/Source/queue.c **** 					{
1429:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1430:FreeRTOS/Source/queue.c **** 					}
1431:FreeRTOS/Source/queue.c **** 				}
1432:FreeRTOS/Source/queue.c **** 				else
1433:FreeRTOS/Source/queue.c **** 				{
1434:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1435:FreeRTOS/Source/queue.c **** 
1436:FreeRTOS/Source/queue.c **** 					/* The data is not being removed, so reset the read
1437:FreeRTOS/Source/queue.c **** 					pointer. */
1438:FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1439:FreeRTOS/Source/queue.c **** 
1440:FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1441:FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
1442:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1443:FreeRTOS/Source/queue.c **** 					{
1444:FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1445:FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1446:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1447:FreeRTOS/Source/queue.c **** 						{
1448:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1449:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1450:FreeRTOS/Source/queue.c **** 						}
1451:FreeRTOS/Source/queue.c **** 						else
1452:FreeRTOS/Source/queue.c **** 						{
1453:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1454:FreeRTOS/Source/queue.c **** 						}
1455:FreeRTOS/Source/queue.c **** 					}
1456:FreeRTOS/Source/queue.c **** 					else
1457:FreeRTOS/Source/queue.c **** 					{
1458:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1459:FreeRTOS/Source/queue.c **** 					}
1460:FreeRTOS/Source/queue.c **** 				}
1461:FreeRTOS/Source/queue.c **** 
1462:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1463:FreeRTOS/Source/queue.c **** 				return pdPASS;
1464:FreeRTOS/Source/queue.c **** 			}
1465:FreeRTOS/Source/queue.c **** 			else
1466:FreeRTOS/Source/queue.c **** 			{
1467:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1468:FreeRTOS/Source/queue.c **** 				{
1469:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1470:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1471:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1472:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1473:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1474:FreeRTOS/Source/queue.c **** 				}
1475:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1476:FreeRTOS/Source/queue.c **** 				{
1477:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1478:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1479:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1480:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1481:FreeRTOS/Source/queue.c **** 				}
1482:FreeRTOS/Source/queue.c **** 				else
1483:FreeRTOS/Source/queue.c **** 				{
1484:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1485:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1486:FreeRTOS/Source/queue.c **** 				}
1487:FreeRTOS/Source/queue.c **** 			}
1488:FreeRTOS/Source/queue.c **** 		}
1489:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1490:FreeRTOS/Source/queue.c **** 
1491:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1492:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1493:FreeRTOS/Source/queue.c **** 
1494:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1496:FreeRTOS/Source/queue.c **** 
1497:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1498:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1499:FreeRTOS/Source/queue.c **** 		{
1500:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1501:FreeRTOS/Source/queue.c **** 			{
1502:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1503:FreeRTOS/Source/queue.c **** 
1504:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1505:FreeRTOS/Source/queue.c **** 				{
1506:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1507:FreeRTOS/Source/queue.c **** 					{
1508:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1509:FreeRTOS/Source/queue.c **** 						{
1510:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1511:FreeRTOS/Source/queue.c **** 						}
1512:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1513:FreeRTOS/Source/queue.c **** 					}
1514:FreeRTOS/Source/queue.c **** 					else
1515:FreeRTOS/Source/queue.c **** 					{
1516:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1517:FreeRTOS/Source/queue.c **** 					}
1518:FreeRTOS/Source/queue.c **** 				}
1519:FreeRTOS/Source/queue.c **** 				#endif
1520:FreeRTOS/Source/queue.c **** 
1521:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1522:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1523:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1524:FreeRTOS/Source/queue.c **** 				{
1525:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1526:FreeRTOS/Source/queue.c **** 				}
1527:FreeRTOS/Source/queue.c **** 				else
1528:FreeRTOS/Source/queue.c **** 				{
1529:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:FreeRTOS/Source/queue.c **** 				}
1531:FreeRTOS/Source/queue.c **** 			}
1532:FreeRTOS/Source/queue.c **** 			else
1533:FreeRTOS/Source/queue.c **** 			{
1534:FreeRTOS/Source/queue.c **** 				/* Try again. */
1535:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1536:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1537:FreeRTOS/Source/queue.c **** 			}
1538:FreeRTOS/Source/queue.c **** 		}
1539:FreeRTOS/Source/queue.c **** 		else
1540:FreeRTOS/Source/queue.c **** 		{
1541:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1542:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1543:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1544:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
1545:FreeRTOS/Source/queue.c **** 		}
1546:FreeRTOS/Source/queue.c **** 	}
1547:FreeRTOS/Source/queue.c **** }
1548:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1549:FreeRTOS/Source/queue.c **** 
1550:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1551:FreeRTOS/Source/queue.c **** {
1552:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1553:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1554:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1555:FreeRTOS/Source/queue.c **** 
1556:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1557:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1558:FreeRTOS/Source/queue.c **** 
1559:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1560:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1561:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1562:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1563:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1564:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1565:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1566:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1567:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1568:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1569:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1570:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1571:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1572:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1573:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1574:FreeRTOS/Source/queue.c **** 
1575:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1576:FreeRTOS/Source/queue.c **** 	{
1577:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1578:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1579:FreeRTOS/Source/queue.c **** 		{
1580:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1581:FreeRTOS/Source/queue.c **** 
1582:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1583:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1584:FreeRTOS/Source/queue.c **** 
1585:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1586:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1587:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1588:FreeRTOS/Source/queue.c **** 			locked. */
1589:FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1590:FreeRTOS/Source/queue.c **** 			{
1591:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1592:FreeRTOS/Source/queue.c **** 				{
1593:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1594:FreeRTOS/Source/queue.c **** 					{
1595:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1596:FreeRTOS/Source/queue.c **** 						force a context switch. */
1597:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1598:FreeRTOS/Source/queue.c **** 						{
1599:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1600:FreeRTOS/Source/queue.c **** 						}
1601:FreeRTOS/Source/queue.c **** 						else
1602:FreeRTOS/Source/queue.c **** 						{
1603:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1604:FreeRTOS/Source/queue.c **** 						}
1605:FreeRTOS/Source/queue.c **** 					}
1606:FreeRTOS/Source/queue.c **** 					else
1607:FreeRTOS/Source/queue.c **** 					{
1608:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1609:FreeRTOS/Source/queue.c **** 					}
1610:FreeRTOS/Source/queue.c **** 				}
1611:FreeRTOS/Source/queue.c **** 				else
1612:FreeRTOS/Source/queue.c **** 				{
1613:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1614:FreeRTOS/Source/queue.c **** 				}
1615:FreeRTOS/Source/queue.c **** 			}
1616:FreeRTOS/Source/queue.c **** 			else
1617:FreeRTOS/Source/queue.c **** 			{
1618:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1619:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1620:FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
1621:FreeRTOS/Source/queue.c **** 			}
1622:FreeRTOS/Source/queue.c **** 
1623:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1624:FreeRTOS/Source/queue.c **** 		}
1625:FreeRTOS/Source/queue.c **** 		else
1626:FreeRTOS/Source/queue.c **** 		{
1627:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1628:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1629:FreeRTOS/Source/queue.c **** 		}
1630:FreeRTOS/Source/queue.c **** 	}
1631:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1632:FreeRTOS/Source/queue.c **** 
1633:FreeRTOS/Source/queue.c **** 	return xReturn;
1634:FreeRTOS/Source/queue.c **** }
1635:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1636:FreeRTOS/Source/queue.c **** 
1637:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1638:FreeRTOS/Source/queue.c **** {
1639:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1640:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1641:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1642:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1643:FreeRTOS/Source/queue.c **** 
1644:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1645:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1646:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1647:FreeRTOS/Source/queue.c **** 
1648:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1649:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1650:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1651:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1652:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1653:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1654:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1655:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1656:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1657:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1658:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1659:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1660:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1661:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1662:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1663:FreeRTOS/Source/queue.c **** 
1664:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1665:FreeRTOS/Source/queue.c **** 	{
1666:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1667:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1668:FreeRTOS/Source/queue.c **** 		{
1669:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1670:FreeRTOS/Source/queue.c **** 
1671:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1672:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1673:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1674:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1675:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1676:FreeRTOS/Source/queue.c **** 
1677:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1678:FreeRTOS/Source/queue.c **** 		}
1679:FreeRTOS/Source/queue.c **** 		else
1680:FreeRTOS/Source/queue.c **** 		{
1681:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1682:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1683:FreeRTOS/Source/queue.c **** 		}
1684:FreeRTOS/Source/queue.c **** 	}
1685:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1686:FreeRTOS/Source/queue.c **** 
1687:FreeRTOS/Source/queue.c **** 	return xReturn;
1688:FreeRTOS/Source/queue.c **** }
1689:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1690:FreeRTOS/Source/queue.c **** 
1691:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1692:FreeRTOS/Source/queue.c **** {
1693:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1694:FreeRTOS/Source/queue.c **** 
1695:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1696:FreeRTOS/Source/queue.c **** 
1697:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1698:FreeRTOS/Source/queue.c **** 	{
1699:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1700:FreeRTOS/Source/queue.c **** 	}
1701:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1702:FreeRTOS/Source/queue.c **** 
1703:FreeRTOS/Source/queue.c **** 	return uxReturn;
1704:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1705:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1706:FreeRTOS/Source/queue.c **** 
1707:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1708:FreeRTOS/Source/queue.c **** {
1709:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1710:FreeRTOS/Source/queue.c **** Queue_t *pxQueue;
1711:FreeRTOS/Source/queue.c **** 
1712:FreeRTOS/Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
1713:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1714:FreeRTOS/Source/queue.c **** 
1715:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1716:FreeRTOS/Source/queue.c **** 	{
1717:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1718:FreeRTOS/Source/queue.c **** 	}
1719:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1720:FreeRTOS/Source/queue.c **** 
1721:FreeRTOS/Source/queue.c **** 	return uxReturn;
1722:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1723:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1724:FreeRTOS/Source/queue.c **** 
1725:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1726:FreeRTOS/Source/queue.c **** {
1727:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1728:FreeRTOS/Source/queue.c **** 
1729:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1730:FreeRTOS/Source/queue.c **** 
1731:FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1732:FreeRTOS/Source/queue.c **** 
1733:FreeRTOS/Source/queue.c **** 	return uxReturn;
1734:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1735:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1736:FreeRTOS/Source/queue.c **** 
1737:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1738:FreeRTOS/Source/queue.c **** {
1739:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1740:FreeRTOS/Source/queue.c **** 
1741:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1742:FreeRTOS/Source/queue.c **** 
1743:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1744:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1745:FreeRTOS/Source/queue.c **** 	{
1746:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1747:FreeRTOS/Source/queue.c **** 	}
1748:FreeRTOS/Source/queue.c **** 	#endif
1749:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
1750:FreeRTOS/Source/queue.c **** }
1751:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1752:FreeRTOS/Source/queue.c **** 
1753:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1754:FreeRTOS/Source/queue.c **** 
1755:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1756:FreeRTOS/Source/queue.c **** 	{
1757:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1758:FreeRTOS/Source/queue.c **** 	}
1759:FreeRTOS/Source/queue.c **** 
1760:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1761:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1762:FreeRTOS/Source/queue.c **** 
1763:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1764:FreeRTOS/Source/queue.c **** 
1765:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1766:FreeRTOS/Source/queue.c **** 	{
1767:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1768:FreeRTOS/Source/queue.c **** 	}
1769:FreeRTOS/Source/queue.c **** 
1770:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1771:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1772:FreeRTOS/Source/queue.c **** 
1773:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1774:FreeRTOS/Source/queue.c **** 
1775:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1776:FreeRTOS/Source/queue.c **** 	{
1777:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1778:FreeRTOS/Source/queue.c **** 	}
1779:FreeRTOS/Source/queue.c **** 
1780:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1781:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1782:FreeRTOS/Source/queue.c **** 
1783:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1784:FreeRTOS/Source/queue.c **** {
 148               	.LM0:
 149               	.LFBB1:
 150 0000 1F93      		push r17
 151 0002 CF93      		push r28
 152 0004 DF93      		push r29
 153               	/* prologue: function */
 154               	/* frame size = 0 */
 155               	/* stack size = 3 */
 156               	.L__stack_usage = 3
 157 0006 EC01      		movw r28,r24
 158 0008 142F      		mov r17,r20
1785:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
1786:FreeRTOS/Source/queue.c **** 
1787:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 160               	.LM1:
 161 000a 4C8D      		ldd r20,Y+28
 162 000c 4423      		tst r20
 163 000e 01F0      		breq .L3
1788:FreeRTOS/Source/queue.c **** 	{
1789:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1790:FreeRTOS/Source/queue.c **** 		{
1791:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1792:FreeRTOS/Source/queue.c **** 			{
1793:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1794:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1795:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1796:FreeRTOS/Source/queue.c **** 			}
1797:FreeRTOS/Source/queue.c **** 			else
1798:FreeRTOS/Source/queue.c **** 			{
1799:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1800:FreeRTOS/Source/queue.c **** 			}
1801:FreeRTOS/Source/queue.c **** 		}
1802:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1803:FreeRTOS/Source/queue.c **** 	}
1804:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
1805:FreeRTOS/Source/queue.c **** 	{
1806:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 165               	.LM2:
 166 0010 50E0      		ldi r21,0
1804:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 168               	.LM3:
 169 0012 1111      		cpse r17,__zero_reg__
 170 0014 00C0      		rjmp .L4
 172               	.LM4:
 173 0016 8C81      		ldd r24,Y+4
 174 0018 9D81      		ldd r25,Y+5
 175 001a 0E94 0000 		call memcpy
1807:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 177               	.LM5:
 178 001e 2C8D      		ldd r18,Y+28
 179 0020 8C81      		ldd r24,Y+4
 180 0022 9D81      		ldd r25,Y+5
 181 0024 820F      		add r24,r18
 182 0026 911D      		adc r25,__zero_reg__
 183 0028 9D83      		std Y+5,r25
 184 002a 8C83      		std Y+4,r24
1808:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 186               	.LM6:
 187 002c 2A81      		ldd r18,Y+2
 188 002e 3B81      		ldd r19,Y+3
 189 0030 8217      		cp r24,r18
 190 0032 9307      		cpc r25,r19
 191 0034 00F0      		brlo .L3
1809:FreeRTOS/Source/queue.c **** 		{
1810:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 193               	.LM7:
 194 0036 8881      		ld r24,Y
 195 0038 9981      		ldd r25,Y+1
 196 003a 9D83      		std Y+5,r25
 197 003c 8C83      		std Y+4,r24
 198 003e 00C0      		rjmp .L3
 199               	.L4:
1811:FreeRTOS/Source/queue.c **** 		}
1812:FreeRTOS/Source/queue.c **** 		else
1813:FreeRTOS/Source/queue.c **** 		{
1814:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1815:FreeRTOS/Source/queue.c **** 		}
1816:FreeRTOS/Source/queue.c **** 	}
1817:FreeRTOS/Source/queue.c **** 	else
1818:FreeRTOS/Source/queue.c **** 	{
1819:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 201               	.LM8:
 202 0040 8E81      		ldd r24,Y+6
 203 0042 9F81      		ldd r25,Y+7
 204 0044 0E94 0000 		call memcpy
1820:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 206               	.LM9:
 207 0048 2C8D      		ldd r18,Y+28
 208 004a 30E0      		ldi r19,0
 209 004c 3195      		neg r19
 210 004e 2195      		neg r18
 211 0050 3109      		sbc r19,__zero_reg__
 212 0052 8E81      		ldd r24,Y+6
 213 0054 9F81      		ldd r25,Y+7
 214 0056 820F      		add r24,r18
 215 0058 931F      		adc r25,r19
 216 005a 9F83      		std Y+7,r25
 217 005c 8E83      		std Y+6,r24
1821:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 219               	.LM10:
 220 005e 6881      		ld r22,Y
 221 0060 7981      		ldd r23,Y+1
 222 0062 8617      		cp r24,r22
 223 0064 9707      		cpc r25,r23
 224 0066 00F4      		brsh .L6
1822:FreeRTOS/Source/queue.c **** 		{
1823:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 226               	.LM11:
 227 0068 8A81      		ldd r24,Y+2
 228 006a 9B81      		ldd r25,Y+3
 229 006c 820F      		add r24,r18
 230 006e 931F      		adc r25,r19
 231 0070 9F83      		std Y+7,r25
 232 0072 8E83      		std Y+6,r24
 233               	.L6:
1824:FreeRTOS/Source/queue.c **** 		}
1825:FreeRTOS/Source/queue.c **** 		else
1826:FreeRTOS/Source/queue.c **** 		{
1827:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1828:FreeRTOS/Source/queue.c **** 		}
1829:FreeRTOS/Source/queue.c **** 
1830:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 235               	.LM12:
 236 0074 1230      		cpi r17,lo8(2)
 237 0076 01F4      		brne .L3
1831:FreeRTOS/Source/queue.c **** 		{
1832:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 239               	.LM13:
 240 0078 8A8D      		ldd r24,Y+26
 241 007a 8823      		tst r24
 242 007c 01F0      		breq .L3
1833:FreeRTOS/Source/queue.c **** 			{
1834:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1835:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
1836:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
1837:FreeRTOS/Source/queue.c **** 				correct. */
1838:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 244               	.LM14:
 245 007e 8A8D      		ldd r24,Y+26
 246 0080 8150      		subi r24,lo8(-(-1))
 247 0082 8A8F      		std Y+26,r24
 248               	.L3:
1839:FreeRTOS/Source/queue.c **** 			}
1840:FreeRTOS/Source/queue.c **** 			else
1841:FreeRTOS/Source/queue.c **** 			{
1842:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1843:FreeRTOS/Source/queue.c **** 			}
1844:FreeRTOS/Source/queue.c **** 		}
1845:FreeRTOS/Source/queue.c **** 		else
1846:FreeRTOS/Source/queue.c **** 		{
1847:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/queue.c **** 		}
1849:FreeRTOS/Source/queue.c **** 	}
1850:FreeRTOS/Source/queue.c **** 
1851:FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 250               	.LM15:
 251 0084 8A8D      		ldd r24,Y+26
 252 0086 8F5F      		subi r24,lo8(-(1))
 253 0088 8A8F      		std Y+26,r24
1852:FreeRTOS/Source/queue.c **** 
1853:FreeRTOS/Source/queue.c **** 	return xReturn;
1854:FreeRTOS/Source/queue.c **** }
 255               	.LM16:
 256 008a 80E0      		ldi r24,0
 257               	/* epilogue start */
 258 008c DF91      		pop r29
 259 008e CF91      		pop r28
 260 0090 1F91      		pop r17
 261 0092 0895      		ret
 263               	.Lscope1:
 265               		.stabd	78,0,0
 269               	prvCopyDataFromQueue:
 270               		.stabd	46,0,0
1855:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1856:FreeRTOS/Source/queue.c **** 
1857:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1858:FreeRTOS/Source/queue.c **** {
 272               	.LM17:
 273               	.LFBB2:
 274               	/* prologue: function */
 275               	/* frame size = 0 */
 276               	/* stack size = 0 */
 277               	.L__stack_usage = 0
 278 0094 FC01      		movw r30,r24
 279 0096 CB01      		movw r24,r22
1859:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 281               	.LM18:
 282 0098 448D      		ldd r20,Z+28
 283 009a 4423      		tst r20
 284 009c 01F0      		breq .L10
1860:FreeRTOS/Source/queue.c **** 	{
1861:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 286               	.LM19:
 287 009e 2681      		ldd r18,Z+6
 288 00a0 3781      		ldd r19,Z+7
 289 00a2 240F      		add r18,r20
 290 00a4 311D      		adc r19,__zero_reg__
 291 00a6 3783      		std Z+7,r19
 292 00a8 2683      		std Z+6,r18
1862:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 294               	.LM20:
 295 00aa A281      		ldd r26,Z+2
 296 00ac B381      		ldd r27,Z+3
 297 00ae 2A17      		cp r18,r26
 298 00b0 3B07      		cpc r19,r27
 299 00b2 00F0      		brlo .L12
1863:FreeRTOS/Source/queue.c **** 		{
1864:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 301               	.LM21:
 302 00b4 2081      		ld r18,Z
 303 00b6 3181      		ldd r19,Z+1
 304 00b8 3783      		std Z+7,r19
 305 00ba 2683      		std Z+6,r18
 306               	.L12:
1865:FreeRTOS/Source/queue.c **** 		}
1866:FreeRTOS/Source/queue.c **** 		else
1867:FreeRTOS/Source/queue.c **** 		{
1868:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1869:FreeRTOS/Source/queue.c **** 		}
1870:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 308               	.LM22:
 309 00bc 6681      		ldd r22,Z+6
 310 00be 7781      		ldd r23,Z+7
 311 00c0 50E0      		ldi r21,0
 312 00c2 0C94 0000 		jmp memcpy
 313               	.L10:
 314 00c6 0895      		ret
 316               	.Lscope2:
 318               		.stabd	78,0,0
 322               	prvUnlockQueue:
 323               		.stabd	46,0,0
1871:FreeRTOS/Source/queue.c **** 	}
1872:FreeRTOS/Source/queue.c **** }
1873:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1874:FreeRTOS/Source/queue.c **** 
1875:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1876:FreeRTOS/Source/queue.c **** {
 325               	.LM23:
 326               	.LFBB3:
 327 00c8 0F93      		push r16
 328 00ca 1F93      		push r17
 329 00cc CF93      		push r28
 330 00ce DF93      		push r29
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 4 */
 334               	.L__stack_usage = 4
 335 00d0 EC01      		movw r28,r24
1877:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1878:FreeRTOS/Source/queue.c **** 
1879:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1880:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1881:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1882:FreeRTOS/Source/queue.c **** 	updated. */
1883:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 337               	.LM24:
 338               	/* #APP */
 339               	 ;  1883 "FreeRTOS/Source/queue.c" 1
 340 00d2 0FB6      		in		__tmp_reg__, __SREG__
 341               	 ;  0 "" 2
 342               	 ;  1883 "FreeRTOS/Source/queue.c" 1
 343 00d4 F894      		cli
 344               	 ;  0 "" 2
 345               	 ;  1883 "FreeRTOS/Source/queue.c" 1
 346 00d6 0F92      		push	__tmp_reg__
 347               	 ;  0 "" 2
1884:FreeRTOS/Source/queue.c **** 	{
1885:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1886:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
1887:FreeRTOS/Source/queue.c **** 		{
1888:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1889:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1890:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1891:FreeRTOS/Source/queue.c **** 			{
1892:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1893:FreeRTOS/Source/queue.c **** 				{
1894:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1895:FreeRTOS/Source/queue.c **** 					{
1896:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1897:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1898:FreeRTOS/Source/queue.c **** 						A context switch is required. */
1899:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1900:FreeRTOS/Source/queue.c **** 					}
1901:FreeRTOS/Source/queue.c **** 					else
1902:FreeRTOS/Source/queue.c **** 					{
1903:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1904:FreeRTOS/Source/queue.c **** 					}
1905:FreeRTOS/Source/queue.c **** 				}
1906:FreeRTOS/Source/queue.c **** 				else
1907:FreeRTOS/Source/queue.c **** 				{
1908:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1909:FreeRTOS/Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1910:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1911:FreeRTOS/Source/queue.c **** 					{
1912:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1913:FreeRTOS/Source/queue.c **** 						{
1914:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1915:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1916:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
1917:FreeRTOS/Source/queue.c **** 						}
1918:FreeRTOS/Source/queue.c **** 						else
1919:FreeRTOS/Source/queue.c **** 						{
1920:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1921:FreeRTOS/Source/queue.c **** 						}
1922:FreeRTOS/Source/queue.c **** 					}
1923:FreeRTOS/Source/queue.c **** 					else
1924:FreeRTOS/Source/queue.c **** 					{
1925:FreeRTOS/Source/queue.c **** 						break;
1926:FreeRTOS/Source/queue.c **** 					}
1927:FreeRTOS/Source/queue.c **** 				}
1928:FreeRTOS/Source/queue.c **** 			}
1929:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1930:FreeRTOS/Source/queue.c **** 			{
1931:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1932:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1933:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1934:FreeRTOS/Source/queue.c **** 				{
1935:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 349               	.LM25:
 350               	/* #NOAPP */
 351 00d8 8C01      		movw r16,r24
 352 00da 0F5E      		subi r16,-17
 353 00dc 1F4F      		sbci r17,-1
1886:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 355               	.LM26:
 356 00de 00C0      		rjmp .L14
 357               	.L17:
1933:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 359               	.LM27:
 360 00e0 8989      		ldd r24,Y+17
 361 00e2 8823      		tst r24
 362 00e4 01F0      		breq .L15
 364               	.LM28:
 365 00e6 C801      		movw r24,r16
 366 00e8 0E94 0000 		call xTaskRemoveFromEventList
 367 00ec 8111      		cpse r24,__zero_reg__
1936:FreeRTOS/Source/queue.c **** 					{
1937:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1938:FreeRTOS/Source/queue.c **** 						context	switch is required. */
1939:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
 369               	.LM29:
 370 00ee 0E94 0000 		call vTaskMissedYield
 371               	.L16:
1940:FreeRTOS/Source/queue.c **** 					}
1941:FreeRTOS/Source/queue.c **** 					else
1942:FreeRTOS/Source/queue.c **** 					{
1943:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1944:FreeRTOS/Source/queue.c **** 					}
1945:FreeRTOS/Source/queue.c **** 				}
1946:FreeRTOS/Source/queue.c **** 				else
1947:FreeRTOS/Source/queue.c **** 				{
1948:FreeRTOS/Source/queue.c **** 					break;
1949:FreeRTOS/Source/queue.c **** 				}
1950:FreeRTOS/Source/queue.c **** 			}
1951:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1952:FreeRTOS/Source/queue.c **** 
1953:FreeRTOS/Source/queue.c **** 			--( pxQueue->xTxLock );
 373               	.LM30:
 374 00f2 8E8D      		ldd r24,Y+30
 375 00f4 8150      		subi r24,lo8(-(-1))
 376 00f6 8E8F      		std Y+30,r24
 377               	.L14:
1886:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 379               	.LM31:
 380 00f8 8E8D      		ldd r24,Y+30
 381 00fa 1816      		cp __zero_reg__,r24
 382 00fc 04F0      		brlt .L17
 383               	.L15:
1954:FreeRTOS/Source/queue.c **** 		}
1955:FreeRTOS/Source/queue.c **** 
1956:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 385               	.LM32:
 386 00fe 8FEF      		ldi r24,lo8(-1)
 387 0100 8E8F      		std Y+30,r24
1957:FreeRTOS/Source/queue.c **** 	}
1958:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 389               	.LM33:
 390               	/* #APP */
 391               	 ;  1958 "FreeRTOS/Source/queue.c" 1
 392 0102 0F90      		pop		__tmp_reg__
 393               	 ;  0 "" 2
 394               	 ;  1958 "FreeRTOS/Source/queue.c" 1
 395 0104 0FBE      		out		__SREG__, __tmp_reg__
 396               	 ;  0 "" 2
1959:FreeRTOS/Source/queue.c **** 
1960:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1961:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 398               	.LM34:
 399               	 ;  1961 "FreeRTOS/Source/queue.c" 1
 400 0106 0FB6      		in		__tmp_reg__, __SREG__
 401               	 ;  0 "" 2
 402               	 ;  1961 "FreeRTOS/Source/queue.c" 1
 403 0108 F894      		cli
 404               	 ;  0 "" 2
 405               	 ;  1961 "FreeRTOS/Source/queue.c" 1
 406 010a 0F92      		push	__tmp_reg__
 407               	 ;  0 "" 2
1962:FreeRTOS/Source/queue.c **** 	{
1963:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
1964:FreeRTOS/Source/queue.c **** 		{
1965:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1966:FreeRTOS/Source/queue.c **** 			{
1967:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 409               	.LM35:
 410               	/* #NOAPP */
 411 010c 8E01      		movw r16,r28
 412 010e 085F      		subi r16,-8
 413 0110 1F4F      		sbci r17,-1
1963:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 415               	.LM36:
 416 0112 00C0      		rjmp .L18
 417               	.L21:
1965:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 419               	.LM37:
 420 0114 8885      		ldd r24,Y+8
 421 0116 8823      		tst r24
 422 0118 01F0      		breq .L19
 424               	.LM38:
 425 011a C801      		movw r24,r16
 426 011c 0E94 0000 		call xTaskRemoveFromEventList
 427 0120 8111      		cpse r24,__zero_reg__
1968:FreeRTOS/Source/queue.c **** 				{
1969:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 429               	.LM39:
 430 0122 0E94 0000 		call vTaskMissedYield
 431               	.L20:
1970:FreeRTOS/Source/queue.c **** 				}
1971:FreeRTOS/Source/queue.c **** 				else
1972:FreeRTOS/Source/queue.c **** 				{
1973:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1974:FreeRTOS/Source/queue.c **** 				}
1975:FreeRTOS/Source/queue.c **** 
1976:FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 433               	.LM40:
 434 0126 8D8D      		ldd r24,Y+29
 435 0128 8150      		subi r24,lo8(-(-1))
 436 012a 8D8F      		std Y+29,r24
 437               	.L18:
1963:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 439               	.LM41:
 440 012c 8D8D      		ldd r24,Y+29
 441 012e 1816      		cp __zero_reg__,r24
 442 0130 04F0      		brlt .L21
 443               	.L19:
1977:FreeRTOS/Source/queue.c **** 			}
1978:FreeRTOS/Source/queue.c **** 			else
1979:FreeRTOS/Source/queue.c **** 			{
1980:FreeRTOS/Source/queue.c **** 				break;
1981:FreeRTOS/Source/queue.c **** 			}
1982:FreeRTOS/Source/queue.c **** 		}
1983:FreeRTOS/Source/queue.c **** 
1984:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 445               	.LM42:
 446 0132 8FEF      		ldi r24,lo8(-1)
 447 0134 8D8F      		std Y+29,r24
1985:FreeRTOS/Source/queue.c **** 	}
1986:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 449               	.LM43:
 450               	/* #APP */
 451               	 ;  1986 "FreeRTOS/Source/queue.c" 1
 452 0136 0F90      		pop		__tmp_reg__
 453               	 ;  0 "" 2
 454               	 ;  1986 "FreeRTOS/Source/queue.c" 1
 455 0138 0FBE      		out		__SREG__, __tmp_reg__
 456               	 ;  0 "" 2
 457               	/* epilogue start */
1987:FreeRTOS/Source/queue.c **** }
 459               	.LM44:
 460               	/* #NOAPP */
 461 013a DF91      		pop r29
 462 013c CF91      		pop r28
 463 013e 1F91      		pop r17
 464 0140 0F91      		pop r16
 465 0142 0895      		ret
 467               	.Lscope3:
 469               		.stabd	78,0,0
 473               	.global	xQueueGenericReset
 475               	xQueueGenericReset:
 476               		.stabd	46,0,0
 261:FreeRTOS/Source/queue.c **** {
 478               	.LM45:
 479               	.LFBB4:
 480 0144 CF93      		push r28
 481 0146 DF93      		push r29
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 2 */
 485               	.L__stack_usage = 2
 486 0148 EC01      		movw r28,r24
 266:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 488               	.LM46:
 489               	/* #APP */
 490               	 ;  266 "FreeRTOS/Source/queue.c" 1
 491 014a 0FB6      		in		__tmp_reg__, __SREG__
 492               	 ;  0 "" 2
 493               	 ;  266 "FreeRTOS/Source/queue.c" 1
 494 014c F894      		cli
 495               	 ;  0 "" 2
 496               	 ;  266 "FreeRTOS/Source/queue.c" 1
 497 014e 0F92      		push	__tmp_reg__
 498               	 ;  0 "" 2
 268:FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 500               	.LM47:
 501               	/* #NOAPP */
 502 0150 2881      		ld r18,Y
 503 0152 3981      		ldd r19,Y+1
 504 0154 4B8D      		ldd r20,Y+27
 505 0156 7C8D      		ldd r23,Y+28
 506 0158 C901      		movw r24,r18
 507 015a 479F      		mul r20,r23
 508 015c 800D      		add r24,r0
 509 015e 911D      		adc r25,r1
 510 0160 1124      		clr __zero_reg__
 511 0162 9B83      		std Y+3,r25
 512 0164 8A83      		std Y+2,r24
 269:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 514               	.LM48:
 515 0166 1A8E      		std Y+26,__zero_reg__
 270:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 517               	.LM49:
 518 0168 3D83      		std Y+5,r19
 519 016a 2C83      		std Y+4,r18
 268:FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 521               	.LM50:
 522 016c 50E0      		ldi r21,0
 271:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 524               	.LM51:
 525 016e 4150      		subi r20,1
 526 0170 5109      		sbc r21,__zero_reg__
 527 0172 749F      		mul r23,r20
 528 0174 C001      		movw r24,r0
 529 0176 759F      		mul r23,r21
 530 0178 900D      		add r25,r0
 531 017a 1124      		clr __zero_reg__
 532 017c 820F      		add r24,r18
 533 017e 931F      		adc r25,r19
 534 0180 9F83      		std Y+7,r25
 535 0182 8E83      		std Y+6,r24
 272:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 537               	.LM52:
 538 0184 8FEF      		ldi r24,lo8(-1)
 539 0186 8D8F      		std Y+29,r24
 273:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 541               	.LM53:
 542 0188 8E8F      		std Y+30,r24
 275:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 544               	.LM54:
 545 018a 6111      		cpse r22,__zero_reg__
 546 018c 00C0      		rjmp .L35
 282:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 548               	.LM55:
 549 018e 8885      		ldd r24,Y+8
 550 0190 8823      		tst r24
 551 0192 01F0      		breq .L37
 284:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 553               	.LM56:
 554 0194 CE01      		movw r24,r28
 555 0196 0896      		adiw r24,8
 556 0198 0E94 0000 		call xTaskRemoveFromEventList
 557 019c 8130      		cpi r24,lo8(1)
 558 019e 01F4      		brne .L37
 286:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 560               	.LM57:
 561 01a0 0E94 0000 		call vPortYield
 562 01a4 00C0      		rjmp .L37
 563               	.L35:
 301:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 565               	.LM58:
 566 01a6 CE01      		movw r24,r28
 567 01a8 0896      		adiw r24,8
 568 01aa 0E94 0000 		call vListInitialise
 302:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 570               	.LM59:
 571 01ae CE01      		movw r24,r28
 572 01b0 4196      		adiw r24,17
 573 01b2 0E94 0000 		call vListInitialise
 574               	.L37:
 305:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 576               	.LM60:
 577               	/* #APP */
 578               	 ;  305 "FreeRTOS/Source/queue.c" 1
 579 01b6 0F90      		pop		__tmp_reg__
 580               	 ;  0 "" 2
 581               	 ;  305 "FreeRTOS/Source/queue.c" 1
 582 01b8 0FBE      		out		__SREG__, __tmp_reg__
 583               	 ;  0 "" 2
 310:FreeRTOS/Source/queue.c **** }
 585               	.LM61:
 586               	/* #NOAPP */
 587 01ba 81E0      		ldi r24,lo8(1)
 588               	/* epilogue start */
 589 01bc DF91      		pop r29
 590 01be CF91      		pop r28
 591 01c0 0895      		ret
 593               	.Lscope4:
 595               		.stabd	78,0,0
 600               	.global	xQueueGenericCreate
 602               	xQueueGenericCreate:
 603               		.stabd	46,0,0
 314:FreeRTOS/Source/queue.c **** {
 605               	.LM62:
 606               	.LFBB5:
 607 01c2 EF92      		push r14
 608 01c4 FF92      		push r15
 609 01c6 1F93      		push r17
 610 01c8 CF93      		push r28
 611 01ca DF93      		push r29
 612 01cc 1F92      		push __zero_reg__
 613 01ce CDB7      		in r28,__SP_L__
 614 01d0 DEB7      		in r29,__SP_H__
 615               	/* prologue: function */
 616               	/* frame size = 1 */
 617               	/* stack size = 6 */
 618               	.L__stack_usage = 6
 619 01d2 182F      		mov r17,r24
 326:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 621               	.LM63:
 622 01d4 6623      		tst r22
 623 01d6 01F0      		breq .L44
 335:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA 
 625               	.LM64:
 626 01d8 869F      		mul r24,r22
 627 01da C001      		movw r24,r0
 628 01dc 1124      		clr __zero_reg__
 629 01de 0196      		adiw r24,1
 630 01e0 00C0      		rjmp .L40
 631               	.L44:
 329:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) 0;
 633               	.LM65:
 634 01e2 80E0      		ldi r24,0
 635 01e4 90E0      		ldi r25,0
 636               	.L40:
 339:FreeRTOS/Source/queue.c **** 	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 638               	.LM66:
 639 01e6 4F96      		adiw r24,31
 640 01e8 6983      		std Y+1,r22
 641 01ea 0E94 0000 		call pvPortMalloc
 642 01ee 7C01      		movw r14,r24
 341:FreeRTOS/Source/queue.c **** 	if( pcAllocatedBuffer != NULL )
 644               	.LM67:
 645 01f0 6981      		ldd r22,Y+1
 646 01f2 0097      		sbiw r24,0
 647 01f4 01F0      		breq .L45
 345:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 649               	.LM68:
 650 01f6 6111      		cpse r22,__zero_reg__
 651 01f8 00C0      		rjmp .L42
 351:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 653               	.LM69:
 654 01fa FC01      		movw r30,r24
 655 01fc 9183      		std Z+1,r25
 656 01fe 8083      		st Z,r24
 657 0200 00C0      		rjmp .L43
 658               	.L42:
 357:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
 660               	.LM70:
 661 0202 9C01      		movw r18,r24
 662 0204 215E      		subi r18,-31
 663 0206 3F4F      		sbci r19,-1
 664 0208 FC01      		movw r30,r24
 665 020a 3183      		std Z+1,r19
 666 020c 2083      		st Z,r18
 667               	.L43:
 362:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxLength = uxQueueLength;
 669               	.LM71:
 670 020e F701      		movw r30,r14
 671 0210 138F      		std Z+27,r17
 363:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxItemSize = uxItemSize;
 673               	.LM72:
 674 0212 648F      		std Z+28,r22
 364:FreeRTOS/Source/queue.c **** 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 676               	.LM73:
 677 0214 61E0      		ldi r22,lo8(1)
 678 0216 C701      		movw r24,r14
 679 0218 0E94 0000 		call xQueueGenericReset
 680 021c C701      		movw r24,r14
 681 021e 00C0      		rjmp .L41
 682               	.L45:
 317:FreeRTOS/Source/queue.c **** QueueHandle_t xReturn = NULL;
 684               	.LM74:
 685 0220 80E0      		ldi r24,0
 686 0222 90E0      		ldi r25,0
 687               	.L41:
 688               	/* epilogue start */
 389:FreeRTOS/Source/queue.c **** }
 690               	.LM75:
 691 0224 0F90      		pop __tmp_reg__
 692 0226 DF91      		pop r29
 693 0228 CF91      		pop r28
 694 022a 1F91      		pop r17
 695 022c FF90      		pop r15
 696 022e EF90      		pop r14
 697 0230 0895      		ret
 704               	.Lscope5:
 706               		.stabd	78,0,0
 712               	.global	xQueueGenericSend
 714               	xQueueGenericSend:
 715               		.stabd	46,0,0
 614:FreeRTOS/Source/queue.c **** {
 717               	.LM76:
 718               	.LFBB6:
 719 0232 BF92      		push r11
 720 0234 CF92      		push r12
 721 0236 DF92      		push r13
 722 0238 EF92      		push r14
 723 023a FF92      		push r15
 724 023c 0F93      		push r16
 725 023e 1F93      		push r17
 726 0240 CF93      		push r28
 727 0242 DF93      		push r29
 728 0244 00D0      		rcall .
 729 0246 00D0      		rcall .
 730 0248 1F92      		push __zero_reg__
 731 024a CDB7      		in r28,__SP_L__
 732 024c DEB7      		in r29,__SP_H__
 733               	/* prologue: function */
 734               	/* frame size = 5 */
 735               	/* stack size = 14 */
 736               	.L__stack_usage = 14
 737 024e 8C01      		movw r16,r24
 738 0250 6B01      		movw r12,r22
 739 0252 5D83      		std Y+5,r21
 740 0254 4C83      		std Y+4,r20
 741 0256 B22E      		mov r11,r18
 615:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 743               	.LM77:
 744 0258 20E0      		ldi r18,0
 772:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 746               	.LM78:
 747 025a 7C01      		movw r14,r24
 748 025c 88E0      		ldi r24,8
 749 025e E80E      		add r14,r24
 750 0260 F11C      		adc r15,__zero_reg__
 751 0262 00C0      		rjmp .L47
 752               	.L61:
 753 0264 21E0      		ldi r18,lo8(1)
 754               	.L47:
 634:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 756               	.LM79:
 757               	/* #APP */
 758               	 ;  634 "FreeRTOS/Source/queue.c" 1
 759 0266 0FB6      		in		__tmp_reg__, __SREG__
 760               	 ;  0 "" 2
 761               	 ;  634 "FreeRTOS/Source/queue.c" 1
 762 0268 F894      		cli
 763               	 ;  0 "" 2
 764               	 ;  634 "FreeRTOS/Source/queue.c" 1
 765 026a 0F92      		push	__tmp_reg__
 766               	 ;  0 "" 2
 640:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 768               	.LM80:
 769               	/* #NOAPP */
 770 026c F801      		movw r30,r16
 771 026e 928D      		ldd r25,Z+26
 772 0270 838D      		ldd r24,Z+27
 773 0272 9817      		cp r25,r24
 774 0274 00F0      		brlo .L48
 640:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 776               	.LM81:
 777 0276 F2E0      		ldi r31,lo8(2)
 778 0278 BF12      		cpse r11,r31
 779 027a 00C0      		rjmp .L49
 780               	.L48:
 643:FreeRTOS/Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 782               	.LM82:
 783 027c 4B2D      		mov r20,r11
 784 027e B601      		movw r22,r12
 785 0280 C801      		movw r24,r16
 786 0282 0E94 0000 		call prvCopyDataToQueue
 698:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 788               	.LM83:
 789 0286 F801      		movw r30,r16
 790 0288 9189      		ldd r25,Z+17
 791 028a 9923      		tst r25
 792 028c 01F0      		breq .L50
 700:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 794               	.LM84:
 795 028e C801      		movw r24,r16
 796 0290 4196      		adiw r24,17
 797 0292 0E94 0000 		call xTaskRemoveFromEventList
 798 0296 8130      		cpi r24,lo8(1)
 799 0298 01F4      		brne .L52
 800               	.L51:
 706:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 802               	.LM85:
 803 029a 0E94 0000 		call vPortYield
 804 029e 00C0      		rjmp .L52
 805               	.L50:
 713:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 807               	.LM86:
 808 02a0 8111      		cpse r24,__zero_reg__
 809 02a2 00C0      		rjmp .L51
 810               	.L52:
 728:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 812               	.LM87:
 813               	/* #APP */
 814               	 ;  728 "FreeRTOS/Source/queue.c" 1
 815 02a4 0F90      		pop		__tmp_reg__
 816               	 ;  0 "" 2
 817               	 ;  728 "FreeRTOS/Source/queue.c" 1
 818 02a6 0FBE      		out		__SREG__, __tmp_reg__
 819               	 ;  0 "" 2
 729:FreeRTOS/Source/queue.c **** 				return pdPASS;
 821               	.LM88:
 822               	/* #NOAPP */
 823 02a8 81E0      		ldi r24,lo8(1)
 824 02aa 00C0      		rjmp .L54
 825               	.L49:
 733:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 827               	.LM89:
 828 02ac 8C81      		ldd r24,Y+4
 829 02ae 9D81      		ldd r25,Y+5
 830 02b0 892B      		or r24,r25
 831 02b2 01F4      		brne .L55
 737:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 833               	.LM90:
 834               	/* #APP */
 835               	 ;  737 "FreeRTOS/Source/queue.c" 1
 836 02b4 0F90      		pop		__tmp_reg__
 837               	 ;  0 "" 2
 838               	 ;  737 "FreeRTOS/Source/queue.c" 1
 839 02b6 0FBE      		out		__SREG__, __tmp_reg__
 840               	 ;  0 "" 2
 841               	/* #NOAPP */
 842 02b8 00C0      		rjmp .L65
 843               	.L55:
 744:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 845               	.LM91:
 846 02ba 2111      		cpse r18,__zero_reg__
 847 02bc 00C0      		rjmp .L56
 748:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 849               	.LM92:
 850 02be CE01      		movw r24,r28
 851 02c0 0196      		adiw r24,1
 852 02c2 0E94 0000 		call vTaskSetTimeOutState
 853               	.L56:
 758:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 855               	.LM93:
 856               	/* #APP */
 857               	 ;  758 "FreeRTOS/Source/queue.c" 1
 858 02c6 0F90      		pop		__tmp_reg__
 859               	 ;  0 "" 2
 860               	 ;  758 "FreeRTOS/Source/queue.c" 1
 861 02c8 0FBE      		out		__SREG__, __tmp_reg__
 862               	 ;  0 "" 2
 763:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 864               	.LM94:
 865               	/* #NOAPP */
 866 02ca 0E94 0000 		call vTaskSuspendAll
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 868               	.LM95:
 869               	/* #APP */
 870               	 ;  764 "FreeRTOS/Source/queue.c" 1
 871 02ce 0FB6      		in		__tmp_reg__, __SREG__
 872               	 ;  0 "" 2
 873               	 ;  764 "FreeRTOS/Source/queue.c" 1
 874 02d0 F894      		cli
 875               	 ;  0 "" 2
 876               	 ;  764 "FreeRTOS/Source/queue.c" 1
 877 02d2 0F92      		push	__tmp_reg__
 878               	 ;  0 "" 2
 879               	/* #NOAPP */
 880 02d4 F801      		movw r30,r16
 881 02d6 858D      		ldd r24,Z+29
 882 02d8 8F3F      		cpi r24,lo8(-1)
 883 02da 01F4      		brne .L57
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 885               	.LM96:
 886 02dc 158E      		std Z+29,__zero_reg__
 887               	.L57:
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 889               	.LM97:
 890 02de F801      		movw r30,r16
 891 02e0 868D      		ldd r24,Z+30
 892 02e2 8F3F      		cpi r24,lo8(-1)
 893 02e4 01F4      		brne .L58
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 895               	.LM98:
 896 02e6 168E      		std Z+30,__zero_reg__
 897               	.L58:
 764:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 899               	.LM99:
 900               	/* #APP */
 901               	 ;  764 "FreeRTOS/Source/queue.c" 1
 902 02e8 0F90      		pop		__tmp_reg__
 903               	 ;  0 "" 2
 904               	 ;  764 "FreeRTOS/Source/queue.c" 1
 905 02ea 0FBE      		out		__SREG__, __tmp_reg__
 906               	 ;  0 "" 2
 767:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 908               	.LM100:
 909               	/* #NOAPP */
 910 02ec BE01      		movw r22,r28
 911 02ee 6C5F      		subi r22,-4
 912 02f0 7F4F      		sbci r23,-1
 913 02f2 CE01      		movw r24,r28
 914 02f4 0196      		adiw r24,1
 915 02f6 0E94 0000 		call xTaskCheckForTimeOut
 916 02fa 8111      		cpse r24,__zero_reg__
 917 02fc 00C0      		rjmp .L59
 918               	.LBB4:
 919               	.LBB5:
1988:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1989:FreeRTOS/Source/queue.c **** 
1990:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1991:FreeRTOS/Source/queue.c **** {
1992:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1993:FreeRTOS/Source/queue.c **** 
1994:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1995:FreeRTOS/Source/queue.c **** 	{
1996:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
1997:FreeRTOS/Source/queue.c **** 		{
1998:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
1999:FreeRTOS/Source/queue.c **** 		}
2000:FreeRTOS/Source/queue.c **** 		else
2001:FreeRTOS/Source/queue.c **** 		{
2002:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2003:FreeRTOS/Source/queue.c **** 		}
2004:FreeRTOS/Source/queue.c **** 	}
2005:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2006:FreeRTOS/Source/queue.c **** 
2007:FreeRTOS/Source/queue.c **** 	return xReturn;
2008:FreeRTOS/Source/queue.c **** }
2009:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2010:FreeRTOS/Source/queue.c **** 
2011:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2012:FreeRTOS/Source/queue.c **** {
2013:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2014:FreeRTOS/Source/queue.c **** 
2015:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2016:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
2017:FreeRTOS/Source/queue.c **** 	{
2018:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2019:FreeRTOS/Source/queue.c **** 	}
2020:FreeRTOS/Source/queue.c **** 	else
2021:FreeRTOS/Source/queue.c **** 	{
2022:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2023:FreeRTOS/Source/queue.c **** 	}
2024:FreeRTOS/Source/queue.c **** 
2025:FreeRTOS/Source/queue.c **** 	return xReturn;
2026:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2027:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2028:FreeRTOS/Source/queue.c **** 
2029:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2030:FreeRTOS/Source/queue.c **** {
2031:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2032:FreeRTOS/Source/queue.c **** 
2033:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 921               	.LM101:
 922               	/* #APP */
 923               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 924 02fe 0FB6      		in		__tmp_reg__, __SREG__
 925               	 ;  0 "" 2
 926               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 927 0300 F894      		cli
 928               	 ;  0 "" 2
 929               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 930 0302 0F92      		push	__tmp_reg__
 931               	 ;  0 "" 2
2034:FreeRTOS/Source/queue.c **** 	{
2035:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 933               	.LM102:
 934               	/* #NOAPP */
 935 0304 F801      		movw r30,r16
 936 0306 928D      		ldd r25,Z+26
2036:FreeRTOS/Source/queue.c **** 		{
2037:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2038:FreeRTOS/Source/queue.c **** 		}
2039:FreeRTOS/Source/queue.c **** 		else
2040:FreeRTOS/Source/queue.c **** 		{
2041:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2042:FreeRTOS/Source/queue.c **** 		}
2043:FreeRTOS/Source/queue.c **** 	}
2044:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 938               	.LM103:
 939               	/* #APP */
 940               	 ;  2044 "FreeRTOS/Source/queue.c" 1
 941 0308 0F90      		pop		__tmp_reg__
 942               	 ;  0 "" 2
 943               	 ;  2044 "FreeRTOS/Source/queue.c" 1
 944 030a 0FBE      		out		__SREG__, __tmp_reg__
 945               	 ;  0 "" 2
 946               	/* #NOAPP */
 947               	.LBE5:
 948               	.LBE4:
 769:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 950               	.LM104:
 951 030c F801      		movw r30,r16
 952 030e 838D      		ldd r24,Z+27
 953 0310 9813      		cpse r25,r24
 954 0312 00C0      		rjmp .L60
 772:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 956               	.LM105:
 957 0314 6C81      		ldd r22,Y+4
 958 0316 7D81      		ldd r23,Y+5
 959 0318 C701      		movw r24,r14
 960 031a 0E94 0000 		call vTaskPlaceOnEventList
 779:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 962               	.LM106:
 963 031e C801      		movw r24,r16
 964 0320 0E94 0000 		call prvUnlockQueue
 786:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 966               	.LM107:
 967 0324 0E94 0000 		call xTaskResumeAll
 968 0328 8111      		cpse r24,__zero_reg__
 969 032a 00C0      		rjmp .L61
 788:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 971               	.LM108:
 972 032c 0E94 0000 		call vPortYield
 973 0330 00C0      		rjmp .L61
 974               	.L60:
 794:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 976               	.LM109:
 977 0332 C801      		movw r24,r16
 978 0334 0E94 0000 		call prvUnlockQueue
 795:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 980               	.LM110:
 981 0338 0E94 0000 		call xTaskResumeAll
 982 033c 00C0      		rjmp .L61
 983               	.L59:
 801:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 985               	.LM111:
 986 033e C801      		movw r24,r16
 987 0340 0E94 0000 		call prvUnlockQueue
 802:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 989               	.LM112:
 990 0344 0E94 0000 		call xTaskResumeAll
 991               	.L65:
 807:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 993               	.LM113:
 994 0348 80E0      		ldi r24,0
 995               	.L54:
 996               	/* epilogue start */
 810:FreeRTOS/Source/queue.c **** }
 998               	.LM114:
 999 034a 0F90      		pop __tmp_reg__
 1000 034c 0F90      		pop __tmp_reg__
 1001 034e 0F90      		pop __tmp_reg__
 1002 0350 0F90      		pop __tmp_reg__
 1003 0352 0F90      		pop __tmp_reg__
 1004 0354 DF91      		pop r29
 1005 0356 CF91      		pop r28
 1006 0358 1F91      		pop r17
 1007 035a 0F91      		pop r16
 1008 035c FF90      		pop r15
 1009 035e EF90      		pop r14
 1010 0360 DF90      		pop r13
 1011 0362 CF90      		pop r12
 1012 0364 BF90      		pop r11
 1013 0366 0895      		ret
 1020               	.Lscope6:
 1022               		.stabd	78,0,0
 1028               	.global	xQueueGenericSendFromISR
 1030               	xQueueGenericSendFromISR:
 1031               		.stabd	46,0,0
1059:FreeRTOS/Source/queue.c **** {
 1033               	.LM115:
 1034               	.LFBB7:
 1035 0368 0F93      		push r16
 1036 036a 1F93      		push r17
 1037 036c CF93      		push r28
 1038 036e DF93      		push r29
 1039               	/* prologue: function */
 1040               	/* frame size = 0 */
 1041               	/* stack size = 4 */
 1042               	.L__stack_usage = 4
 1043 0370 EC01      		movw r28,r24
 1044 0372 8A01      		movw r16,r20
1091:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1046               	.LM116:
 1047 0374 9A8D      		ldd r25,Y+26
 1048 0376 8B8D      		ldd r24,Y+27
 1049 0378 9817      		cp r25,r24
 1050 037a 00F0      		brlo .L67
1091:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1052               	.LM117:
 1053 037c 2230      		cpi r18,lo8(2)
 1054 037e 01F4      		brne .L72
 1055               	.L67:
1100:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1057               	.LM118:
 1058 0380 422F      		mov r20,r18
 1059 0382 CE01      		movw r24,r28
 1060 0384 0E94 0000 		call prvCopyDataToQueue
1104:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1062               	.LM119:
 1063 0388 8E8D      		ldd r24,Y+30
 1064 038a 8F3F      		cpi r24,lo8(-1)
 1065 038c 01F4      		brne .L69
1159:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1067               	.LM120:
 1068 038e 8989      		ldd r24,Y+17
 1069 0390 8111      		cpse r24,__zero_reg__
 1070 0392 00C0      		rjmp .L70
 1071 0394 00C0      		rjmp .L79
 1072               	.L70:
1161:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1074               	.LM121:
 1075 0396 CE01      		movw r24,r28
 1076 0398 4196      		adiw r24,17
 1077 039a 0E94 0000 		call xTaskRemoveFromEventList
 1078 039e 8823      		tst r24
 1079 03a0 01F0      		breq .L79
1165:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1081               	.LM122:
 1082 03a2 0115      		cp r16,__zero_reg__
 1083 03a4 1105      		cpc r17,__zero_reg__
 1084 03a6 01F0      		breq .L79
1167:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1086               	.LM123:
 1087 03a8 81E0      		ldi r24,lo8(1)
 1088 03aa F801      		movw r30,r16
 1089 03ac 8083      		st Z,r24
 1090 03ae 00C0      		rjmp .L68
 1091               	.L69:
1190:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 1093               	.LM124:
 1094 03b0 8E8D      		ldd r24,Y+30
 1095 03b2 8F5F      		subi r24,lo8(-(1))
 1096 03b4 8E8F      		std Y+30,r24
 1097               	.L79:
1193:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1099               	.LM125:
 1100 03b6 81E0      		ldi r24,lo8(1)
 1101 03b8 00C0      		rjmp .L68
 1102               	.L72:
1198:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1104               	.LM126:
 1105 03ba 80E0      		ldi r24,0
 1106               	.L68:
 1107               	/* epilogue start */
1204:FreeRTOS/Source/queue.c **** }
 1109               	.LM127:
 1110 03bc DF91      		pop r29
 1111 03be CF91      		pop r28
 1112 03c0 1F91      		pop r17
 1113 03c2 0F91      		pop r16
 1114 03c4 0895      		ret
 1119               	.Lscope7:
 1121               		.stabd	78,0,0
 1125               	.global	xQueueGiveFromISR
 1127               	xQueueGiveFromISR:
 1128               		.stabd	46,0,0
1208:FreeRTOS/Source/queue.c **** {
 1130               	.LM128:
 1131               	.LFBB8:
 1132 03c6 CF93      		push r28
 1133 03c8 DF93      		push r29
 1134               	/* prologue: function */
 1135               	/* frame size = 0 */
 1136               	/* stack size = 2 */
 1137               	.L__stack_usage = 2
 1138 03ca FC01      		movw r30,r24
 1139 03cc EB01      		movw r28,r22
1244:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 1141               	.LM129:
 1142 03ce 928D      		ldd r25,Z+26
 1143 03d0 838D      		ldd r24,Z+27
 1144 03d2 9817      		cp r25,r24
 1145 03d4 00F4      		brsh .L85
1254:FreeRTOS/Source/queue.c **** 			++( pxQueue->uxMessagesWaiting );
 1147               	.LM130:
 1148 03d6 828D      		ldd r24,Z+26
 1149 03d8 8F5F      		subi r24,lo8(-(1))
 1150 03da 828F      		std Z+26,r24
1258:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1152               	.LM131:
 1153 03dc 868D      		ldd r24,Z+30
 1154 03de 8F3F      		cpi r24,lo8(-1)
 1155 03e0 01F4      		brne .L82
1313:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1157               	.LM132:
 1158 03e2 8189      		ldd r24,Z+17
 1159 03e4 8111      		cpse r24,__zero_reg__
 1160 03e6 00C0      		rjmp .L83
 1161 03e8 00C0      		rjmp .L92
 1162               	.L83:
1315:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1164               	.LM133:
 1165 03ea CF01      		movw r24,r30
 1166 03ec 4196      		adiw r24,17
 1167 03ee 0E94 0000 		call xTaskRemoveFromEventList
 1168 03f2 8823      		tst r24
 1169 03f4 01F0      		breq .L92
1319:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1171               	.LM134:
 1172 03f6 2097      		sbiw r28,0
 1173 03f8 01F0      		breq .L92
1321:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1175               	.LM135:
 1176 03fa 81E0      		ldi r24,lo8(1)
 1177 03fc 8883      		st Y,r24
 1178 03fe 00C0      		rjmp .L81
 1179               	.L82:
1344:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 1181               	.LM136:
 1182 0400 868D      		ldd r24,Z+30
 1183 0402 8F5F      		subi r24,lo8(-(1))
 1184 0404 868F      		std Z+30,r24
 1185               	.L92:
1347:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1187               	.LM137:
 1188 0406 81E0      		ldi r24,lo8(1)
 1189 0408 00C0      		rjmp .L81
 1190               	.L85:
1352:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1192               	.LM138:
 1193 040a 80E0      		ldi r24,0
 1194               	.L81:
 1195               	/* epilogue start */
1358:FreeRTOS/Source/queue.c **** }
 1197               	.LM139:
 1198 040c DF91      		pop r29
 1199 040e CF91      		pop r28
 1200 0410 0895      		ret
 1205               	.Lscope8:
 1207               		.stabd	78,0,0
 1213               	.global	xQueueGenericReceive
 1215               	xQueueGenericReceive:
 1216               		.stabd	46,0,0
1362:FreeRTOS/Source/queue.c **** {
 1218               	.LM140:
 1219               	.LFBB9:
 1220 0412 BF92      		push r11
 1221 0414 CF92      		push r12
 1222 0416 DF92      		push r13
 1223 0418 EF92      		push r14
 1224 041a FF92      		push r15
 1225 041c 0F93      		push r16
 1226 041e 1F93      		push r17
 1227 0420 CF93      		push r28
 1228 0422 DF93      		push r29
 1229 0424 00D0      		rcall .
 1230 0426 00D0      		rcall .
 1231 0428 1F92      		push __zero_reg__
 1232 042a CDB7      		in r28,__SP_L__
 1233 042c DEB7      		in r29,__SP_H__
 1234               	/* prologue: function */
 1235               	/* frame size = 5 */
 1236               	/* stack size = 14 */
 1237               	.L__stack_usage = 14
 1238 042e 8C01      		movw r16,r24
 1239 0430 6B01      		movw r12,r22
 1240 0432 5D83      		std Y+5,r21
 1241 0434 4C83      		std Y+4,r20
 1242 0436 B22E      		mov r11,r18
1363:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1244               	.LM141:
 1245 0438 30E0      		ldi r19,0
1521:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1247               	.LM142:
 1248 043a 7C01      		movw r14,r24
 1249 043c 81E1      		ldi r24,17
 1250 043e E80E      		add r14,r24
 1251 0440 F11C      		adc r15,__zero_reg__
 1252 0442 00C0      		rjmp .L94
 1253               	.L108:
 1254 0444 31E0      		ldi r19,lo8(1)
 1255               	.L94:
1382:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 1257               	.LM143:
 1258               	/* #APP */
 1259               	 ;  1382 "FreeRTOS/Source/queue.c" 1
 1260 0446 0FB6      		in		__tmp_reg__, __SREG__
 1261               	 ;  0 "" 2
 1262               	 ;  1382 "FreeRTOS/Source/queue.c" 1
 1263 0448 F894      		cli
 1264               	 ;  0 "" 2
 1265               	 ;  1382 "FreeRTOS/Source/queue.c" 1
 1266 044a 0F92      		push	__tmp_reg__
 1267               	 ;  0 "" 2
1386:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1269               	.LM144:
 1270               	/* #NOAPP */
 1271 044c F801      		movw r30,r16
 1272 044e 828D      		ldd r24,Z+26
 1273 0450 8823      		tst r24
 1274 0452 01F0      		breq .L95
1390:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1276               	.LM145:
 1277 0454 E680      		ldd r14,Z+6
 1278 0456 F780      		ldd r15,Z+7
1392:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1280               	.LM146:
 1281 0458 B601      		movw r22,r12
 1282 045a C801      		movw r24,r16
 1283 045c 0E94 0000 		call prvCopyDataFromQueue
1399:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1285               	.LM147:
 1286 0460 F801      		movw r30,r16
1394:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1288               	.LM148:
 1289 0462 B110      		cpse r11,__zero_reg__
 1290 0464 00C0      		rjmp .L96
1399:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1292               	.LM149:
 1293 0466 828D      		ldd r24,Z+26
 1294 0468 8150      		subi r24,lo8(-(-1))
 1295 046a 828F      		std Z+26,r24
1416:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1297               	.LM150:
 1298 046c 8085      		ldd r24,Z+8
 1299 046e 8823      		tst r24
 1300 0470 01F0      		breq .L98
1418:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1302               	.LM151:
 1303 0472 C801      		movw r24,r16
 1304 0474 0896      		adiw r24,8
 1305 0476 0E94 0000 		call xTaskRemoveFromEventList
 1306 047a 8130      		cpi r24,lo8(1)
 1307 047c 01F4      		brne .L98
 1308               	.L100:
1420:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1310               	.LM152:
 1311 047e 0E94 0000 		call vPortYield
 1312 0482 00C0      		rjmp .L98
 1313               	.L96:
1438:FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1315               	.LM153:
 1316 0484 F782      		std Z+7,r15
 1317 0486 E682      		std Z+6,r14
1442:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1319               	.LM154:
 1320 0488 8189      		ldd r24,Z+17
 1321 048a 8823      		tst r24
 1322 048c 01F0      		breq .L98
1446:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1324               	.LM155:
 1325 048e C801      		movw r24,r16
 1326 0490 4196      		adiw r24,17
 1327 0492 0E94 0000 		call xTaskRemoveFromEventList
 1328 0496 8111      		cpse r24,__zero_reg__
 1329 0498 00C0      		rjmp .L100
 1330               	.L98:
1462:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 1332               	.LM156:
 1333               	/* #APP */
 1334               	 ;  1462 "FreeRTOS/Source/queue.c" 1
 1335 049a 0F90      		pop		__tmp_reg__
 1336               	 ;  0 "" 2
 1337               	 ;  1462 "FreeRTOS/Source/queue.c" 1
 1338 049c 0FBE      		out		__SREG__, __tmp_reg__
 1339               	 ;  0 "" 2
1463:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1341               	.LM157:
 1342               	/* #NOAPP */
 1343 049e 81E0      		ldi r24,lo8(1)
 1344 04a0 00C0      		rjmp .L101
 1345               	.L95:
1467:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1347               	.LM158:
 1348 04a2 8C81      		ldd r24,Y+4
 1349 04a4 9D81      		ldd r25,Y+5
 1350 04a6 892B      		or r24,r25
 1351 04a8 01F4      		brne .L102
1471:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 1353               	.LM159:
 1354               	/* #APP */
 1355               	 ;  1471 "FreeRTOS/Source/queue.c" 1
 1356 04aa 0F90      		pop		__tmp_reg__
 1357               	 ;  0 "" 2
 1358               	 ;  1471 "FreeRTOS/Source/queue.c" 1
 1359 04ac 0FBE      		out		__SREG__, __tmp_reg__
 1360               	 ;  0 "" 2
 1361               	/* #NOAPP */
 1362 04ae 00C0      		rjmp .L112
 1363               	.L102:
1475:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1365               	.LM160:
 1366 04b0 3111      		cpse r19,__zero_reg__
 1367 04b2 00C0      		rjmp .L103
1479:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1369               	.LM161:
 1370 04b4 CE01      		movw r24,r28
 1371 04b6 0196      		adiw r24,1
 1372 04b8 0E94 0000 		call vTaskSetTimeOutState
 1373               	.L103:
1489:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 1375               	.LM162:
 1376               	/* #APP */
 1377               	 ;  1489 "FreeRTOS/Source/queue.c" 1
 1378 04bc 0F90      		pop		__tmp_reg__
 1379               	 ;  0 "" 2
 1380               	 ;  1489 "FreeRTOS/Source/queue.c" 1
 1381 04be 0FBE      		out		__SREG__, __tmp_reg__
 1382               	 ;  0 "" 2
1494:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 1384               	.LM163:
 1385               	/* #NOAPP */
 1386 04c0 0E94 0000 		call vTaskSuspendAll
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1388               	.LM164:
 1389               	/* #APP */
 1390               	 ;  1495 "FreeRTOS/Source/queue.c" 1
 1391 04c4 0FB6      		in		__tmp_reg__, __SREG__
 1392               	 ;  0 "" 2
 1393               	 ;  1495 "FreeRTOS/Source/queue.c" 1
 1394 04c6 F894      		cli
 1395               	 ;  0 "" 2
 1396               	 ;  1495 "FreeRTOS/Source/queue.c" 1
 1397 04c8 0F92      		push	__tmp_reg__
 1398               	 ;  0 "" 2
 1399               	/* #NOAPP */
 1400 04ca F801      		movw r30,r16
 1401 04cc 858D      		ldd r24,Z+29
 1402 04ce 8F3F      		cpi r24,lo8(-1)
 1403 04d0 01F4      		brne .L104
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1405               	.LM165:
 1406 04d2 158E      		std Z+29,__zero_reg__
 1407               	.L104:
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1409               	.LM166:
 1410 04d4 F801      		movw r30,r16
 1411 04d6 868D      		ldd r24,Z+30
 1412 04d8 8F3F      		cpi r24,lo8(-1)
 1413 04da 01F4      		brne .L105
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1415               	.LM167:
 1416 04dc 168E      		std Z+30,__zero_reg__
 1417               	.L105:
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1419               	.LM168:
 1420               	/* #APP */
 1421               	 ;  1495 "FreeRTOS/Source/queue.c" 1
 1422 04de 0F90      		pop		__tmp_reg__
 1423               	 ;  0 "" 2
 1424               	 ;  1495 "FreeRTOS/Source/queue.c" 1
 1425 04e0 0FBE      		out		__SREG__, __tmp_reg__
 1426               	 ;  0 "" 2
1498:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1428               	.LM169:
 1429               	/* #NOAPP */
 1430 04e2 BE01      		movw r22,r28
 1431 04e4 6C5F      		subi r22,-4
 1432 04e6 7F4F      		sbci r23,-1
 1433 04e8 CE01      		movw r24,r28
 1434 04ea 0196      		adiw r24,1
 1435 04ec 0E94 0000 		call xTaskCheckForTimeOut
 1436 04f0 8111      		cpse r24,__zero_reg__
 1437 04f2 00C0      		rjmp .L106
 1438               	.LBB8:
 1439               	.LBB9:
1994:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1441               	.LM170:
 1442               	/* #APP */
 1443               	 ;  1994 "FreeRTOS/Source/queue.c" 1
 1444 04f4 0FB6      		in		__tmp_reg__, __SREG__
 1445               	 ;  0 "" 2
 1446               	 ;  1994 "FreeRTOS/Source/queue.c" 1
 1447 04f6 F894      		cli
 1448               	 ;  0 "" 2
 1449               	 ;  1994 "FreeRTOS/Source/queue.c" 1
 1450 04f8 0F92      		push	__tmp_reg__
 1451               	 ;  0 "" 2
1996:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 1453               	.LM171:
 1454               	/* #NOAPP */
 1455 04fa F801      		movw r30,r16
 1456 04fc 828D      		ldd r24,Z+26
2005:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1458               	.LM172:
 1459               	/* #APP */
 1460               	 ;  2005 "FreeRTOS/Source/queue.c" 1
 1461 04fe 0F90      		pop		__tmp_reg__
 1462               	 ;  0 "" 2
 1463               	 ;  2005 "FreeRTOS/Source/queue.c" 1
 1464 0500 0FBE      		out		__SREG__, __tmp_reg__
 1465               	 ;  0 "" 2
 1466               	/* #NOAPP */
 1467               	.LBE9:
 1468               	.LBE8:
1500:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1470               	.LM173:
 1471 0502 8111      		cpse r24,__zero_reg__
 1472 0504 00C0      		rjmp .L107
1521:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1474               	.LM174:
 1475 0506 6C81      		ldd r22,Y+4
 1476 0508 7D81      		ldd r23,Y+5
 1477 050a C701      		movw r24,r14
 1478 050c 0E94 0000 		call vTaskPlaceOnEventList
1522:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1480               	.LM175:
 1481 0510 C801      		movw r24,r16
 1482 0512 0E94 0000 		call prvUnlockQueue
1523:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1484               	.LM176:
 1485 0516 0E94 0000 		call xTaskResumeAll
 1486 051a 8111      		cpse r24,__zero_reg__
 1487 051c 00C0      		rjmp .L108
1525:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 1489               	.LM177:
 1490 051e 0E94 0000 		call vPortYield
 1491 0522 00C0      		rjmp .L108
 1492               	.L107:
1535:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1494               	.LM178:
 1495 0524 C801      		movw r24,r16
 1496 0526 0E94 0000 		call prvUnlockQueue
1536:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1498               	.LM179:
 1499 052a 0E94 0000 		call xTaskResumeAll
 1500 052e 00C0      		rjmp .L108
 1501               	.L106:
1541:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1503               	.LM180:
 1504 0530 C801      		movw r24,r16
 1505 0532 0E94 0000 		call prvUnlockQueue
1542:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1507               	.LM181:
 1508 0536 0E94 0000 		call xTaskResumeAll
 1509               	.L112:
1544:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 1511               	.LM182:
 1512 053a 80E0      		ldi r24,0
 1513               	.L101:
 1514               	/* epilogue start */
1547:FreeRTOS/Source/queue.c **** }
 1516               	.LM183:
 1517 053c 0F90      		pop __tmp_reg__
 1518 053e 0F90      		pop __tmp_reg__
 1519 0540 0F90      		pop __tmp_reg__
 1520 0542 0F90      		pop __tmp_reg__
 1521 0544 0F90      		pop __tmp_reg__
 1522 0546 DF91      		pop r29
 1523 0548 CF91      		pop r28
 1524 054a 1F91      		pop r17
 1525 054c 0F91      		pop r16
 1526 054e FF90      		pop r15
 1527 0550 EF90      		pop r14
 1528 0552 DF90      		pop r13
 1529 0554 CF90      		pop r12
 1530 0556 BF90      		pop r11
 1531 0558 0895      		ret
 1538               	.Lscope9:
 1540               		.stabd	78,0,0
 1545               	.global	xQueueReceiveFromISR
 1547               	xQueueReceiveFromISR:
 1548               		.stabd	46,0,0
1551:FreeRTOS/Source/queue.c **** {
 1550               	.LM184:
 1551               	.LFBB10:
 1552 055a 0F93      		push r16
 1553 055c 1F93      		push r17
 1554 055e CF93      		push r28
 1555 0560 DF93      		push r29
 1556               	/* prologue: function */
 1557               	/* frame size = 0 */
 1558               	/* stack size = 4 */
 1559               	.L__stack_usage = 4
 1560 0562 EC01      		movw r28,r24
 1561 0564 8A01      		movw r16,r20
1578:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1563               	.LM185:
 1564 0566 8A8D      		ldd r24,Y+26
 1565 0568 8823      		tst r24
 1566 056a 01F0      		breq .L118
1582:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1568               	.LM186:
 1569 056c CE01      		movw r24,r28
 1570 056e 0E94 0000 		call prvCopyDataFromQueue
1583:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1572               	.LM187:
 1573 0572 8A8D      		ldd r24,Y+26
 1574 0574 8150      		subi r24,lo8(-(-1))
 1575 0576 8A8F      		std Y+26,r24
1589:FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1577               	.LM188:
 1578 0578 8D8D      		ldd r24,Y+29
 1579 057a 8F3F      		cpi r24,lo8(-1)
 1580 057c 01F4      		brne .L115
1591:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1582               	.LM189:
 1583 057e 8885      		ldd r24,Y+8
 1584 0580 8111      		cpse r24,__zero_reg__
 1585 0582 00C0      		rjmp .L116
 1586 0584 00C0      		rjmp .L125
 1587               	.L116:
1593:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1589               	.LM190:
 1590 0586 CE01      		movw r24,r28
 1591 0588 0896      		adiw r24,8
 1592 058a 0E94 0000 		call xTaskRemoveFromEventList
 1593 058e 8823      		tst r24
 1594 0590 01F0      		breq .L125
1597:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1596               	.LM191:
 1597 0592 0115      		cp r16,__zero_reg__
 1598 0594 1105      		cpc r17,__zero_reg__
 1599 0596 01F0      		breq .L125
1599:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1601               	.LM192:
 1602 0598 81E0      		ldi r24,lo8(1)
 1603 059a F801      		movw r30,r16
 1604 059c 8083      		st Z,r24
 1605 059e 00C0      		rjmp .L114
 1606               	.L115:
1620:FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 1608               	.LM193:
 1609 05a0 8D8D      		ldd r24,Y+29
 1610 05a2 8F5F      		subi r24,lo8(-(1))
 1611 05a4 8D8F      		std Y+29,r24
 1612               	.L125:
1623:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1614               	.LM194:
 1615 05a6 81E0      		ldi r24,lo8(1)
 1616 05a8 00C0      		rjmp .L114
 1617               	.L118:
1627:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1619               	.LM195:
 1620 05aa 80E0      		ldi r24,0
 1621               	.L114:
 1622               	/* epilogue start */
1634:FreeRTOS/Source/queue.c **** }
 1624               	.LM196:
 1625 05ac DF91      		pop r29
 1626 05ae CF91      		pop r28
 1627 05b0 1F91      		pop r17
 1628 05b2 0F91      		pop r16
 1629 05b4 0895      		ret
 1634               	.Lscope10:
 1636               		.stabd	78,0,0
 1640               	.global	xQueuePeekFromISR
 1642               	xQueuePeekFromISR:
 1643               		.stabd	46,0,0
1638:FreeRTOS/Source/queue.c **** {
 1645               	.LM197:
 1646               	.LFBB11:
 1647 05b6 0F93      		push r16
 1648 05b8 1F93      		push r17
 1649 05ba CF93      		push r28
 1650 05bc DF93      		push r29
 1651               	/* prologue: function */
 1652               	/* frame size = 0 */
 1653               	/* stack size = 4 */
 1654               	.L__stack_usage = 4
 1655 05be EC01      		movw r28,r24
1667:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1657               	.LM198:
 1658 05c0 8A8D      		ldd r24,Y+26
 1659 05c2 8823      		tst r24
 1660 05c4 01F0      		breq .L128
1673:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1662               	.LM199:
 1663 05c6 0E81      		ldd r16,Y+6
 1664 05c8 1F81      		ldd r17,Y+7
1674:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1666               	.LM200:
 1667 05ca CE01      		movw r24,r28
 1668 05cc 0E94 0000 		call prvCopyDataFromQueue
1675:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1670               	.LM201:
 1671 05d0 1F83      		std Y+7,r17
 1672 05d2 0E83      		std Y+6,r16
1677:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1674               	.LM202:
 1675 05d4 81E0      		ldi r24,lo8(1)
 1676 05d6 00C0      		rjmp .L127
 1677               	.L128:
1681:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1679               	.LM203:
 1680 05d8 80E0      		ldi r24,0
 1681               	.L127:
 1682               	/* epilogue start */
1688:FreeRTOS/Source/queue.c **** }
 1684               	.LM204:
 1685 05da DF91      		pop r29
 1686 05dc CF91      		pop r28
 1687 05de 1F91      		pop r17
 1688 05e0 0F91      		pop r16
 1689 05e2 0895      		ret
 1695               	.Lscope11:
 1697               		.stabd	78,0,0
 1700               	.global	uxQueueMessagesWaiting
 1702               	uxQueueMessagesWaiting:
 1703               		.stabd	46,0,0
1692:FreeRTOS/Source/queue.c **** {
 1705               	.LM205:
 1706               	.LFBB12:
 1707               	/* prologue: function */
 1708               	/* frame size = 0 */
 1709               	/* stack size = 0 */
 1710               	.L__stack_usage = 0
1697:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1712               	.LM206:
 1713               	/* #APP */
 1714               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 1715 05e4 0FB6      		in		__tmp_reg__, __SREG__
 1716               	 ;  0 "" 2
 1717               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 1718 05e6 F894      		cli
 1719               	 ;  0 "" 2
 1720               	 ;  1697 "FreeRTOS/Source/queue.c" 1
 1721 05e8 0F92      		push	__tmp_reg__
 1722               	 ;  0 "" 2
1699:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1724               	.LM207:
 1725               	/* #NOAPP */
 1726 05ea FC01      		movw r30,r24
 1727 05ec 828D      		ldd r24,Z+26
1701:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1729               	.LM208:
 1730               	/* #APP */
 1731               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 1732 05ee 0F90      		pop		__tmp_reg__
 1733               	 ;  0 "" 2
 1734               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 1735 05f0 0FBE      		out		__SREG__, __tmp_reg__
 1736               	 ;  0 "" 2
1704:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1738               	.LM209:
 1739               	/* #NOAPP */
 1740 05f2 0895      		ret
 1745               	.Lscope12:
 1747               		.stabd	78,0,0
 1750               	.global	uxQueueSpacesAvailable
 1752               	uxQueueSpacesAvailable:
 1753               		.stabd	46,0,0
1708:FreeRTOS/Source/queue.c **** {
 1755               	.LM210:
 1756               	.LFBB13:
 1757               	/* prologue: function */
 1758               	/* frame size = 0 */
 1759               	/* stack size = 0 */
 1760               	.L__stack_usage = 0
1715:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1762               	.LM211:
 1763               	/* #APP */
 1764               	 ;  1715 "FreeRTOS/Source/queue.c" 1
 1765 05f4 0FB6      		in		__tmp_reg__, __SREG__
 1766               	 ;  0 "" 2
 1767               	 ;  1715 "FreeRTOS/Source/queue.c" 1
 1768 05f6 F894      		cli
 1769               	 ;  0 "" 2
 1770               	 ;  1715 "FreeRTOS/Source/queue.c" 1
 1771 05f8 0F92      		push	__tmp_reg__
 1772               	 ;  0 "" 2
1717:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1774               	.LM212:
 1775               	/* #NOAPP */
 1776 05fa FC01      		movw r30,r24
 1777 05fc 228D      		ldd r18,Z+26
1719:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1779               	.LM213:
 1780               	/* #APP */
 1781               	 ;  1719 "FreeRTOS/Source/queue.c" 1
 1782 05fe 0F90      		pop		__tmp_reg__
 1783               	 ;  0 "" 2
 1784               	 ;  1719 "FreeRTOS/Source/queue.c" 1
 1785 0600 0FBE      		out		__SREG__, __tmp_reg__
 1786               	 ;  0 "" 2
1717:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1788               	.LM214:
 1789               	/* #NOAPP */
 1790 0602 FC01      		movw r30,r24
 1791 0604 838D      		ldd r24,Z+27
1722:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1793               	.LM215:
 1794 0606 821B      		sub r24,r18
 1795 0608 0895      		ret
 1797               	.Lscope13:
 1799               		.stabd	78,0,0
 1802               	.global	uxQueueMessagesWaitingFromISR
 1804               	uxQueueMessagesWaitingFromISR:
 1805               		.stabd	46,0,0
1726:FreeRTOS/Source/queue.c **** {
 1807               	.LM216:
 1808               	.LFBB14:
 1809               	/* prologue: function */
 1810               	/* frame size = 0 */
 1811               	/* stack size = 0 */
 1812               	.L__stack_usage = 0
1731:FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1814               	.LM217:
 1815 060a FC01      		movw r30,r24
 1816 060c 828D      		ldd r24,Z+26
1734:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1818               	.LM218:
 1819 060e 0895      		ret
 1824               	.Lscope14:
 1826               		.stabd	78,0,0
 1829               	.global	vQueueDelete
 1831               	vQueueDelete:
 1832               		.stabd	46,0,0
1738:FreeRTOS/Source/queue.c **** {
 1834               	.LM219:
 1835               	.LFBB15:
 1836               	/* prologue: function */
 1837               	/* frame size = 0 */
 1838               	/* stack size = 0 */
 1839               	.L__stack_usage = 0
1749:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 1841               	.LM220:
 1842 0610 0C94 0000 		jmp vPortFree
 1844               	.Lscope15:
 1846               		.stabd	78,0,0
 1849               	.global	xQueueIsQueueEmptyFromISR
 1851               	xQueueIsQueueEmptyFromISR:
 1852               		.stabd	46,0,0
2012:FreeRTOS/Source/queue.c **** {
 1854               	.LM221:
 1855               	.LFBB16:
 1856               	/* prologue: function */
 1857               	/* frame size = 0 */
 1858               	/* stack size = 0 */
 1859               	.L__stack_usage = 0
2016:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 1861               	.LM222:
 1862 0614 FC01      		movw r30,r24
 1863 0616 928D      		ldd r25,Z+26
 1864 0618 81E0      		ldi r24,lo8(1)
 1865 061a 9111      		cpse r25,__zero_reg__
 1866 061c 80E0      		ldi r24,0
 1867               	.L134:
2026:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1869               	.LM223:
 1870 061e 0895      		ret
 1872               	.Lscope16:
 1874               		.stabd	78,0,0
 1877               	.global	xQueueIsQueueFullFromISR
 1879               	xQueueIsQueueFullFromISR:
 1880               		.stabd	46,0,0
2045:FreeRTOS/Source/queue.c **** 
2046:FreeRTOS/Source/queue.c **** 	return xReturn;
2047:FreeRTOS/Source/queue.c **** }
2048:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2049:FreeRTOS/Source/queue.c **** 
2050:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2051:FreeRTOS/Source/queue.c **** {
 1882               	.LM224:
 1883               	.LFBB17:
 1884               	/* prologue: function */
 1885               	/* frame size = 0 */
 1886               	/* stack size = 0 */
 1887               	.L__stack_usage = 0
 1888 0620 FC01      		movw r30,r24
2052:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2053:FreeRTOS/Source/queue.c **** 
2054:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2055:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 1890               	.LM225:
 1891 0622 228D      		ldd r18,Z+26
 1892 0624 81E0      		ldi r24,lo8(1)
 1893 0626 938D      		ldd r25,Z+27
 1894 0628 2913      		cpse r18,r25
 1895 062a 80E0      		ldi r24,0
 1896               	.L139:
2056:FreeRTOS/Source/queue.c **** 	{
2057:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2058:FreeRTOS/Source/queue.c **** 	}
2059:FreeRTOS/Source/queue.c **** 	else
2060:FreeRTOS/Source/queue.c **** 	{
2061:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2062:FreeRTOS/Source/queue.c **** 	}
2063:FreeRTOS/Source/queue.c **** 
2064:FreeRTOS/Source/queue.c **** 	return xReturn;
2065:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1898               	.LM226:
 1899 062c 0895      		ret
 1901               	.Lscope17:
 1903               		.stabd	78,0,0
 1908               	.global	xQueueCRSend
 1910               	xQueueCRSend:
 1911               		.stabd	46,0,0
2066:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2067:FreeRTOS/Source/queue.c **** 
2068:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2069:FreeRTOS/Source/queue.c **** 
2070:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2071:FreeRTOS/Source/queue.c **** 	{
 1913               	.LM227:
 1914               	.LFBB18:
 1915 062e CF93      		push r28
 1916 0630 DF93      		push r29
 1917               	/* prologue: function */
 1918               	/* frame size = 0 */
 1919               	/* stack size = 2 */
 1920               	.L__stack_usage = 2
 1921 0632 EC01      		movw r28,r24
 1922 0634 CA01      		movw r24,r20
2072:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2073:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2074:FreeRTOS/Source/queue.c **** 
2075:FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2076:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2077:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2078:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 1924               	.LM228:
 1925               	/* #APP */
 1926               	 ;  2078 "FreeRTOS/Source/queue.c" 1
 1927 0636 F894      		cli
 1928               	 ;  0 "" 2
 1929               	/* #NOAPP */
 1930               	.LBB12:
 1931               	.LBB13:
2033:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1933               	.LM229:
 1934               	/* #APP */
 1935               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 1936 0638 0FB6      		in		__tmp_reg__, __SREG__
 1937               	 ;  0 "" 2
 1938               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 1939 063a F894      		cli
 1940               	 ;  0 "" 2
 1941               	 ;  2033 "FreeRTOS/Source/queue.c" 1
 1942 063c 0F92      		push	__tmp_reg__
 1943               	 ;  0 "" 2
2035:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1945               	.LM230:
 1946               	/* #NOAPP */
 1947 063e 3A8D      		ldd r19,Y+26
 1948 0640 2B8D      		ldd r18,Y+27
2044:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1950               	.LM231:
 1951               	/* #APP */
 1952               	 ;  2044 "FreeRTOS/Source/queue.c" 1
 1953 0642 0F90      		pop		__tmp_reg__
 1954               	 ;  0 "" 2
 1955               	 ;  2044 "FreeRTOS/Source/queue.c" 1
 1956 0644 0FBE      		out		__SREG__, __tmp_reg__
 1957               	 ;  0 "" 2
 1958               	/* #NOAPP */
 1959               	.LBE13:
 1960               	.LBE12:
2079:FreeRTOS/Source/queue.c **** 		{
2080:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1962               	.LM232:
 1963 0646 3213      		cpse r19,r18
 1964 0648 00C0      		rjmp .L141
2081:FreeRTOS/Source/queue.c **** 			{
2082:FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2083:FreeRTOS/Source/queue.c **** 				posting? */
2084:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 1966               	.LM233:
 1967 064a 0097      		sbiw r24,0
 1968 064c 01F0      		breq .L142
2085:FreeRTOS/Source/queue.c **** 				{
2086:FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2087:FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
2088:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 1970               	.LM234:
 1971 064e BE01      		movw r22,r28
 1972 0650 685F      		subi r22,-8
 1973 0652 7F4F      		sbci r23,-1
 1974 0654 0E94 0000 		call vCoRoutineAddToDelayedList
2089:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 1976               	.LM235:
 1977               	/* #APP */
 1978               	 ;  2089 "FreeRTOS/Source/queue.c" 1
 1979 0658 7894      		sei
 1980               	 ;  0 "" 2
2090:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 1982               	.LM236:
 1983               	/* #NOAPP */
 1984 065a 8CEF      		ldi r24,lo8(-4)
 1985 065c 00C0      		rjmp .L143
 1986               	.L142:
2091:FreeRTOS/Source/queue.c **** 				}
2092:FreeRTOS/Source/queue.c **** 				else
2093:FreeRTOS/Source/queue.c **** 				{
2094:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 1988               	.LM237:
 1989               	/* #APP */
 1990               	 ;  2094 "FreeRTOS/Source/queue.c" 1
 1991 065e 7894      		sei
 1992               	 ;  0 "" 2
2095:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 1994               	.LM238:
 1995               	/* #NOAPP */
 1996 0660 80E0      		ldi r24,0
 1997 0662 00C0      		rjmp .L143
 1998               	.L141:
2096:FreeRTOS/Source/queue.c **** 				}
2097:FreeRTOS/Source/queue.c **** 			}
2098:FreeRTOS/Source/queue.c **** 		}
2099:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2000               	.LM239:
 2001               	/* #APP */
 2002               	 ;  2099 "FreeRTOS/Source/queue.c" 1
 2003 0664 7894      		sei
 2004               	 ;  0 "" 2
2100:FreeRTOS/Source/queue.c **** 
2101:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2006               	.LM240:
 2007               	 ;  2101 "FreeRTOS/Source/queue.c" 1
 2008 0666 F894      		cli
 2009               	 ;  0 "" 2
2102:FreeRTOS/Source/queue.c **** 		{
2103:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2011               	.LM241:
 2012               	/* #NOAPP */
 2013 0668 8A8D      		ldd r24,Y+26
 2014 066a 8217      		cp r24,r18
 2015 066c 00F4      		brsh .L147
2104:FreeRTOS/Source/queue.c **** 			{
2105:FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2106:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2017               	.LM242:
 2018 066e 40E0      		ldi r20,0
 2019 0670 CE01      		movw r24,r28
 2020 0672 0E94 0000 		call prvCopyDataToQueue
2107:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2108:FreeRTOS/Source/queue.c **** 
2109:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2110:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2022               	.LM243:
 2023 0676 8989      		ldd r24,Y+17
 2024 0678 8111      		cpse r24,__zero_reg__
 2025 067a 00C0      		rjmp .L145
 2026               	.L146:
2107:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2028               	.LM244:
 2029 067c 81E0      		ldi r24,lo8(1)
 2030 067e 00C0      		rjmp .L144
 2031               	.L145:
2111:FreeRTOS/Source/queue.c **** 				{
2112:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2113:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2114:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2115:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2116:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2033               	.LM245:
 2034 0680 CE01      		movw r24,r28
 2035 0682 4196      		adiw r24,17
 2036 0684 0E94 0000 		call xCoRoutineRemoveFromEventList
 2037 0688 8823      		tst r24
 2038 068a 01F0      		breq .L146
2117:FreeRTOS/Source/queue.c **** 					{
2118:FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2119:FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
2120:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2040               	.LM246:
 2041 068c 8BEF      		ldi r24,lo8(-5)
 2042 068e 00C0      		rjmp .L144
 2043               	.L147:
2121:FreeRTOS/Source/queue.c **** 					}
2122:FreeRTOS/Source/queue.c **** 					else
2123:FreeRTOS/Source/queue.c **** 					{
2124:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2125:FreeRTOS/Source/queue.c **** 					}
2126:FreeRTOS/Source/queue.c **** 				}
2127:FreeRTOS/Source/queue.c **** 				else
2128:FreeRTOS/Source/queue.c **** 				{
2129:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2130:FreeRTOS/Source/queue.c **** 				}
2131:FreeRTOS/Source/queue.c **** 			}
2132:FreeRTOS/Source/queue.c **** 			else
2133:FreeRTOS/Source/queue.c **** 			{
2134:FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2045               	.LM247:
 2046 0690 80E0      		ldi r24,0
 2047               	.L144:
2135:FreeRTOS/Source/queue.c **** 			}
2136:FreeRTOS/Source/queue.c **** 		}
2137:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2049               	.LM248:
 2050               	/* #APP */
 2051               	 ;  2137 "FreeRTOS/Source/queue.c" 1
 2052 0692 7894      		sei
 2053               	 ;  0 "" 2
 2054               	/* #NOAPP */
 2055               	.L143:
 2056               	/* epilogue start */
2138:FreeRTOS/Source/queue.c **** 
2139:FreeRTOS/Source/queue.c **** 		return xReturn;
2140:FreeRTOS/Source/queue.c **** 	}
 2058               	.LM249:
 2059 0694 DF91      		pop r29
 2060 0696 CF91      		pop r28
 2061 0698 0895      		ret
 2066               	.Lscope18:
 2068               		.stabd	78,0,0
 2072               	.global	xQueueCRReceive
 2074               	xQueueCRReceive:
 2075               		.stabd	46,0,0
2141:FreeRTOS/Source/queue.c **** 
2142:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2143:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2144:FreeRTOS/Source/queue.c **** 
2145:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2146:FreeRTOS/Source/queue.c **** 
2147:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2148:FreeRTOS/Source/queue.c **** 	{
 2077               	.LM250:
 2078               	.LFBB19:
 2079 069a CF93      		push r28
 2080 069c DF93      		push r29
 2081               	/* prologue: function */
 2082               	/* frame size = 0 */
 2083               	/* stack size = 2 */
 2084               	.L__stack_usage = 2
 2085 069e EC01      		movw r28,r24
 2086 06a0 CB01      		movw r24,r22
2149:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2150:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2151:FreeRTOS/Source/queue.c **** 
2152:FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2153:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2154:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2155:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2088               	.LM251:
 2089               	/* #APP */
 2090               	 ;  2155 "FreeRTOS/Source/queue.c" 1
 2091 06a2 F894      		cli
 2092               	 ;  0 "" 2
2156:FreeRTOS/Source/queue.c **** 		{
2157:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2094               	.LM252:
 2095               	/* #NOAPP */
 2096 06a4 2A8D      		ldd r18,Y+26
 2097 06a6 2111      		cpse r18,__zero_reg__
 2098 06a8 00C0      		rjmp .L152
2158:FreeRTOS/Source/queue.c **** 			{
2159:FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2160:FreeRTOS/Source/queue.c **** 				leave with nothing? */
2161:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2100               	.LM253:
 2101 06aa 4115      		cp r20,__zero_reg__
 2102 06ac 5105      		cpc r21,__zero_reg__
 2103 06ae 01F0      		breq .L153
2162:FreeRTOS/Source/queue.c **** 				{
2163:FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2164:FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2165:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2105               	.LM254:
 2106 06b0 BE01      		movw r22,r28
 2107 06b2 6F5E      		subi r22,-17
 2108 06b4 7F4F      		sbci r23,-1
 2109 06b6 CA01      		movw r24,r20
 2110 06b8 0E94 0000 		call vCoRoutineAddToDelayedList
2166:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2112               	.LM255:
 2113               	/* #APP */
 2114               	 ;  2166 "FreeRTOS/Source/queue.c" 1
 2115 06bc 7894      		sei
 2116               	 ;  0 "" 2
2167:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2118               	.LM256:
 2119               	/* #NOAPP */
 2120 06be 8CEF      		ldi r24,lo8(-4)
 2121 06c0 00C0      		rjmp .L154
 2122               	.L153:
2168:FreeRTOS/Source/queue.c **** 				}
2169:FreeRTOS/Source/queue.c **** 				else
2170:FreeRTOS/Source/queue.c **** 				{
2171:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2124               	.LM257:
 2125               	/* #APP */
 2126               	 ;  2171 "FreeRTOS/Source/queue.c" 1
 2127 06c2 7894      		sei
 2128               	 ;  0 "" 2
2172:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2130               	.LM258:
 2131               	/* #NOAPP */
 2132 06c4 80E0      		ldi r24,0
 2133 06c6 00C0      		rjmp .L154
 2134               	.L152:
2173:FreeRTOS/Source/queue.c **** 				}
2174:FreeRTOS/Source/queue.c **** 			}
2175:FreeRTOS/Source/queue.c **** 			else
2176:FreeRTOS/Source/queue.c **** 			{
2177:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2178:FreeRTOS/Source/queue.c **** 			}
2179:FreeRTOS/Source/queue.c **** 		}
2180:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2136               	.LM259:
 2137               	/* #APP */
 2138               	 ;  2180 "FreeRTOS/Source/queue.c" 1
 2139 06c8 7894      		sei
 2140               	 ;  0 "" 2
2181:FreeRTOS/Source/queue.c **** 
2182:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2142               	.LM260:
 2143               	 ;  2182 "FreeRTOS/Source/queue.c" 1
 2144 06ca F894      		cli
 2145               	 ;  0 "" 2
2183:FreeRTOS/Source/queue.c **** 		{
2184:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2147               	.LM261:
 2148               	/* #NOAPP */
 2149 06cc 2A8D      		ldd r18,Y+26
 2150 06ce 2223      		tst r18
 2151 06d0 01F0      		breq .L159
2185:FreeRTOS/Source/queue.c **** 			{
2186:FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2187:FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2153               	.LM262:
 2154 06d2 4C8D      		ldd r20,Y+28
 2155 06d4 2E81      		ldd r18,Y+6
 2156 06d6 3F81      		ldd r19,Y+7
 2157 06d8 240F      		add r18,r20
 2158 06da 311D      		adc r19,__zero_reg__
 2159 06dc 3F83      		std Y+7,r19
 2160 06de 2E83      		std Y+6,r18
2188:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2162               	.LM263:
 2163 06e0 EA81      		ldd r30,Y+2
 2164 06e2 FB81      		ldd r31,Y+3
 2165 06e4 2E17      		cp r18,r30
 2166 06e6 3F07      		cpc r19,r31
 2167 06e8 00F0      		brlo .L156
2189:FreeRTOS/Source/queue.c **** 				{
2190:FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2169               	.LM264:
 2170 06ea 2881      		ld r18,Y
 2171 06ec 3981      		ldd r19,Y+1
 2172 06ee 3F83      		std Y+7,r19
 2173 06f0 2E83      		std Y+6,r18
 2174               	.L156:
2191:FreeRTOS/Source/queue.c **** 				}
2192:FreeRTOS/Source/queue.c **** 				else
2193:FreeRTOS/Source/queue.c **** 				{
2194:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2195:FreeRTOS/Source/queue.c **** 				}
2196:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2176               	.LM265:
 2177 06f2 2A8D      		ldd r18,Y+26
 2178 06f4 2150      		subi r18,lo8(-(-1))
 2179 06f6 2A8F      		std Y+26,r18
2197:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
 2181               	.LM266:
 2182 06f8 6E81      		ldd r22,Y+6
 2183 06fa 7F81      		ldd r23,Y+7
 2184 06fc 50E0      		ldi r21,0
 2185 06fe 0E94 0000 		call memcpy
2198:FreeRTOS/Source/queue.c **** 
2199:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2200:FreeRTOS/Source/queue.c **** 
2201:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2202:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2187               	.LM267:
 2188 0702 8885      		ldd r24,Y+8
 2189 0704 8111      		cpse r24,__zero_reg__
 2190 0706 00C0      		rjmp .L157
 2191               	.L158:
2199:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2193               	.LM268:
 2194 0708 81E0      		ldi r24,lo8(1)
 2195 070a 00C0      		rjmp .L155
 2196               	.L157:
2203:FreeRTOS/Source/queue.c **** 				{
2204:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2205:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2206:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2207:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2208:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2198               	.LM269:
 2199 070c CE01      		movw r24,r28
 2200 070e 0896      		adiw r24,8
 2201 0710 0E94 0000 		call xCoRoutineRemoveFromEventList
 2202 0714 8823      		tst r24
 2203 0716 01F0      		breq .L158
2209:FreeRTOS/Source/queue.c **** 					{
2210:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2205               	.LM270:
 2206 0718 8BEF      		ldi r24,lo8(-5)
 2207 071a 00C0      		rjmp .L155
 2208               	.L159:
2211:FreeRTOS/Source/queue.c **** 					}
2212:FreeRTOS/Source/queue.c **** 					else
2213:FreeRTOS/Source/queue.c **** 					{
2214:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2215:FreeRTOS/Source/queue.c **** 					}
2216:FreeRTOS/Source/queue.c **** 				}
2217:FreeRTOS/Source/queue.c **** 				else
2218:FreeRTOS/Source/queue.c **** 				{
2219:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2220:FreeRTOS/Source/queue.c **** 				}
2221:FreeRTOS/Source/queue.c **** 			}
2222:FreeRTOS/Source/queue.c **** 			else
2223:FreeRTOS/Source/queue.c **** 			{
2224:FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
 2210               	.LM271:
 2211 071c 80E0      		ldi r24,0
 2212               	.L155:
2225:FreeRTOS/Source/queue.c **** 			}
2226:FreeRTOS/Source/queue.c **** 		}
2227:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2214               	.LM272:
 2215               	/* #APP */
 2216               	 ;  2227 "FreeRTOS/Source/queue.c" 1
 2217 071e 7894      		sei
 2218               	 ;  0 "" 2
 2219               	/* #NOAPP */
 2220               	.L154:
 2221               	/* epilogue start */
2228:FreeRTOS/Source/queue.c **** 
2229:FreeRTOS/Source/queue.c **** 		return xReturn;
2230:FreeRTOS/Source/queue.c **** 	}
 2223               	.LM273:
 2224 0720 DF91      		pop r29
 2225 0722 CF91      		pop r28
 2226 0724 0895      		ret
 2231               	.Lscope19:
 2233               		.stabd	78,0,0
 2238               	.global	xQueueCRSendFromISR
 2240               	xQueueCRSendFromISR:
 2241               		.stabd	46,0,0
2231:FreeRTOS/Source/queue.c **** 
2232:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2233:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2234:FreeRTOS/Source/queue.c **** 
2235:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2236:FreeRTOS/Source/queue.c **** 
2237:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2238:FreeRTOS/Source/queue.c **** 	{
 2243               	.LM274:
 2244               	.LFBB20:
 2245 0726 1F93      		push r17
 2246 0728 CF93      		push r28
 2247 072a DF93      		push r29
 2248               	/* prologue: function */
 2249               	/* frame size = 0 */
 2250               	/* stack size = 3 */
 2251               	.L__stack_usage = 3
 2252 072c EC01      		movw r28,r24
 2253 072e 142F      		mov r17,r20
2239:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2240:FreeRTOS/Source/queue.c **** 
2241:FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2242:FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2243:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2255               	.LM275:
 2256 0730 9A8D      		ldd r25,Y+26
 2257 0732 8B8D      		ldd r24,Y+27
 2258 0734 9817      		cp r25,r24
 2259 0736 00F4      		brsh .L165
2244:FreeRTOS/Source/queue.c **** 		{
2245:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2261               	.LM276:
 2262 0738 40E0      		ldi r20,0
 2263 073a CE01      		movw r24,r28
 2264 073c 0E94 0000 		call prvCopyDataToQueue
2246:FreeRTOS/Source/queue.c **** 
2247:FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2248:FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2249:FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2266               	.LM277:
 2267 0740 1111      		cpse r17,__zero_reg__
 2268 0742 00C0      		rjmp .L165
2250:FreeRTOS/Source/queue.c **** 			{
2251:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2270               	.LM278:
 2271 0744 8989      		ldd r24,Y+17
 2272 0746 8823      		tst r24
 2273 0748 01F0      		breq .L165
2252:FreeRTOS/Source/queue.c **** 				{
2253:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2275               	.LM279:
 2276 074a CE01      		movw r24,r28
 2277 074c 4196      		adiw r24,17
 2278 074e 0E94 0000 		call xCoRoutineRemoveFromEventList
 2279 0752 11E0      		ldi r17,lo8(1)
 2280 0754 8111      		cpse r24,__zero_reg__
 2281 0756 00C0      		rjmp .L165
 2282 0758 10E0      		ldi r17,0
 2283               	.L165:
2254:FreeRTOS/Source/queue.c **** 					{
2255:FreeRTOS/Source/queue.c **** 						return pdTRUE;
2256:FreeRTOS/Source/queue.c **** 					}
2257:FreeRTOS/Source/queue.c **** 					else
2258:FreeRTOS/Source/queue.c **** 					{
2259:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2260:FreeRTOS/Source/queue.c **** 					}
2261:FreeRTOS/Source/queue.c **** 				}
2262:FreeRTOS/Source/queue.c **** 				else
2263:FreeRTOS/Source/queue.c **** 				{
2264:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2265:FreeRTOS/Source/queue.c **** 				}
2266:FreeRTOS/Source/queue.c **** 			}
2267:FreeRTOS/Source/queue.c **** 			else
2268:FreeRTOS/Source/queue.c **** 			{
2269:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2270:FreeRTOS/Source/queue.c **** 			}
2271:FreeRTOS/Source/queue.c **** 		}
2272:FreeRTOS/Source/queue.c **** 		else
2273:FreeRTOS/Source/queue.c **** 		{
2274:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2275:FreeRTOS/Source/queue.c **** 		}
2276:FreeRTOS/Source/queue.c **** 
2277:FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2278:FreeRTOS/Source/queue.c **** 	}
 2285               	.LM280:
 2286 075a 812F      		mov r24,r17
 2287               	/* epilogue start */
 2288 075c DF91      		pop r29
 2289 075e CF91      		pop r28
 2290 0760 1F91      		pop r17
 2291 0762 0895      		ret
 2293               	.Lscope20:
 2295               		.stabd	78,0,0
 2299               	.global	xQueueCRReceiveFromISR
 2301               	xQueueCRReceiveFromISR:
 2302               		.stabd	46,0,0
2279:FreeRTOS/Source/queue.c **** 
2280:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2281:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2282:FreeRTOS/Source/queue.c **** 
2283:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2284:FreeRTOS/Source/queue.c **** 
2285:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2286:FreeRTOS/Source/queue.c **** 	{
 2304               	.LM281:
 2305               	.LFBB21:
 2306 0764 0F93      		push r16
 2307 0766 1F93      		push r17
 2308 0768 CF93      		push r28
 2309 076a DF93      		push r29
 2310               	/* prologue: function */
 2311               	/* frame size = 0 */
 2312               	/* stack size = 4 */
 2313               	.L__stack_usage = 4
 2314 076c EC01      		movw r28,r24
 2315 076e CB01      		movw r24,r22
 2316 0770 8A01      		movw r16,r20
2287:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2288:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2289:FreeRTOS/Source/queue.c **** 
2290:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2291:FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2292:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2318               	.LM282:
 2319 0772 2A8D      		ldd r18,Y+26
 2320 0774 2223      		tst r18
 2321 0776 01F0      		breq .L176
2293:FreeRTOS/Source/queue.c **** 		{
2294:FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2295:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2323               	.LM283:
 2324 0778 4C8D      		ldd r20,Y+28
 2325 077a 2E81      		ldd r18,Y+6
 2326 077c 3F81      		ldd r19,Y+7
 2327 077e 240F      		add r18,r20
 2328 0780 311D      		adc r19,__zero_reg__
 2329 0782 3F83      		std Y+7,r19
 2330 0784 2E83      		std Y+6,r18
2296:FreeRTOS/Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2332               	.LM284:
 2333 0786 EA81      		ldd r30,Y+2
 2334 0788 FB81      		ldd r31,Y+3
 2335 078a 2E17      		cp r18,r30
 2336 078c 3F07      		cpc r19,r31
 2337 078e 00F0      		brlo .L173
2297:FreeRTOS/Source/queue.c **** 			{
2298:FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2339               	.LM285:
 2340 0790 2881      		ld r18,Y
 2341 0792 3981      		ldd r19,Y+1
 2342 0794 3F83      		std Y+7,r19
 2343 0796 2E83      		std Y+6,r18
 2344               	.L173:
2299:FreeRTOS/Source/queue.c **** 			}
2300:FreeRTOS/Source/queue.c **** 			else
2301:FreeRTOS/Source/queue.c **** 			{
2302:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2303:FreeRTOS/Source/queue.c **** 			}
2304:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2346               	.LM286:
 2347 0798 2A8D      		ldd r18,Y+26
 2348 079a 2150      		subi r18,lo8(-(-1))
 2349 079c 2A8F      		std Y+26,r18
2305:FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
 2351               	.LM287:
 2352 079e 6E81      		ldd r22,Y+6
 2353 07a0 7F81      		ldd r23,Y+7
 2354 07a2 50E0      		ldi r21,0
 2355 07a4 0E94 0000 		call memcpy
2306:FreeRTOS/Source/queue.c **** 
2307:FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 2357               	.LM288:
 2358 07a8 F801      		movw r30,r16
 2359 07aa 8081      		ld r24,Z
 2360 07ac 8823      		tst r24
 2361 07ae 01F0      		breq .L174
 2362               	.L175:
2308:FreeRTOS/Source/queue.c **** 			{
2309:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2310:FreeRTOS/Source/queue.c **** 				{
2311:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2312:FreeRTOS/Source/queue.c **** 					{
2313:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2314:FreeRTOS/Source/queue.c **** 					}
2315:FreeRTOS/Source/queue.c **** 					else
2316:FreeRTOS/Source/queue.c **** 					{
2317:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2318:FreeRTOS/Source/queue.c **** 					}
2319:FreeRTOS/Source/queue.c **** 				}
2320:FreeRTOS/Source/queue.c **** 				else
2321:FreeRTOS/Source/queue.c **** 				{
2322:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2323:FreeRTOS/Source/queue.c **** 				}
2324:FreeRTOS/Source/queue.c **** 			}
2325:FreeRTOS/Source/queue.c **** 			else
2326:FreeRTOS/Source/queue.c **** 			{
2327:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2328:FreeRTOS/Source/queue.c **** 			}
2329:FreeRTOS/Source/queue.c **** 
2330:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 2364               	.LM289:
 2365 07b0 81E0      		ldi r24,lo8(1)
 2366 07b2 00C0      		rjmp .L172
 2367               	.L174:
2309:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2369               	.LM290:
 2370 07b4 8885      		ldd r24,Y+8
 2371 07b6 8823      		tst r24
 2372 07b8 01F0      		breq .L175
2311:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2374               	.LM291:
 2375 07ba CE01      		movw r24,r28
 2376 07bc 0896      		adiw r24,8
 2377 07be 0E94 0000 		call xCoRoutineRemoveFromEventList
 2378 07c2 8823      		tst r24
 2379 07c4 01F0      		breq .L175
2313:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
 2381               	.LM292:
 2382 07c6 81E0      		ldi r24,lo8(1)
 2383 07c8 F801      		movw r30,r16
 2384 07ca 8083      		st Z,r24
 2385 07cc 00C0      		rjmp .L172
 2386               	.L176:
2331:FreeRTOS/Source/queue.c **** 		}
2332:FreeRTOS/Source/queue.c **** 		else
2333:FreeRTOS/Source/queue.c **** 		{
2334:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 2388               	.LM293:
 2389 07ce 80E0      		ldi r24,0
 2390               	.L172:
 2391               	/* epilogue start */
2335:FreeRTOS/Source/queue.c **** 		}
2336:FreeRTOS/Source/queue.c **** 
2337:FreeRTOS/Source/queue.c **** 		return xReturn;
2338:FreeRTOS/Source/queue.c **** 	}
 2393               	.LM294:
 2394 07d0 DF91      		pop r29
 2395 07d2 CF91      		pop r28
 2396 07d4 1F91      		pop r17
 2397 07d6 0F91      		pop r16
 2398 07d8 0895      		ret
 2403               	.Lscope21:
 2405               		.stabd	78,0,0
 2407               	.Letext0:
 2408               		.ident	"GCC: (GNU) 4.7.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/cclCgbmr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cclCgbmr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cclCgbmr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cclCgbmr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclCgbmr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclCgbmr.s:145    .text:0000000000000000 prvCopyDataToQueue
     /tmp/cclCgbmr.s:269    .text:0000000000000094 prvCopyDataFromQueue
     /tmp/cclCgbmr.s:322    .text:00000000000000c8 prvUnlockQueue
     /tmp/cclCgbmr.s:475    .text:0000000000000144 xQueueGenericReset
     /tmp/cclCgbmr.s:602    .text:00000000000001c2 xQueueGenericCreate
     /tmp/cclCgbmr.s:714    .text:0000000000000232 xQueueGenericSend
     /tmp/cclCgbmr.s:1030   .text:0000000000000368 xQueueGenericSendFromISR
     /tmp/cclCgbmr.s:1127   .text:00000000000003c6 xQueueGiveFromISR
     /tmp/cclCgbmr.s:1215   .text:0000000000000412 xQueueGenericReceive
     /tmp/cclCgbmr.s:1547   .text:000000000000055a xQueueReceiveFromISR
     /tmp/cclCgbmr.s:1642   .text:00000000000005b6 xQueuePeekFromISR
     /tmp/cclCgbmr.s:1702   .text:00000000000005e4 uxQueueMessagesWaiting
     /tmp/cclCgbmr.s:1752   .text:00000000000005f4 uxQueueSpacesAvailable
     /tmp/cclCgbmr.s:1804   .text:000000000000060a uxQueueMessagesWaitingFromISR
     /tmp/cclCgbmr.s:1831   .text:0000000000000610 vQueueDelete
     /tmp/cclCgbmr.s:1851   .text:0000000000000614 xQueueIsQueueEmptyFromISR
     /tmp/cclCgbmr.s:1879   .text:0000000000000620 xQueueIsQueueFullFromISR
     /tmp/cclCgbmr.s:1910   .text:000000000000062e xQueueCRSend
     /tmp/cclCgbmr.s:2074   .text:000000000000069a xQueueCRReceive
     /tmp/cclCgbmr.s:2240   .text:0000000000000726 xQueueCRSendFromISR
     /tmp/cclCgbmr.s:2301   .text:0000000000000764 xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
