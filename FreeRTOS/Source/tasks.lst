   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 139               	prvResetNextTaskUnblockTime:
 140               		.stabd	46,0,0
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c ****     All rights reserved
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:FreeRTOS/Source/tasks.c **** 
   7:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:FreeRTOS/Source/tasks.c **** 
   9:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:FreeRTOS/Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  12:FreeRTOS/Source/tasks.c **** 
  13:FreeRTOS/Source/tasks.c **** 	***************************************************************************
  14:FreeRTOS/Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:FreeRTOS/Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:FreeRTOS/Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:FreeRTOS/Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:FreeRTOS/Source/tasks.c **** 	***************************************************************************
  19:FreeRTOS/Source/tasks.c **** 
  20:FreeRTOS/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:FreeRTOS/Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:FreeRTOS/Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:FreeRTOS/Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  26:FreeRTOS/Source/tasks.c ****      *                                                                       *
  27:FreeRTOS/Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:FreeRTOS/Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:FreeRTOS/Source/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:FreeRTOS/Source/tasks.c ****      *    is the industry's de facto standard.                               *
  31:FreeRTOS/Source/tasks.c ****      *                                                                       *
  32:FreeRTOS/Source/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:FreeRTOS/Source/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:FreeRTOS/Source/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:FreeRTOS/Source/tasks.c ****      *                                                                       *
  37:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  38:FreeRTOS/Source/tasks.c **** 
  39:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:FreeRTOS/Source/tasks.c **** 	the FAQ page "My application does not run, what could be wrong?".  Have you
  41:FreeRTOS/Source/tasks.c **** 	defined configASSERT()?
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** 	http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:FreeRTOS/Source/tasks.c **** 	embedded software for free we request you assist our global community by
  45:FreeRTOS/Source/tasks.c **** 	participating in the support forum.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c **** 	http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:FreeRTOS/Source/tasks.c **** 	be as productive as possible as early as possible.  Now you can receive
  49:FreeRTOS/Source/tasks.c **** 	FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:FreeRTOS/Source/tasks.c **** 	Ltd, and the world's leading authority on the world's leading RTOS.
  51:FreeRTOS/Source/tasks.c **** 
  52:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:FreeRTOS/Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:FreeRTOS/Source/tasks.c **** 
  56:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:FreeRTOS/Source/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:FreeRTOS/Source/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:FreeRTOS/Source/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:FreeRTOS/Source/tasks.c **** 
  63:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:FreeRTOS/Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:FreeRTOS/Source/tasks.c ****     mission critical applications that require provable dependability.
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  68:FreeRTOS/Source/tasks.c **** */
  69:FreeRTOS/Source/tasks.c **** 
  70:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  71:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  72:FreeRTOS/Source/tasks.c **** #include <string.h>
  73:FreeRTOS/Source/tasks.c **** 
  74:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  77:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:FreeRTOS/Source/tasks.c **** 
  79:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  80:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  81:FreeRTOS/Source/tasks.c **** #include "task.h"
  82:FreeRTOS/Source/tasks.c **** #include "timers.h"
  83:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  84:FreeRTOS/Source/tasks.c **** 
  85:FreeRTOS/Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:FreeRTOS/Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:FreeRTOS/Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:FreeRTOS/Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:FreeRTOS/Source/tasks.c **** 
  91:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  93:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  99:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:FreeRTOS/Source/tasks.c **** 
 101:FreeRTOS/Source/tasks.c **** /* Sanity check the configuration. */
 102:FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
 103:FreeRTOS/Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
 104:FreeRTOS/Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
 105:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 106:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 107:FreeRTOS/Source/tasks.c **** 
 108:FreeRTOS/Source/tasks.c **** /*
 109:FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 110:FreeRTOS/Source/tasks.c ****  */
 111:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 112:FreeRTOS/Source/tasks.c **** 
 113:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 114:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 116:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 117:FreeRTOS/Source/tasks.c **** #else
 118:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:FreeRTOS/Source/tasks.c **** #endif
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /* Value that can be assigned to the eNotifyState member of the TCB. */
 122:FreeRTOS/Source/tasks.c **** typedef enum
 123:FreeRTOS/Source/tasks.c **** {
 124:FreeRTOS/Source/tasks.c **** 	eNotWaitingNotification = 0,
 125:FreeRTOS/Source/tasks.c **** 	eWaitingNotification,
 126:FreeRTOS/Source/tasks.c **** 	eNotified
 127:FreeRTOS/Source/tasks.c **** } eNotifyValue;
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*
 130:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 131:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 132:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 133:FreeRTOS/Source/tasks.c ****  */
 134:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 135:FreeRTOS/Source/tasks.c **** {
 136:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 139:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 140:FreeRTOS/Source/tasks.c **** 		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocat
 141:FreeRTOS/Source/tasks.c **** 	#endif
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 144:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 145:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 146:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 147:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 148:FreeRTOS/Source/tasks.c **** 
 149:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 150:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 151:FreeRTOS/Source/tasks.c **** 	#endif
 152:FreeRTOS/Source/tasks.c **** 
 153:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 154:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 155:FreeRTOS/Source/tasks.c **** 	#endif
 156:FreeRTOS/Source/tasks.c **** 
 157:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 158:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 159:FreeRTOS/Source/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 160:FreeRTOS/Source/tasks.c **** 	#endif
 161:FreeRTOS/Source/tasks.c **** 
 162:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 163:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 164:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxMutexesHeld;
 165:FreeRTOS/Source/tasks.c **** 	#endif
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 168:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 169:FreeRTOS/Source/tasks.c **** 	#endif
 170:FreeRTOS/Source/tasks.c **** 
 171:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 172:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 173:FreeRTOS/Source/tasks.c **** 	#endif
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 176:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 177:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 178:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 179:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 180:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 181:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 182:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 183:FreeRTOS/Source/tasks.c **** 		struct 	_reent xNewLib_reent;
 184:FreeRTOS/Source/tasks.c **** 	#endif
 185:FreeRTOS/Source/tasks.c **** 
 186:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 187:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 188:FreeRTOS/Source/tasks.c **** 		volatile eNotifyValue eNotifyState;
 189:FreeRTOS/Source/tasks.c **** 	#endif
 190:FreeRTOS/Source/tasks.c **** 
 191:FreeRTOS/Source/tasks.c **** } tskTCB;
 192:FreeRTOS/Source/tasks.c **** 
 193:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 194:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 195:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /*
 198:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 199:FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 200:FreeRTOS/Source/tasks.c ****  */
 201:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 202:FreeRTOS/Source/tasks.c **** 	#define static
 203:FreeRTOS/Source/tasks.c **** #endif
 204:FreeRTOS/Source/tasks.c **** 
 205:FreeRTOS/Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 206:FreeRTOS/Source/tasks.c **** static variables must be declared volatile. */
 207:FreeRTOS/Source/tasks.c **** 
 208:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 209:FreeRTOS/Source/tasks.c **** 
 210:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 211:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 212:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 213:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 214:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 215:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 216:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 217:FreeRTOS/Source/tasks.c **** 
 218:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 219:FreeRTOS/Source/tasks.c **** 
 220:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 221:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 222:FreeRTOS/Source/tasks.c **** 
 223:FreeRTOS/Source/tasks.c **** #endif
 224:FreeRTOS/Source/tasks.c **** 
 225:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 226:FreeRTOS/Source/tasks.c **** 
 227:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** #endif
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 232:FreeRTOS/Source/tasks.c **** 
 233:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 234:FreeRTOS/Source/tasks.c **** 
 235:FreeRTOS/Source/tasks.c **** #endif
 236:FreeRTOS/Source/tasks.c **** 
 237:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 238:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 239:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 240:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 241:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 242:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 243:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 244:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 245:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 246:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
 247:FreeRTOS/Source/tasks.c **** 
 248:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 249:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xGenericListItem of a TCB, or any of the
 250:FreeRTOS/Source/tasks.c **** lists the xGenericListItem can be referenced from, if the scheduler is suspended.
 251:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 252:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 253:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 254:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 255:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 256:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 257:FreeRTOS/Source/tasks.c **** 
 258:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 259:FreeRTOS/Source/tasks.c **** 
 260:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 261:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 262:FreeRTOS/Source/tasks.c **** 
 263:FreeRTOS/Source/tasks.c **** #endif
 264:FreeRTOS/Source/tasks.c **** 
 265:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 266:FreeRTOS/Source/tasks.c **** 
 267:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 268:FreeRTOS/Source/tasks.c **** 
 269:FreeRTOS/Source/tasks.c **** /*
 270:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 271:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 272:FreeRTOS/Source/tasks.c ****  */
 273:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 274:FreeRTOS/Source/tasks.c **** 
 275:FreeRTOS/Source/tasks.c **** /*
 276:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 277:FreeRTOS/Source/tasks.c ****  */
 278:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 279:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 280:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 281:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 282:FreeRTOS/Source/tasks.c **** 
 283:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 284:FreeRTOS/Source/tasks.c **** 
 285:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 288:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 289:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 292:FreeRTOS/Source/tasks.c **** 	state task. */
 293:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 294:FreeRTOS/Source/tasks.c **** 	{																									\
 295:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 296:FreeRTOS/Source/tasks.c **** 		{																								\
 297:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 298:FreeRTOS/Source/tasks.c **** 		}																								\
 299:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 300:FreeRTOS/Source/tasks.c **** 
 301:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 302:FreeRTOS/Source/tasks.c **** 
 303:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 304:FreeRTOS/Source/tasks.c **** 	{																									\
 305:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 306:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 307:FreeRTOS/Source/tasks.c **** 		{																								\
 308:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 309:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																		\
 310:FreeRTOS/Source/tasks.c **** 		}																								\
 311:FreeRTOS/Source/tasks.c **** 																										\
 312:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 313:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 314:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 315:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 316:FreeRTOS/Source/tasks.c **** 
 317:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 318:FreeRTOS/Source/tasks.c **** 
 319:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 320:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 321:FreeRTOS/Source/tasks.c **** 	being used. */
 322:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 323:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 324:FreeRTOS/Source/tasks.c **** 
 325:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 326:FreeRTOS/Source/tasks.c **** 
 327:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 328:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 329:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 330:FreeRTOS/Source/tasks.c **** 
 331:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 332:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 333:FreeRTOS/Source/tasks.c **** 
 334:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 335:FreeRTOS/Source/tasks.c **** 
 336:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 337:FreeRTOS/Source/tasks.c **** 	{																								\
 338:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 339:FreeRTOS/Source/tasks.c **** 																									\
 340:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 341:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 342:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 343:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 344:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 345:FreeRTOS/Source/tasks.c **** 
 346:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 347:FreeRTOS/Source/tasks.c **** 
 348:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 349:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 350:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 351:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 352:FreeRTOS/Source/tasks.c **** 	{																									\
 353:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 354:FreeRTOS/Source/tasks.c **** 		{																								\
 355:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 356:FreeRTOS/Source/tasks.c **** 		}																								\
 357:FreeRTOS/Source/tasks.c **** 	}
 358:FreeRTOS/Source/tasks.c **** 
 359:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 360:FreeRTOS/Source/tasks.c **** 
 361:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 362:FreeRTOS/Source/tasks.c **** 
 363:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 364:FreeRTOS/Source/tasks.c **** count overflows. */
 365:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 366:FreeRTOS/Source/tasks.c **** {																									\
 367:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 368:FreeRTOS/Source/tasks.c **** 																									\
 369:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 370:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 371:FreeRTOS/Source/tasks.c **** 																									\
 372:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 373:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 374:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 375:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 376:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 377:FreeRTOS/Source/tasks.c **** }
 378:FreeRTOS/Source/tasks.c **** 
 379:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 380:FreeRTOS/Source/tasks.c **** 
 381:FreeRTOS/Source/tasks.c **** /*
 382:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 383:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 384:FreeRTOS/Source/tasks.c ****  */
 385:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 386:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
 387:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 388:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 389:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 390:FreeRTOS/Source/tasks.c **** 
 391:FreeRTOS/Source/tasks.c **** /*
 392:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 393:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 394:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 395:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 396:FreeRTOS/Source/tasks.c ****  */
 397:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 398:FreeRTOS/Source/tasks.c **** 
 399:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 400:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 401:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 402:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 403:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 404:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 405:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 406:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 407:FreeRTOS/Source/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 408:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 409:FreeRTOS/Source/tasks.c **** #else
 410:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 411:FreeRTOS/Source/tasks.c **** #endif
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 414:FreeRTOS/Source/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 415:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 416:FreeRTOS/Source/tasks.c **** #endif
 417:FreeRTOS/Source/tasks.c **** 
 418:FreeRTOS/Source/tasks.c **** #if configUSE_TICK_HOOK > 0
 419:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void );
 420:FreeRTOS/Source/tasks.c **** #endif
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 423:FreeRTOS/Source/tasks.c **** 
 424:FreeRTOS/Source/tasks.c **** /*
 425:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 426:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 427:FreeRTOS/Source/tasks.c ****  */
 428:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 429:FreeRTOS/Source/tasks.c **** 
 430:FreeRTOS/Source/tasks.c **** /**
 431:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 432:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 433:FreeRTOS/Source/tasks.c ****  * is in any other state.
 434:FreeRTOS/Source/tasks.c ****  */
 435:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 436:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 437:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 438:FreeRTOS/Source/tasks.c **** 
 439:FreeRTOS/Source/tasks.c **** /*
 440:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 441:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 442:FreeRTOS/Source/tasks.c ****  */
 443:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 444:FreeRTOS/Source/tasks.c **** 
 445:FreeRTOS/Source/tasks.c **** /*
 446:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 447:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 448:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 449:FreeRTOS/Source/tasks.c ****  *
 450:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 451:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 452:FreeRTOS/Source/tasks.c ****  *
 453:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 454:FreeRTOS/Source/tasks.c ****  *
 455:FreeRTOS/Source/tasks.c ****  */
 456:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 457:FreeRTOS/Source/tasks.c **** 
 458:FreeRTOS/Source/tasks.c **** /*
 459:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 460:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 461:FreeRTOS/Source/tasks.c ****  *
 462:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 463:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 464:FreeRTOS/Source/tasks.c ****  */
 465:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 466:FreeRTOS/Source/tasks.c **** 
 467:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 468:FreeRTOS/Source/tasks.c **** 
 469:FreeRTOS/Source/tasks.c **** #endif
 470:FreeRTOS/Source/tasks.c **** 
 471:FreeRTOS/Source/tasks.c **** /*
 472:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 473:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 474:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 475:FreeRTOS/Source/tasks.c ****  */
 476:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 477:FreeRTOS/Source/tasks.c **** 
 478:FreeRTOS/Source/tasks.c **** /*
 479:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 480:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 481:FreeRTOS/Source/tasks.c ****  */
 482:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 483:FreeRTOS/Source/tasks.c **** 
 484:FreeRTOS/Source/tasks.c **** /*
 485:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 486:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 487:FreeRTOS/Source/tasks.c ****  */
 488:FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 489:FreeRTOS/Source/tasks.c **** 
 490:FreeRTOS/Source/tasks.c **** /*
 491:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 492:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 493:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 494:FreeRTOS/Source/tasks.c ****  *
 495:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 496:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 497:FreeRTOS/Source/tasks.c ****  */
 498:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 499:FreeRTOS/Source/tasks.c **** 
 500:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 501:FreeRTOS/Source/tasks.c **** 
 502:FreeRTOS/Source/tasks.c **** #endif
 503:FreeRTOS/Source/tasks.c **** 
 504:FreeRTOS/Source/tasks.c **** /*
 505:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 506:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 507:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 508:FreeRTOS/Source/tasks.c ****  */
 509:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 510:FreeRTOS/Source/tasks.c **** 
 511:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 512:FreeRTOS/Source/tasks.c **** 
 513:FreeRTOS/Source/tasks.c **** #endif
 514:FreeRTOS/Source/tasks.c **** 
 515:FreeRTOS/Source/tasks.c **** /*
 516:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 517:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 518:FreeRTOS/Source/tasks.c ****  *
 519:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 520:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 521:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 522:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 523:FreeRTOS/Source/tasks.c ****  */
 524:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 525:FreeRTOS/Source/tasks.c **** 
 526:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** #endif
 529:FreeRTOS/Source/tasks.c **** 
 530:FreeRTOS/Source/tasks.c **** /*
 531:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 532:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 533:FreeRTOS/Source/tasks.c ****  */
 534:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 535:FreeRTOS/Source/tasks.c **** 
 536:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 537:FreeRTOS/Source/tasks.c **** 
 538:FreeRTOS/Source/tasks.c **** 	/*
 539:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 540:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 541:FreeRTOS/Source/tasks.c **** 	 */
 542:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
 543:FreeRTOS/Source/tasks.c **** 
 544:FreeRTOS/Source/tasks.c **** #endif
 545:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 546:FreeRTOS/Source/tasks.c **** 
 547:FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 548:FreeRTOS/Source/tasks.c **** {
 549:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 550:FreeRTOS/Source/tasks.c **** TCB_t * pxNewTCB;
 551:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 552:FreeRTOS/Source/tasks.c **** 
 553:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 554:FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 555:FreeRTOS/Source/tasks.c **** 
 556:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 557:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 558:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 559:FreeRTOS/Source/tasks.c **** 
 560:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 561:FreeRTOS/Source/tasks.c **** 	{
 562:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 563:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 564:FreeRTOS/Source/tasks.c **** 			BaseType_t xRunPrivileged;
 565:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 566:FreeRTOS/Source/tasks.c **** 			{
 567:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 568:FreeRTOS/Source/tasks.c **** 			}
 569:FreeRTOS/Source/tasks.c **** 			else
 570:FreeRTOS/Source/tasks.c **** 			{
 571:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 572:FreeRTOS/Source/tasks.c **** 			}
 573:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 574:FreeRTOS/Source/tasks.c **** 
 575:FreeRTOS/Source/tasks.c **** 			if( puxStackBuffer != NULL )
 576:FreeRTOS/Source/tasks.c **** 			{
 577:FreeRTOS/Source/tasks.c **** 				/* The application provided its own stack.  Note this so no
 578:FreeRTOS/Source/tasks.c **** 				attempt is made to delete the stack should that task be
 579:FreeRTOS/Source/tasks.c **** 				deleted. */
 580:FreeRTOS/Source/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
 581:FreeRTOS/Source/tasks.c **** 			}
 582:FreeRTOS/Source/tasks.c **** 			else
 583:FreeRTOS/Source/tasks.c **** 			{
 584:FreeRTOS/Source/tasks.c **** 				/* The stack was allocated dynamically.  Note this so it can be
 585:FreeRTOS/Source/tasks.c **** 				deleted again if the task is deleted. */
 586:FreeRTOS/Source/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
 587:FreeRTOS/Source/tasks.c **** 			}
 588:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 589:FreeRTOS/Source/tasks.c **** 
 590:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 591:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 592:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 593:FreeRTOS/Source/tasks.c **** 		required by the port. */
 594:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 595:FreeRTOS/Source/tasks.c **** 		{
 596:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 597:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 598:FreeRTOS/Source/tasks.c **** 
 599:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 600:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_AL
 601:FreeRTOS/Source/tasks.c **** 		}
 602:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 603:FreeRTOS/Source/tasks.c **** 		{
 604:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 607:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBY
 608:FreeRTOS/Source/tasks.c **** 
 609:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 610:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 611:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 612:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 613:FreeRTOS/Source/tasks.c **** 		}
 614:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 615:FreeRTOS/Source/tasks.c **** 
 616:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 617:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 618:FreeRTOS/Source/tasks.c **** 
 619:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 620:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 621:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 622:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 623:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 624:FreeRTOS/Source/tasks.c **** 		{
 625:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 626:FreeRTOS/Source/tasks.c **** 		}
 627:FreeRTOS/Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 628:FreeRTOS/Source/tasks.c **** 		{
 629:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 630:FreeRTOS/Source/tasks.c **** 		}
 631:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 632:FreeRTOS/Source/tasks.c **** 
 633:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 634:FreeRTOS/Source/tasks.c **** 		{
 635:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 636:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 637:FreeRTOS/Source/tasks.c **** 			required.*/
 638:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 639:FreeRTOS/Source/tasks.c **** 		}
 640:FreeRTOS/Source/tasks.c **** 		else
 641:FreeRTOS/Source/tasks.c **** 		{
 642:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 643:FreeRTOS/Source/tasks.c **** 		}
 644:FreeRTOS/Source/tasks.c **** 
 645:FreeRTOS/Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 646:FreeRTOS/Source/tasks.c **** 		updated. */
 647:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 648:FreeRTOS/Source/tasks.c **** 		{
 649:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 650:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 651:FreeRTOS/Source/tasks.c **** 			{
 652:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 653:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 654:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 657:FreeRTOS/Source/tasks.c **** 				{
 658:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 659:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 660:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 661:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 662:FreeRTOS/Source/tasks.c **** 				}
 663:FreeRTOS/Source/tasks.c **** 				else
 664:FreeRTOS/Source/tasks.c **** 				{
 665:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 666:FreeRTOS/Source/tasks.c **** 				}
 667:FreeRTOS/Source/tasks.c **** 			}
 668:FreeRTOS/Source/tasks.c **** 			else
 669:FreeRTOS/Source/tasks.c **** 			{
 670:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 671:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 672:FreeRTOS/Source/tasks.c **** 				so far. */
 673:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 674:FreeRTOS/Source/tasks.c **** 				{
 675:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 676:FreeRTOS/Source/tasks.c **** 					{
 677:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 678:FreeRTOS/Source/tasks.c **** 					}
 679:FreeRTOS/Source/tasks.c **** 					else
 680:FreeRTOS/Source/tasks.c **** 					{
 681:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 682:FreeRTOS/Source/tasks.c **** 					}
 683:FreeRTOS/Source/tasks.c **** 				}
 684:FreeRTOS/Source/tasks.c **** 				else
 685:FreeRTOS/Source/tasks.c **** 				{
 686:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 687:FreeRTOS/Source/tasks.c **** 				}
 688:FreeRTOS/Source/tasks.c **** 			}
 689:FreeRTOS/Source/tasks.c **** 
 690:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 691:FreeRTOS/Source/tasks.c **** 
 692:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 693:FreeRTOS/Source/tasks.c **** 			{
 694:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 695:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 696:FreeRTOS/Source/tasks.c **** 			}
 697:FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 698:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 699:FreeRTOS/Source/tasks.c **** 
 700:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 703:FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 704:FreeRTOS/Source/tasks.c **** 		}
 705:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 706:FreeRTOS/Source/tasks.c **** 	}
 707:FreeRTOS/Source/tasks.c **** 	else
 708:FreeRTOS/Source/tasks.c **** 	{
 709:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 710:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 711:FreeRTOS/Source/tasks.c **** 	}
 712:FreeRTOS/Source/tasks.c **** 
 713:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 714:FreeRTOS/Source/tasks.c **** 	{
 715:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 716:FreeRTOS/Source/tasks.c **** 		{
 717:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 718:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 719:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 720:FreeRTOS/Source/tasks.c **** 			{
 721:FreeRTOS/Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 722:FreeRTOS/Source/tasks.c **** 			}
 723:FreeRTOS/Source/tasks.c **** 			else
 724:FreeRTOS/Source/tasks.c **** 			{
 725:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 726:FreeRTOS/Source/tasks.c **** 			}
 727:FreeRTOS/Source/tasks.c **** 		}
 728:FreeRTOS/Source/tasks.c **** 		else
 729:FreeRTOS/Source/tasks.c **** 		{
 730:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 731:FreeRTOS/Source/tasks.c **** 		}
 732:FreeRTOS/Source/tasks.c **** 	}
 733:FreeRTOS/Source/tasks.c **** 
 734:FreeRTOS/Source/tasks.c **** 	return xReturn;
 735:FreeRTOS/Source/tasks.c **** }
 736:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 737:FreeRTOS/Source/tasks.c **** 
 738:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 739:FreeRTOS/Source/tasks.c **** 
 740:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 741:FreeRTOS/Source/tasks.c **** 	{
 742:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 743:FreeRTOS/Source/tasks.c **** 
 744:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 745:FreeRTOS/Source/tasks.c **** 		{
 746:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 747:FreeRTOS/Source/tasks.c **** 			being deleted. */
 748:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 749:FreeRTOS/Source/tasks.c **** 
 750:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 751:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 752:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 753:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 754:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 755:FreeRTOS/Source/tasks.c **** 			{
 756:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 757:FreeRTOS/Source/tasks.c **** 			}
 758:FreeRTOS/Source/tasks.c **** 			else
 759:FreeRTOS/Source/tasks.c **** 			{
 760:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 761:FreeRTOS/Source/tasks.c **** 			}
 762:FreeRTOS/Source/tasks.c **** 
 763:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 764:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 765:FreeRTOS/Source/tasks.c **** 			{
 766:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 767:FreeRTOS/Source/tasks.c **** 			}
 768:FreeRTOS/Source/tasks.c **** 			else
 769:FreeRTOS/Source/tasks.c **** 			{
 770:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 771:FreeRTOS/Source/tasks.c **** 			}
 772:FreeRTOS/Source/tasks.c **** 
 773:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 774:FreeRTOS/Source/tasks.c **** 
 775:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 776:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 777:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 778:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 779:FreeRTOS/Source/tasks.c **** 
 780:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 781:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 782:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 783:FreeRTOS/Source/tasks.c **** 
 784:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 785:FreeRTOS/Source/tasks.c **** 		}
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 789:FreeRTOS/Source/tasks.c **** 		been deleted. */
 790:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 791:FreeRTOS/Source/tasks.c **** 		{
 792:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 793:FreeRTOS/Source/tasks.c **** 			{
 794:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 795:FreeRTOS/Source/tasks.c **** 
 796:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 797:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
 798:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
 799:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 800:FreeRTOS/Source/tasks.c **** 				required. */
 801:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 802:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 803:FreeRTOS/Source/tasks.c **** 			}
 804:FreeRTOS/Source/tasks.c **** 			else
 805:FreeRTOS/Source/tasks.c **** 			{
 806:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 807:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
 808:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 809:FreeRTOS/Source/tasks.c **** 				{
 810:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 811:FreeRTOS/Source/tasks.c **** 				}
 812:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 813:FreeRTOS/Source/tasks.c **** 			}
 814:FreeRTOS/Source/tasks.c **** 		}
 815:FreeRTOS/Source/tasks.c **** 	}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 818:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 819:FreeRTOS/Source/tasks.c **** 
 820:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 821:FreeRTOS/Source/tasks.c **** 
 822:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 823:FreeRTOS/Source/tasks.c **** 	{
 824:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 825:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 826:FreeRTOS/Source/tasks.c **** 
 827:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 828:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 829:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 830:FreeRTOS/Source/tasks.c **** 
 831:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 832:FreeRTOS/Source/tasks.c **** 		{
 833:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 834:FreeRTOS/Source/tasks.c **** 			block. */
 835:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 836:FreeRTOS/Source/tasks.c **** 
 837:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 838:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 839:FreeRTOS/Source/tasks.c **** 
 840:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 841:FreeRTOS/Source/tasks.c **** 			{
 842:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 843:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 844:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 845:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 846:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 847:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 848:FreeRTOS/Source/tasks.c **** 				{
 849:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 850:FreeRTOS/Source/tasks.c **** 				}
 851:FreeRTOS/Source/tasks.c **** 				else
 852:FreeRTOS/Source/tasks.c **** 				{
 853:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 854:FreeRTOS/Source/tasks.c **** 				}
 855:FreeRTOS/Source/tasks.c **** 			}
 856:FreeRTOS/Source/tasks.c **** 			else
 857:FreeRTOS/Source/tasks.c **** 			{
 858:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 859:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 860:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 861:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 862:FreeRTOS/Source/tasks.c **** 				{
 863:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 864:FreeRTOS/Source/tasks.c **** 				}
 865:FreeRTOS/Source/tasks.c **** 				else
 866:FreeRTOS/Source/tasks.c **** 				{
 867:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 			}
 870:FreeRTOS/Source/tasks.c **** 
 871:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 872:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 873:FreeRTOS/Source/tasks.c **** 
 874:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 875:FreeRTOS/Source/tasks.c **** 			{
 876:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 877:FreeRTOS/Source/tasks.c **** 
 878:FreeRTOS/Source/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 879:FreeRTOS/Source/tasks.c **** 				blocked list as the same list item is used for both lists. */
 880:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 881:FreeRTOS/Source/tasks.c **** 				{
 882:FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 883:FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 884:FreeRTOS/Source/tasks.c **** 					directly. */
 885:FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 886:FreeRTOS/Source/tasks.c **** 				}
 887:FreeRTOS/Source/tasks.c **** 				else
 888:FreeRTOS/Source/tasks.c **** 				{
 889:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 890:FreeRTOS/Source/tasks.c **** 				}
 891:FreeRTOS/Source/tasks.c **** 
 892:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 893:FreeRTOS/Source/tasks.c **** 			}
 894:FreeRTOS/Source/tasks.c **** 			else
 895:FreeRTOS/Source/tasks.c **** 			{
 896:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 897:FreeRTOS/Source/tasks.c **** 			}
 898:FreeRTOS/Source/tasks.c **** 		}
 899:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 900:FreeRTOS/Source/tasks.c **** 
 901:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 902:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 903:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 904:FreeRTOS/Source/tasks.c **** 		{
 905:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 906:FreeRTOS/Source/tasks.c **** 		}
 907:FreeRTOS/Source/tasks.c **** 		else
 908:FreeRTOS/Source/tasks.c **** 		{
 909:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 910:FreeRTOS/Source/tasks.c **** 		}
 911:FreeRTOS/Source/tasks.c **** 	}
 912:FreeRTOS/Source/tasks.c **** 
 913:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 914:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 915:FreeRTOS/Source/tasks.c **** 
 916:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 917:FreeRTOS/Source/tasks.c **** 
 918:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 919:FreeRTOS/Source/tasks.c **** 	{
 920:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 921:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 922:FreeRTOS/Source/tasks.c **** 
 923:FreeRTOS/Source/tasks.c **** 
 924:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 925:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 926:FreeRTOS/Source/tasks.c **** 		{
 927:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 928:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 929:FreeRTOS/Source/tasks.c **** 			{
 930:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 931:FreeRTOS/Source/tasks.c **** 
 932:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 933:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 934:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 935:FreeRTOS/Source/tasks.c **** 				is resumed.
 936:FreeRTOS/Source/tasks.c **** 
 937:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 938:FreeRTOS/Source/tasks.c **** 				executing task. */
 939:FreeRTOS/Source/tasks.c **** 
 940:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 941:FreeRTOS/Source/tasks.c **** 				not a problem. */
 942:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 943:FreeRTOS/Source/tasks.c **** 
 944:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 945:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 946:FreeRTOS/Source/tasks.c **** 				both lists. */
 947:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 948:FreeRTOS/Source/tasks.c **** 				{
 949:FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 950:FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 951:FreeRTOS/Source/tasks.c **** 					directly. */
 952:FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 953:FreeRTOS/Source/tasks.c **** 				}
 954:FreeRTOS/Source/tasks.c **** 				else
 955:FreeRTOS/Source/tasks.c **** 				{
 956:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 957:FreeRTOS/Source/tasks.c **** 				}
 958:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 959:FreeRTOS/Source/tasks.c **** 			}
 960:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 961:FreeRTOS/Source/tasks.c **** 		}
 962:FreeRTOS/Source/tasks.c **** 		else
 963:FreeRTOS/Source/tasks.c **** 		{
 964:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 965:FreeRTOS/Source/tasks.c **** 		}
 966:FreeRTOS/Source/tasks.c **** 
 967:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 968:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 969:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 970:FreeRTOS/Source/tasks.c **** 		{
 971:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 972:FreeRTOS/Source/tasks.c **** 		}
 973:FreeRTOS/Source/tasks.c **** 		else
 974:FreeRTOS/Source/tasks.c **** 		{
 975:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 976:FreeRTOS/Source/tasks.c **** 		}
 977:FreeRTOS/Source/tasks.c **** 	}
 978:FreeRTOS/Source/tasks.c **** 
 979:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 980:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 981:FreeRTOS/Source/tasks.c **** 
 982:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 983:FreeRTOS/Source/tasks.c **** 
 984:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 985:FreeRTOS/Source/tasks.c **** 	{
 986:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 987:FreeRTOS/Source/tasks.c **** 	List_t *pxStateList;
 988:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 989:FreeRTOS/Source/tasks.c **** 
 990:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
 991:FreeRTOS/Source/tasks.c **** 
 992:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 993:FreeRTOS/Source/tasks.c **** 		{
 994:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 995:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
 996:FreeRTOS/Source/tasks.c **** 		}
 997:FreeRTOS/Source/tasks.c **** 		else
 998:FreeRTOS/Source/tasks.c **** 		{
 999:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1000:FreeRTOS/Source/tasks.c **** 			{
1001:FreeRTOS/Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
1002:FreeRTOS/Source/tasks.c **** 			}
1003:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1004:FreeRTOS/Source/tasks.c **** 
1005:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1006:FreeRTOS/Source/tasks.c **** 			{
1007:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1008:FreeRTOS/Source/tasks.c **** 				lists. */
1009:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1010:FreeRTOS/Source/tasks.c **** 			}
1011:FreeRTOS/Source/tasks.c **** 
1012:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1013:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1014:FreeRTOS/Source/tasks.c **** 				{
1015:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1016:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
1017:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1018:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1019:FreeRTOS/Source/tasks.c **** 					{
1020:FreeRTOS/Source/tasks.c **** 						eReturn = eSuspended;
1021:FreeRTOS/Source/tasks.c **** 					}
1022:FreeRTOS/Source/tasks.c **** 					else
1023:FreeRTOS/Source/tasks.c **** 					{
1024:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1025:FreeRTOS/Source/tasks.c **** 					}
1026:FreeRTOS/Source/tasks.c **** 				}
1027:FreeRTOS/Source/tasks.c **** 			#endif
1028:FreeRTOS/Source/tasks.c **** 
1029:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1030:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
1031:FreeRTOS/Source/tasks.c **** 				{
1032:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1033:FreeRTOS/Source/tasks.c **** 					tasks list. */
1034:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1035:FreeRTOS/Source/tasks.c **** 				}
1036:FreeRTOS/Source/tasks.c **** 			#endif
1037:FreeRTOS/Source/tasks.c **** 
1038:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1039:FreeRTOS/Source/tasks.c **** 			{
1040:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1041:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1042:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1043:FreeRTOS/Source/tasks.c **** 			}
1044:FreeRTOS/Source/tasks.c **** 		}
1045:FreeRTOS/Source/tasks.c **** 
1046:FreeRTOS/Source/tasks.c **** 		return eReturn;
1047:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1048:FreeRTOS/Source/tasks.c **** 
1049:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1051:FreeRTOS/Source/tasks.c **** 
1052:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1053:FreeRTOS/Source/tasks.c **** 
1054:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1055:FreeRTOS/Source/tasks.c **** 	{
1056:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1057:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1058:FreeRTOS/Source/tasks.c **** 
1059:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1060:FreeRTOS/Source/tasks.c **** 		{
1061:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
1062:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
1063:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1064:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1065:FreeRTOS/Source/tasks.c **** 		}
1066:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1067:FreeRTOS/Source/tasks.c **** 
1068:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1069:FreeRTOS/Source/tasks.c **** 	}
1070:FreeRTOS/Source/tasks.c **** 
1071:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1072:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1073:FreeRTOS/Source/tasks.c **** 
1074:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1075:FreeRTOS/Source/tasks.c **** 
1076:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1077:FreeRTOS/Source/tasks.c **** 	{
1078:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1079:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1080:FreeRTOS/Source/tasks.c **** 
1081:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1082:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1083:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1084:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1085:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1086:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1087:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1088:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1089:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1090:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1091:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1092:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1093:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1094:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1095:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1096:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1097:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1098:FreeRTOS/Source/tasks.c **** 
1099:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1100:FreeRTOS/Source/tasks.c **** 		{
1101:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1102:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1103:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1104:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1105:FreeRTOS/Source/tasks.c **** 		}
1106:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1107:FreeRTOS/Source/tasks.c **** 
1108:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1109:FreeRTOS/Source/tasks.c **** 	}
1110:FreeRTOS/Source/tasks.c **** 
1111:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1112:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1113:FreeRTOS/Source/tasks.c **** 
1114:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1115:FreeRTOS/Source/tasks.c **** 
1116:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1117:FreeRTOS/Source/tasks.c **** 	{
1118:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1119:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1120:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1121:FreeRTOS/Source/tasks.c **** 
1122:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1123:FreeRTOS/Source/tasks.c **** 
1124:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1125:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1126:FreeRTOS/Source/tasks.c **** 		{
1127:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1128:FreeRTOS/Source/tasks.c **** 		}
1129:FreeRTOS/Source/tasks.c **** 		else
1130:FreeRTOS/Source/tasks.c **** 		{
1131:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1132:FreeRTOS/Source/tasks.c **** 		}
1133:FreeRTOS/Source/tasks.c **** 
1134:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1135:FreeRTOS/Source/tasks.c **** 		{
1136:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1137:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1138:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1139:FreeRTOS/Source/tasks.c **** 
1140:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1141:FreeRTOS/Source/tasks.c **** 
1142:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1143:FreeRTOS/Source/tasks.c **** 			{
1144:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1145:FreeRTOS/Source/tasks.c **** 			}
1146:FreeRTOS/Source/tasks.c **** 			#else
1147:FreeRTOS/Source/tasks.c **** 			{
1148:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1149:FreeRTOS/Source/tasks.c **** 			}
1150:FreeRTOS/Source/tasks.c **** 			#endif
1151:FreeRTOS/Source/tasks.c **** 
1152:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1153:FreeRTOS/Source/tasks.c **** 			{
1154:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1155:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1156:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1157:FreeRTOS/Source/tasks.c **** 				{
1158:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1159:FreeRTOS/Source/tasks.c **** 					{
1160:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1161:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1162:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1163:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1164:FreeRTOS/Source/tasks.c **** 						{
1165:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1166:FreeRTOS/Source/tasks.c **** 						}
1167:FreeRTOS/Source/tasks.c **** 						else
1168:FreeRTOS/Source/tasks.c **** 						{
1169:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1170:FreeRTOS/Source/tasks.c **** 						}
1171:FreeRTOS/Source/tasks.c **** 					}
1172:FreeRTOS/Source/tasks.c **** 					else
1173:FreeRTOS/Source/tasks.c **** 					{
1174:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1175:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1176:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1177:FreeRTOS/Source/tasks.c **** 					}
1178:FreeRTOS/Source/tasks.c **** 				}
1179:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1180:FreeRTOS/Source/tasks.c **** 				{
1181:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1182:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1183:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1184:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1185:FreeRTOS/Source/tasks.c **** 				}
1186:FreeRTOS/Source/tasks.c **** 				else
1187:FreeRTOS/Source/tasks.c **** 				{
1188:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1189:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1190:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1191:FreeRTOS/Source/tasks.c **** 				}
1192:FreeRTOS/Source/tasks.c **** 
1193:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1194:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1195:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1196:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1197:FreeRTOS/Source/tasks.c **** 
1198:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1199:FreeRTOS/Source/tasks.c **** 				{
1200:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1201:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1202:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1203:FreeRTOS/Source/tasks.c **** 					{
1204:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1205:FreeRTOS/Source/tasks.c **** 					}
1206:FreeRTOS/Source/tasks.c **** 					else
1207:FreeRTOS/Source/tasks.c **** 					{
1208:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1209:FreeRTOS/Source/tasks.c **** 					}
1210:FreeRTOS/Source/tasks.c **** 
1211:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1212:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1213:FreeRTOS/Source/tasks.c **** 				}
1214:FreeRTOS/Source/tasks.c **** 				#else
1215:FreeRTOS/Source/tasks.c **** 				{
1216:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1217:FreeRTOS/Source/tasks.c **** 				}
1218:FreeRTOS/Source/tasks.c **** 				#endif
1219:FreeRTOS/Source/tasks.c **** 
1220:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1221:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1222:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1223:FreeRTOS/Source/tasks.c **** 				{
1224:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1225:FreeRTOS/Source/tasks.c **** 				}
1226:FreeRTOS/Source/tasks.c **** 				else
1227:FreeRTOS/Source/tasks.c **** 				{
1228:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1229:FreeRTOS/Source/tasks.c **** 				}
1230:FreeRTOS/Source/tasks.c **** 
1231:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1232:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1233:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1234:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1235:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
1236:FreeRTOS/Source/tasks.c **** 				{
1237:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1238:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1239:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1240:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1241:FreeRTOS/Source/tasks.c **** 					{
1242:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1243:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1244:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1245:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1246:FreeRTOS/Source/tasks.c **** 					}
1247:FreeRTOS/Source/tasks.c **** 					else
1248:FreeRTOS/Source/tasks.c **** 					{
1249:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1250:FreeRTOS/Source/tasks.c **** 					}
1251:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1252:FreeRTOS/Source/tasks.c **** 				}
1253:FreeRTOS/Source/tasks.c **** 				else
1254:FreeRTOS/Source/tasks.c **** 				{
1255:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1256:FreeRTOS/Source/tasks.c **** 				}
1257:FreeRTOS/Source/tasks.c **** 
1258:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1259:FreeRTOS/Source/tasks.c **** 				{
1260:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1261:FreeRTOS/Source/tasks.c **** 				}
1262:FreeRTOS/Source/tasks.c **** 				else
1263:FreeRTOS/Source/tasks.c **** 				{
1264:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1265:FreeRTOS/Source/tasks.c **** 				}
1266:FreeRTOS/Source/tasks.c **** 
1267:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1268:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1269:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1270:FreeRTOS/Source/tasks.c **** 			}
1271:FreeRTOS/Source/tasks.c **** 		}
1272:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1273:FreeRTOS/Source/tasks.c **** 	}
1274:FreeRTOS/Source/tasks.c **** 
1275:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1276:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1277:FreeRTOS/Source/tasks.c **** 
1278:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1279:FreeRTOS/Source/tasks.c **** 
1280:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1281:FreeRTOS/Source/tasks.c **** 	{
1282:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1283:FreeRTOS/Source/tasks.c **** 
1284:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1285:FreeRTOS/Source/tasks.c **** 		{
1286:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1287:FreeRTOS/Source/tasks.c **** 			being suspended. */
1288:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1289:FreeRTOS/Source/tasks.c **** 
1290:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1291:FreeRTOS/Source/tasks.c **** 
1292:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1293:FreeRTOS/Source/tasks.c **** 			suspended list. */
1294:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1295:FreeRTOS/Source/tasks.c **** 			{
1296:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1297:FreeRTOS/Source/tasks.c **** 			}
1298:FreeRTOS/Source/tasks.c **** 			else
1299:FreeRTOS/Source/tasks.c **** 			{
1300:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1301:FreeRTOS/Source/tasks.c **** 			}
1302:FreeRTOS/Source/tasks.c **** 
1303:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1304:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1305:FreeRTOS/Source/tasks.c **** 			{
1306:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1307:FreeRTOS/Source/tasks.c **** 			}
1308:FreeRTOS/Source/tasks.c **** 			else
1309:FreeRTOS/Source/tasks.c **** 			{
1310:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1311:FreeRTOS/Source/tasks.c **** 			}
1312:FreeRTOS/Source/tasks.c **** 
1313:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1314:FreeRTOS/Source/tasks.c **** 		}
1315:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1316:FreeRTOS/Source/tasks.c **** 
1317:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1318:FreeRTOS/Source/tasks.c **** 		{
1319:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1320:FreeRTOS/Source/tasks.c **** 			{
1321:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1322:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1323:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1324:FreeRTOS/Source/tasks.c **** 			}
1325:FreeRTOS/Source/tasks.c **** 			else
1326:FreeRTOS/Source/tasks.c **** 			{
1327:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1328:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1329:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1330:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1331:FreeRTOS/Source/tasks.c **** 				{
1332:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1333:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1334:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1335:FreeRTOS/Source/tasks.c **** 					is. */
1336:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1337:FreeRTOS/Source/tasks.c **** 				}
1338:FreeRTOS/Source/tasks.c **** 				else
1339:FreeRTOS/Source/tasks.c **** 				{
1340:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1341:FreeRTOS/Source/tasks.c **** 				}
1342:FreeRTOS/Source/tasks.c **** 			}
1343:FreeRTOS/Source/tasks.c **** 		}
1344:FreeRTOS/Source/tasks.c **** 		else
1345:FreeRTOS/Source/tasks.c **** 		{
1346:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1347:FreeRTOS/Source/tasks.c **** 			{
1348:FreeRTOS/Source/tasks.c **** 				/* A task other than the currently running task was suspended,
1349:FreeRTOS/Source/tasks.c **** 				reset the next expected unblock time in case it referred to the
1350:FreeRTOS/Source/tasks.c **** 				task that is now in the Suspended state. */
1351:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
1352:FreeRTOS/Source/tasks.c **** 				{
1353:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
1354:FreeRTOS/Source/tasks.c **** 				}
1355:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
1356:FreeRTOS/Source/tasks.c **** 			}
1357:FreeRTOS/Source/tasks.c **** 			else
1358:FreeRTOS/Source/tasks.c **** 			{
1359:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1360:FreeRTOS/Source/tasks.c **** 			}
1361:FreeRTOS/Source/tasks.c **** 		}
1362:FreeRTOS/Source/tasks.c **** 	}
1363:FreeRTOS/Source/tasks.c **** 
1364:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1365:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1366:FreeRTOS/Source/tasks.c **** 
1367:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1368:FreeRTOS/Source/tasks.c **** 
1369:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1370:FreeRTOS/Source/tasks.c **** 	{
1371:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1372:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1373:FreeRTOS/Source/tasks.c **** 
1374:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1375:FreeRTOS/Source/tasks.c **** 		section. */
1376:FreeRTOS/Source/tasks.c **** 
1377:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1378:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1381:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1382:FreeRTOS/Source/tasks.c **** 		{
1383:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1384:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1385:FreeRTOS/Source/tasks.c **** 			{
1386:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1387:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1388:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1389:FreeRTOS/Source/tasks.c **** 				{
1390:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1391:FreeRTOS/Source/tasks.c **** 				}
1392:FreeRTOS/Source/tasks.c **** 				else
1393:FreeRTOS/Source/tasks.c **** 				{
1394:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1395:FreeRTOS/Source/tasks.c **** 				}
1396:FreeRTOS/Source/tasks.c **** 			}
1397:FreeRTOS/Source/tasks.c **** 			else
1398:FreeRTOS/Source/tasks.c **** 			{
1399:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1400:FreeRTOS/Source/tasks.c **** 			}
1401:FreeRTOS/Source/tasks.c **** 		}
1402:FreeRTOS/Source/tasks.c **** 		else
1403:FreeRTOS/Source/tasks.c **** 		{
1404:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1405:FreeRTOS/Source/tasks.c **** 		}
1406:FreeRTOS/Source/tasks.c **** 
1407:FreeRTOS/Source/tasks.c **** 		return xReturn;
1408:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1409:FreeRTOS/Source/tasks.c **** 
1410:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1411:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1412:FreeRTOS/Source/tasks.c **** 
1413:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1414:FreeRTOS/Source/tasks.c **** 
1415:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1416:FreeRTOS/Source/tasks.c **** 	{
1417:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1420:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1421:FreeRTOS/Source/tasks.c **** 
1422:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1423:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1424:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1425:FreeRTOS/Source/tasks.c **** 		{
1426:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1427:FreeRTOS/Source/tasks.c **** 			{
1428:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1429:FreeRTOS/Source/tasks.c **** 				{
1430:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1431:FreeRTOS/Source/tasks.c **** 
1432:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1433:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1434:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1435:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1436:FreeRTOS/Source/tasks.c **** 
1437:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1438:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1439:FreeRTOS/Source/tasks.c **** 					{
1440:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1441:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1442:FreeRTOS/Source/tasks.c **** 						next yield. */
1443:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1444:FreeRTOS/Source/tasks.c **** 					}
1445:FreeRTOS/Source/tasks.c **** 					else
1446:FreeRTOS/Source/tasks.c **** 					{
1447:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1448:FreeRTOS/Source/tasks.c **** 					}
1449:FreeRTOS/Source/tasks.c **** 				}
1450:FreeRTOS/Source/tasks.c **** 				else
1451:FreeRTOS/Source/tasks.c **** 				{
1452:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1453:FreeRTOS/Source/tasks.c **** 				}
1454:FreeRTOS/Source/tasks.c **** 			}
1455:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1456:FreeRTOS/Source/tasks.c **** 		}
1457:FreeRTOS/Source/tasks.c **** 		else
1458:FreeRTOS/Source/tasks.c **** 		{
1459:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1460:FreeRTOS/Source/tasks.c **** 		}
1461:FreeRTOS/Source/tasks.c **** 	}
1462:FreeRTOS/Source/tasks.c **** 
1463:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1464:FreeRTOS/Source/tasks.c **** 
1465:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1466:FreeRTOS/Source/tasks.c **** 
1467:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1468:FreeRTOS/Source/tasks.c **** 
1469:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1470:FreeRTOS/Source/tasks.c **** 	{
1471:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1472:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1473:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1474:FreeRTOS/Source/tasks.c **** 
1475:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1476:FreeRTOS/Source/tasks.c **** 
1477:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1478:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1479:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1480:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1481:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1482:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1483:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1484:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1485:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1486:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1487:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1488:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1489:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1490:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1491:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1492:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1493:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1494:FreeRTOS/Source/tasks.c **** 
1495:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1496:FreeRTOS/Source/tasks.c **** 		{
1497:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1498:FreeRTOS/Source/tasks.c **** 			{
1499:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1500:FreeRTOS/Source/tasks.c **** 
1501:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1502:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1503:FreeRTOS/Source/tasks.c **** 				{
1504:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1505:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1506:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1507:FreeRTOS/Source/tasks.c **** 					{
1508:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1509:FreeRTOS/Source/tasks.c **** 					}
1510:FreeRTOS/Source/tasks.c **** 					else
1511:FreeRTOS/Source/tasks.c **** 					{
1512:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1513:FreeRTOS/Source/tasks.c **** 					}
1514:FreeRTOS/Source/tasks.c **** 
1515:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1516:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1517:FreeRTOS/Source/tasks.c **** 				}
1518:FreeRTOS/Source/tasks.c **** 				else
1519:FreeRTOS/Source/tasks.c **** 				{
1520:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1521:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1522:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1523:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1524:FreeRTOS/Source/tasks.c **** 				}
1525:FreeRTOS/Source/tasks.c **** 			}
1526:FreeRTOS/Source/tasks.c **** 			else
1527:FreeRTOS/Source/tasks.c **** 			{
1528:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1529:FreeRTOS/Source/tasks.c **** 			}
1530:FreeRTOS/Source/tasks.c **** 		}
1531:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1532:FreeRTOS/Source/tasks.c **** 
1533:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1534:FreeRTOS/Source/tasks.c **** 	}
1535:FreeRTOS/Source/tasks.c **** 
1536:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1537:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1538:FreeRTOS/Source/tasks.c **** 
1539:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1540:FreeRTOS/Source/tasks.c **** {
1541:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1542:FreeRTOS/Source/tasks.c **** 
1543:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1544:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1545:FreeRTOS/Source/tasks.c **** 	{
1546:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1547:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1548:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1549:FreeRTOS/Source/tasks.c **** 	}
1550:FreeRTOS/Source/tasks.c **** 	#else
1551:FreeRTOS/Source/tasks.c **** 	{
1552:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1553:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1554:FreeRTOS/Source/tasks.c **** 	}
1555:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1556:FreeRTOS/Source/tasks.c **** 
1557:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1558:FreeRTOS/Source/tasks.c **** 	{
1559:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1560:FreeRTOS/Source/tasks.c **** 		{
1561:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1562:FreeRTOS/Source/tasks.c **** 		}
1563:FreeRTOS/Source/tasks.c **** 		else
1564:FreeRTOS/Source/tasks.c **** 		{
1565:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1566:FreeRTOS/Source/tasks.c **** 		}
1567:FreeRTOS/Source/tasks.c **** 	}
1568:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1569:FreeRTOS/Source/tasks.c **** 
1570:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1571:FreeRTOS/Source/tasks.c **** 	{
1572:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1573:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1574:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1575:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1576:FreeRTOS/Source/tasks.c **** 		starts to run. */
1577:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1578:FreeRTOS/Source/tasks.c **** 
1579:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1580:FreeRTOS/Source/tasks.c **** 		{
1581:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1582:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
1583:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1584:FreeRTOS/Source/tasks.c **** 		}
1585:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1586:FreeRTOS/Source/tasks.c **** 
1587:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1588:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
1589:FreeRTOS/Source/tasks.c **** 
1590:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1591:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1592:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1593:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1594:FreeRTOS/Source/tasks.c **** 
1595:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1596:FreeRTOS/Source/tasks.c **** 		portable interface. */
1597:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1598:FreeRTOS/Source/tasks.c **** 		{
1599:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1600:FreeRTOS/Source/tasks.c **** 			function will not return. */
1601:FreeRTOS/Source/tasks.c **** 		}
1602:FreeRTOS/Source/tasks.c **** 		else
1603:FreeRTOS/Source/tasks.c **** 		{
1604:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1605:FreeRTOS/Source/tasks.c **** 		}
1606:FreeRTOS/Source/tasks.c **** 	}
1607:FreeRTOS/Source/tasks.c **** 	else
1608:FreeRTOS/Source/tasks.c **** 	{
1609:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1610:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1611:FreeRTOS/Source/tasks.c **** 		or the timer task. */
1612:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn );
1613:FreeRTOS/Source/tasks.c **** 	}
1614:FreeRTOS/Source/tasks.c **** }
1615:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1616:FreeRTOS/Source/tasks.c **** 
1617:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1618:FreeRTOS/Source/tasks.c **** {
1619:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1620:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1621:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1622:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1623:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1624:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
1625:FreeRTOS/Source/tasks.c **** }
1626:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1627:FreeRTOS/Source/tasks.c **** 
1628:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1629:FreeRTOS/Source/tasks.c **** {
1630:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1631:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1632:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1633:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
1634:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
1635:FreeRTOS/Source/tasks.c **** }
1636:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1637:FreeRTOS/Source/tasks.c **** 
1638:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1641:FreeRTOS/Source/tasks.c **** 	{
1642:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
1643:FreeRTOS/Source/tasks.c **** 
1644:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1645:FreeRTOS/Source/tasks.c **** 		{
1646:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1647:FreeRTOS/Source/tasks.c **** 		}
1648:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1649:FreeRTOS/Source/tasks.c **** 		{
1650:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1651:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1652:FreeRTOS/Source/tasks.c **** 			processed. */
1653:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1654:FreeRTOS/Source/tasks.c **** 		}
1655:FreeRTOS/Source/tasks.c **** 		else
1656:FreeRTOS/Source/tasks.c **** 		{
1657:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1658:FreeRTOS/Source/tasks.c **** 		}
1659:FreeRTOS/Source/tasks.c **** 
1660:FreeRTOS/Source/tasks.c **** 		return xReturn;
1661:FreeRTOS/Source/tasks.c **** 	}
1662:FreeRTOS/Source/tasks.c **** 
1663:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1664:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1665:FreeRTOS/Source/tasks.c **** 
1666:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
1667:FreeRTOS/Source/tasks.c **** {
1668:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
1669:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
1670:FreeRTOS/Source/tasks.c **** 
1671:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1672:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1673:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1674:FreeRTOS/Source/tasks.c **** 
1675:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1676:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1677:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1678:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1679:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1680:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1681:FreeRTOS/Source/tasks.c **** 	{
1682:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
1683:FreeRTOS/Source/tasks.c **** 
1684:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1685:FreeRTOS/Source/tasks.c **** 		{
1686:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
1687:FreeRTOS/Source/tasks.c **** 			{
1688:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1689:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1690:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1691:FreeRTOS/Source/tasks.c **** 				{
1692:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1693:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1694:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1695:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1696:FreeRTOS/Source/tasks.c **** 
1697:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
1698:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
1699:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1700:FreeRTOS/Source/tasks.c **** 					{
1701:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
1702:FreeRTOS/Source/tasks.c **** 					}
1703:FreeRTOS/Source/tasks.c **** 					else
1704:FreeRTOS/Source/tasks.c **** 					{
1705:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1706:FreeRTOS/Source/tasks.c **** 					}
1707:FreeRTOS/Source/tasks.c **** 				}
1708:FreeRTOS/Source/tasks.c **** 
1709:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1710:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
1711:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1712:FreeRTOS/Source/tasks.c **** 				time. */
1713:FreeRTOS/Source/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
1714:FreeRTOS/Source/tasks.c **** 				{
1715:FreeRTOS/Source/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
1716:FreeRTOS/Source/tasks.c **** 					{
1717:FreeRTOS/Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
1718:FreeRTOS/Source/tasks.c **** 						{
1719:FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
1720:FreeRTOS/Source/tasks.c **** 						}
1721:FreeRTOS/Source/tasks.c **** 						else
1722:FreeRTOS/Source/tasks.c **** 						{
1723:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1724:FreeRTOS/Source/tasks.c **** 						}
1725:FreeRTOS/Source/tasks.c **** 						--uxPendedTicks;
1726:FreeRTOS/Source/tasks.c **** 					}
1727:FreeRTOS/Source/tasks.c **** 				}
1728:FreeRTOS/Source/tasks.c **** 				else
1729:FreeRTOS/Source/tasks.c **** 				{
1730:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1731:FreeRTOS/Source/tasks.c **** 				}
1732:FreeRTOS/Source/tasks.c **** 
1733:FreeRTOS/Source/tasks.c **** 				if( xYieldPending == pdTRUE )
1734:FreeRTOS/Source/tasks.c **** 				{
1735:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1736:FreeRTOS/Source/tasks.c **** 					{
1737:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
1738:FreeRTOS/Source/tasks.c **** 					}
1739:FreeRTOS/Source/tasks.c **** 					#endif
1740:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1741:FreeRTOS/Source/tasks.c **** 				}
1742:FreeRTOS/Source/tasks.c **** 				else
1743:FreeRTOS/Source/tasks.c **** 				{
1744:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1745:FreeRTOS/Source/tasks.c **** 				}
1746:FreeRTOS/Source/tasks.c **** 			}
1747:FreeRTOS/Source/tasks.c **** 		}
1748:FreeRTOS/Source/tasks.c **** 		else
1749:FreeRTOS/Source/tasks.c **** 		{
1750:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1751:FreeRTOS/Source/tasks.c **** 		}
1752:FreeRTOS/Source/tasks.c **** 	}
1753:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1754:FreeRTOS/Source/tasks.c **** 
1755:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
1756:FreeRTOS/Source/tasks.c **** }
1757:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1758:FreeRTOS/Source/tasks.c **** 
1759:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
1760:FreeRTOS/Source/tasks.c **** {
1761:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
1762:FreeRTOS/Source/tasks.c **** 
1763:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1764:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
1765:FreeRTOS/Source/tasks.c **** 	{
1766:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
1767:FreeRTOS/Source/tasks.c **** 	}
1768:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
1769:FreeRTOS/Source/tasks.c **** 
1770:FreeRTOS/Source/tasks.c **** 	return xTicks;
1771:FreeRTOS/Source/tasks.c **** }
1772:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1773:FreeRTOS/Source/tasks.c **** 
1774:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1775:FreeRTOS/Source/tasks.c **** {
1776:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
1777:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1778:FreeRTOS/Source/tasks.c **** 
1779:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1780:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1781:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1782:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1783:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1784:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1785:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1786:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1787:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1788:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1789:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1790:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1791:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1792:FreeRTOS/Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1793:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1794:FreeRTOS/Source/tasks.c **** 
1795:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1796:FreeRTOS/Source/tasks.c **** 	{
1797:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
1798:FreeRTOS/Source/tasks.c **** 	}
1799:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1800:FreeRTOS/Source/tasks.c **** 
1801:FreeRTOS/Source/tasks.c **** 	return xReturn;
1802:FreeRTOS/Source/tasks.c **** }
1803:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1804:FreeRTOS/Source/tasks.c **** 
1805:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1806:FreeRTOS/Source/tasks.c **** {
1807:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1808:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
1809:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1810:FreeRTOS/Source/tasks.c **** }
1811:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1814:FreeRTOS/Source/tasks.c **** 
1815:FreeRTOS/Source/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allow
1816:FreeRTOS/Source/tasks.c **** 	{
1817:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1818:FreeRTOS/Source/tasks.c **** 
1819:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1820:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1821:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1822:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1823:FreeRTOS/Source/tasks.c **** 	}
1824:FreeRTOS/Source/tasks.c **** 
1825:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1826:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1827:FreeRTOS/Source/tasks.c **** 
1828:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1829:FreeRTOS/Source/tasks.c **** 
1830:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1831:FreeRTOS/Source/tasks.c **** 	{
1832:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1833:FreeRTOS/Source/tasks.c **** 
1834:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1835:FreeRTOS/Source/tasks.c **** 		{
1836:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1837:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1838:FreeRTOS/Source/tasks.c **** 			{
1839:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1840:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
1841:FreeRTOS/Source/tasks.c **** 				do
1842:FreeRTOS/Source/tasks.c **** 				{
1843:FreeRTOS/Source/tasks.c **** 					uxQueue--;
1844:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
1847:FreeRTOS/Source/tasks.c **** 
1848:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1849:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
1850:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
1851:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
1852:FreeRTOS/Source/tasks.c **** 
1853:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1854:FreeRTOS/Source/tasks.c **** 				{
1855:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1856:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1857:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1858:FreeRTOS/Source/tasks.c **** 				}
1859:FreeRTOS/Source/tasks.c **** 				#endif
1860:FreeRTOS/Source/tasks.c **** 
1861:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1862:FreeRTOS/Source/tasks.c **** 				{
1863:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1864:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
1865:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1866:FreeRTOS/Source/tasks.c **** 				}
1867:FreeRTOS/Source/tasks.c **** 				#endif
1868:FreeRTOS/Source/tasks.c **** 
1869:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1870:FreeRTOS/Source/tasks.c **** 				{
1871:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1872:FreeRTOS/Source/tasks.c **** 					{
1873:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1874:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1875:FreeRTOS/Source/tasks.c **** 						#else
1876:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1877:FreeRTOS/Source/tasks.c **** 						#endif
1878:FreeRTOS/Source/tasks.c **** 					}
1879:FreeRTOS/Source/tasks.c **** 				}
1880:FreeRTOS/Source/tasks.c **** 				#else
1881:FreeRTOS/Source/tasks.c **** 				{
1882:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1883:FreeRTOS/Source/tasks.c **** 					{
1884:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
1885:FreeRTOS/Source/tasks.c **** 					}
1886:FreeRTOS/Source/tasks.c **** 				}
1887:FreeRTOS/Source/tasks.c **** 				#endif
1888:FreeRTOS/Source/tasks.c **** 			}
1889:FreeRTOS/Source/tasks.c **** 			else
1890:FreeRTOS/Source/tasks.c **** 			{
1891:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1892:FreeRTOS/Source/tasks.c **** 			}
1893:FreeRTOS/Source/tasks.c **** 		}
1894:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
1895:FreeRTOS/Source/tasks.c **** 
1896:FreeRTOS/Source/tasks.c **** 		return uxTask;
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 
1899:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1900:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1901:FreeRTOS/Source/tasks.c **** 
1902:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1905:FreeRTOS/Source/tasks.c **** 	{
1906:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1907:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1908:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1909:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1910:FreeRTOS/Source/tasks.c **** 	}
1911:FreeRTOS/Source/tasks.c **** 
1912:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1913:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1914:FreeRTOS/Source/tasks.c **** 
1915:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1916:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1917:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1918:FreeRTOS/Source/tasks.c **** 1. */
1919:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1920:FreeRTOS/Source/tasks.c **** 
1921:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1922:FreeRTOS/Source/tasks.c **** 	{
1923:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1924:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1925:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
1926:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1927:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1928:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1929:FreeRTOS/Source/tasks.c **** 	}
1930:FreeRTOS/Source/tasks.c **** 
1931:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1932:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1933:FreeRTOS/Source/tasks.c **** 
1934:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
1935:FreeRTOS/Source/tasks.c **** {
1936:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
1937:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
1938:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
1939:FreeRTOS/Source/tasks.c **** 
1940:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1941:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1942:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1943:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1944:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1945:FreeRTOS/Source/tasks.c **** 	{
1946:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1947:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
1948:FreeRTOS/Source/tasks.c **** 		++xTickCount;
1949:FreeRTOS/Source/tasks.c **** 
1950:FreeRTOS/Source/tasks.c **** 		{
1951:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1952:FreeRTOS/Source/tasks.c **** 			block. */
1953:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1954:FreeRTOS/Source/tasks.c **** 
1955:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
1956:FreeRTOS/Source/tasks.c **** 			{
1957:FreeRTOS/Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
1958:FreeRTOS/Source/tasks.c **** 			}
1959:FreeRTOS/Source/tasks.c **** 			else
1960:FreeRTOS/Source/tasks.c **** 			{
1961:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1962:FreeRTOS/Source/tasks.c **** 			}
1963:FreeRTOS/Source/tasks.c **** 
1964:FreeRTOS/Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1965:FreeRTOS/Source/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1966:FreeRTOS/Source/tasks.c **** 			has been found whose block time has not expired there is no need to
1967:FreeRTOS/Source/tasks.c **** 			look any further down the list. */
1968:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
1969:FreeRTOS/Source/tasks.c **** 			{
1970:FreeRTOS/Source/tasks.c **** 				for( ;; )
1971:FreeRTOS/Source/tasks.c **** 				{
1972:FreeRTOS/Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1973:FreeRTOS/Source/tasks.c **** 					{
1974:FreeRTOS/Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1975:FreeRTOS/Source/tasks.c **** 						to the maximum possible value so it is extremely
1976:FreeRTOS/Source/tasks.c **** 						unlikely that the
1977:FreeRTOS/Source/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1978:FreeRTOS/Source/tasks.c **** 						next time through. */
1979:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1980:FreeRTOS/Source/tasks.c **** 						break;
1981:FreeRTOS/Source/tasks.c **** 					}
1982:FreeRTOS/Source/tasks.c **** 					else
1983:FreeRTOS/Source/tasks.c **** 					{
1984:FreeRTOS/Source/tasks.c **** 						/* The delayed list is not empty, get the value of the
1985:FreeRTOS/Source/tasks.c **** 						item at the head of the delayed list.  This is the time
1986:FreeRTOS/Source/tasks.c **** 						at which the task at the head of the delayed list must
1987:FreeRTOS/Source/tasks.c **** 						be removed from the Blocked state. */
1988:FreeRTOS/Source/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1989:FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1990:FreeRTOS/Source/tasks.c **** 
1991:FreeRTOS/Source/tasks.c **** 						if( xConstTickCount < xItemValue )
1992:FreeRTOS/Source/tasks.c **** 						{
1993:FreeRTOS/Source/tasks.c **** 							/* It is not time to unblock this item yet, but the
1994:FreeRTOS/Source/tasks.c **** 							item value is the time at which the task at the head
1995:FreeRTOS/Source/tasks.c **** 							of the blocked list must be removed from the Blocked
1996:FreeRTOS/Source/tasks.c **** 							state -	so record the item value in
1997:FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime. */
1998:FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
1999:FreeRTOS/Source/tasks.c **** 							break;
2000:FreeRTOS/Source/tasks.c **** 						}
2001:FreeRTOS/Source/tasks.c **** 						else
2002:FreeRTOS/Source/tasks.c **** 						{
2003:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2004:FreeRTOS/Source/tasks.c **** 						}
2005:FreeRTOS/Source/tasks.c **** 
2006:FreeRTOS/Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
2007:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2008:FreeRTOS/Source/tasks.c **** 
2009:FreeRTOS/Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
2010:FreeRTOS/Source/tasks.c **** 						it from the event list. */
2011:FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2012:FreeRTOS/Source/tasks.c **** 						{
2013:FreeRTOS/Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2014:FreeRTOS/Source/tasks.c **** 						}
2015:FreeRTOS/Source/tasks.c **** 						else
2016:FreeRTOS/Source/tasks.c **** 						{
2017:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2018:FreeRTOS/Source/tasks.c **** 						}
2019:FreeRTOS/Source/tasks.c **** 
2020:FreeRTOS/Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
2021:FreeRTOS/Source/tasks.c **** 						list. */
2022:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
2023:FreeRTOS/Source/tasks.c **** 
2024:FreeRTOS/Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate
2025:FreeRTOS/Source/tasks.c **** 						context switch if preemption is turned off. */
2026:FreeRTOS/Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
2027:FreeRTOS/Source/tasks.c **** 						{
2028:FreeRTOS/Source/tasks.c **** 							/* Preemption is on, but a context switch should
2029:FreeRTOS/Source/tasks.c **** 							only be performed if the unblocked task has a
2030:FreeRTOS/Source/tasks.c **** 							priority that is equal to or higher than the
2031:FreeRTOS/Source/tasks.c **** 							currently executing task. */
2032:FreeRTOS/Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2033:FreeRTOS/Source/tasks.c **** 							{
2034:FreeRTOS/Source/tasks.c **** 								xSwitchRequired = pdTRUE;
2035:FreeRTOS/Source/tasks.c **** 							}
2036:FreeRTOS/Source/tasks.c **** 							else
2037:FreeRTOS/Source/tasks.c **** 							{
2038:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2039:FreeRTOS/Source/tasks.c **** 							}
2040:FreeRTOS/Source/tasks.c **** 						}
2041:FreeRTOS/Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
2042:FreeRTOS/Source/tasks.c **** 					}
2043:FreeRTOS/Source/tasks.c **** 				}
2044:FreeRTOS/Source/tasks.c **** 			}
2045:FreeRTOS/Source/tasks.c **** 		}
2046:FreeRTOS/Source/tasks.c **** 
2047:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2048:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2049:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2050:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2051:FreeRTOS/Source/tasks.c **** 		{
2052:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2053:FreeRTOS/Source/tasks.c **** 			{
2054:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2055:FreeRTOS/Source/tasks.c **** 			}
2056:FreeRTOS/Source/tasks.c **** 			else
2057:FreeRTOS/Source/tasks.c **** 			{
2058:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2059:FreeRTOS/Source/tasks.c **** 			}
2060:FreeRTOS/Source/tasks.c **** 		}
2061:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2064:FreeRTOS/Source/tasks.c **** 		{
2065:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2066:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2067:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2068:FreeRTOS/Source/tasks.c **** 			{
2069:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2070:FreeRTOS/Source/tasks.c **** 			}
2071:FreeRTOS/Source/tasks.c **** 			else
2072:FreeRTOS/Source/tasks.c **** 			{
2073:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2074:FreeRTOS/Source/tasks.c **** 			}
2075:FreeRTOS/Source/tasks.c **** 		}
2076:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2077:FreeRTOS/Source/tasks.c **** 	}
2078:FreeRTOS/Source/tasks.c **** 	else
2079:FreeRTOS/Source/tasks.c **** 	{
2080:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2081:FreeRTOS/Source/tasks.c **** 
2082:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2083:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2084:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2085:FreeRTOS/Source/tasks.c **** 		{
2086:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2087:FreeRTOS/Source/tasks.c **** 		}
2088:FreeRTOS/Source/tasks.c **** 		#endif
2089:FreeRTOS/Source/tasks.c **** 	}
2090:FreeRTOS/Source/tasks.c **** 
2091:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2092:FreeRTOS/Source/tasks.c **** 	{
2093:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2094:FreeRTOS/Source/tasks.c **** 		{
2095:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2096:FreeRTOS/Source/tasks.c **** 		}
2097:FreeRTOS/Source/tasks.c **** 		else
2098:FreeRTOS/Source/tasks.c **** 		{
2099:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2100:FreeRTOS/Source/tasks.c **** 		}
2101:FreeRTOS/Source/tasks.c **** 	}
2102:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2103:FreeRTOS/Source/tasks.c **** 
2104:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2105:FreeRTOS/Source/tasks.c **** }
2106:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2107:FreeRTOS/Source/tasks.c **** 
2108:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2109:FreeRTOS/Source/tasks.c **** 
2110:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2111:FreeRTOS/Source/tasks.c **** 	{
2112:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2113:FreeRTOS/Source/tasks.c **** 
2114:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2115:FreeRTOS/Source/tasks.c **** 		getting set. */
2116:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2117:FreeRTOS/Source/tasks.c **** 		{
2118:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2119:FreeRTOS/Source/tasks.c **** 		}
2120:FreeRTOS/Source/tasks.c **** 		else
2121:FreeRTOS/Source/tasks.c **** 		{
2122:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2123:FreeRTOS/Source/tasks.c **** 		}
2124:FreeRTOS/Source/tasks.c **** 
2125:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2126:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2127:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2128:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2129:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2130:FreeRTOS/Source/tasks.c **** 	}
2131:FreeRTOS/Source/tasks.c **** 
2132:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2133:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2134:FreeRTOS/Source/tasks.c **** 
2135:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2136:FreeRTOS/Source/tasks.c **** 
2137:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2138:FreeRTOS/Source/tasks.c **** 	{
2139:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2140:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2141:FreeRTOS/Source/tasks.c **** 
2142:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2143:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2144:FreeRTOS/Source/tasks.c **** 		{
2145:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2146:FreeRTOS/Source/tasks.c **** 		}
2147:FreeRTOS/Source/tasks.c **** 		else
2148:FreeRTOS/Source/tasks.c **** 		{
2149:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2150:FreeRTOS/Source/tasks.c **** 		}
2151:FreeRTOS/Source/tasks.c **** 
2152:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2153:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2154:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2155:FreeRTOS/Source/tasks.c **** 		{
2156:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2157:FreeRTOS/Source/tasks.c **** 		}
2158:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2159:FreeRTOS/Source/tasks.c **** 
2160:FreeRTOS/Source/tasks.c **** 		return xReturn;
2161:FreeRTOS/Source/tasks.c **** 	}
2162:FreeRTOS/Source/tasks.c **** 
2163:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2164:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2165:FreeRTOS/Source/tasks.c **** 
2166:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2169:FreeRTOS/Source/tasks.c **** 	{
2170:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2171:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2172:FreeRTOS/Source/tasks.c **** 
2173:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2174:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2175:FreeRTOS/Source/tasks.c **** 		{
2176:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2177:FreeRTOS/Source/tasks.c **** 		}
2178:FreeRTOS/Source/tasks.c **** 		else
2179:FreeRTOS/Source/tasks.c **** 		{
2180:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2181:FreeRTOS/Source/tasks.c **** 		}
2182:FreeRTOS/Source/tasks.c **** 
2183:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2184:FreeRTOS/Source/tasks.c **** 		{
2185:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2186:FreeRTOS/Source/tasks.c **** 		}
2187:FreeRTOS/Source/tasks.c **** 		else
2188:FreeRTOS/Source/tasks.c **** 		{
2189:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2190:FreeRTOS/Source/tasks.c **** 		}
2191:FreeRTOS/Source/tasks.c **** 
2192:FreeRTOS/Source/tasks.c **** 		return xReturn;
2193:FreeRTOS/Source/tasks.c **** 	}
2194:FreeRTOS/Source/tasks.c **** 
2195:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2196:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2197:FreeRTOS/Source/tasks.c **** 
2198:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2199:FreeRTOS/Source/tasks.c **** {
2200:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2201:FreeRTOS/Source/tasks.c **** 	{
2202:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2203:FreeRTOS/Source/tasks.c **** 		switch. */
2204:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2205:FreeRTOS/Source/tasks.c **** 	}
2206:FreeRTOS/Source/tasks.c **** 	else
2207:FreeRTOS/Source/tasks.c **** 	{
2208:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2209:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2210:FreeRTOS/Source/tasks.c **** 
2211:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2212:FreeRTOS/Source/tasks.c **** 		{
2213:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2214:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2215:FreeRTOS/Source/tasks.c **** 				#else
2216:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2217:FreeRTOS/Source/tasks.c **** 				#endif
2218:FreeRTOS/Source/tasks.c **** 
2219:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2220:FreeRTOS/Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
2221:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2222:FreeRTOS/Source/tasks.c **** 				protection here	so count values are only valid until the timer
2223:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2224:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2225:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2226:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2227:FreeRTOS/Source/tasks.c **** 				{
2228:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2229:FreeRTOS/Source/tasks.c **** 				}
2230:FreeRTOS/Source/tasks.c **** 				else
2231:FreeRTOS/Source/tasks.c **** 				{
2232:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2233:FreeRTOS/Source/tasks.c **** 				}
2234:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2235:FreeRTOS/Source/tasks.c **** 		}
2236:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2237:FreeRTOS/Source/tasks.c **** 
2238:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2239:FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
2240:FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2241:FreeRTOS/Source/tasks.c **** 
2242:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2243:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
2245:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2246:FreeRTOS/Source/tasks.c **** 
2247:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2248:FreeRTOS/Source/tasks.c **** 		{
2249:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2250:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2251:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2252:FreeRTOS/Source/tasks.c **** 		}
2253:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2254:FreeRTOS/Source/tasks.c **** 	}
2255:FreeRTOS/Source/tasks.c **** }
2256:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2257:FreeRTOS/Source/tasks.c **** 
2258:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2259:FreeRTOS/Source/tasks.c **** {
2260:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2261:FreeRTOS/Source/tasks.c **** 
2262:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2263:FreeRTOS/Source/tasks.c **** 
2264:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2265:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2266:FreeRTOS/Source/tasks.c **** 
2267:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2268:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2269:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2270:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2271:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2272:FreeRTOS/Source/tasks.c **** 
2273:FreeRTOS/Source/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2274:FreeRTOS/Source/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2275:FreeRTOS/Source/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2276:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2277:FreeRTOS/Source/tasks.c **** 	{
2278:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2279:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2280:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2281:FreeRTOS/Source/tasks.c **** 	}
2282:FreeRTOS/Source/tasks.c **** 	else
2283:FreeRTOS/Source/tasks.c **** 	{
2284:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2285:FreeRTOS/Source/tasks.c **** 	}
2286:FreeRTOS/Source/tasks.c **** 
2287:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2288:FreeRTOS/Source/tasks.c **** 	{
2289:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2290:FreeRTOS/Source/tasks.c **** 		{
2291:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2292:FreeRTOS/Source/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2293:FreeRTOS/Source/tasks.c **** 			block indefinitely. */
2294:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2295:FreeRTOS/Source/tasks.c **** 		}
2296:FreeRTOS/Source/tasks.c **** 		else
2297:FreeRTOS/Source/tasks.c **** 		{
2298:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2299:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2300:FreeRTOS/Source/tasks.c **** 			scheduler will handle it. */
2301:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2302:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2303:FreeRTOS/Source/tasks.c **** 		}
2304:FreeRTOS/Source/tasks.c **** 	}
2305:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2306:FreeRTOS/Source/tasks.c **** 	{
2307:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2308:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2309:FreeRTOS/Source/tasks.c **** 			will handle it. */
2310:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2311:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2312:FreeRTOS/Source/tasks.c **** 	}
2313:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2314:FreeRTOS/Source/tasks.c **** }
2315:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2316:FreeRTOS/Source/tasks.c **** 
2317:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2318:FreeRTOS/Source/tasks.c **** {
2319:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2320:FreeRTOS/Source/tasks.c **** 
2321:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2322:FreeRTOS/Source/tasks.c **** 
2323:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2324:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2325:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2326:FreeRTOS/Source/tasks.c **** 
2327:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2328:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2329:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
2330:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
2331:FreeRTOS/Source/tasks.c **** 
2332:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2333:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2334:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2335:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2336:FreeRTOS/Source/tasks.c **** 	the task level). */
2337:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2338:FreeRTOS/Source/tasks.c **** 
2339:FreeRTOS/Source/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2340:FreeRTOS/Source/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2341:FreeRTOS/Source/tasks.c **** 	scheduler is locked. */
2342:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2343:FreeRTOS/Source/tasks.c **** 	{
2344:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2345:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2346:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2347:FreeRTOS/Source/tasks.c **** 	}
2348:FreeRTOS/Source/tasks.c **** 	else
2349:FreeRTOS/Source/tasks.c **** 	{
2350:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2351:FreeRTOS/Source/tasks.c **** 	}
2352:FreeRTOS/Source/tasks.c **** 
2353:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2354:FreeRTOS/Source/tasks.c **** 	{
2355:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2356:FreeRTOS/Source/tasks.c **** 		{
2357:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2358:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2359:FreeRTOS/Source/tasks.c **** 			indefinitely. */
2360:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2361:FreeRTOS/Source/tasks.c **** 		}
2362:FreeRTOS/Source/tasks.c **** 		else
2363:FreeRTOS/Source/tasks.c **** 		{
2364:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2365:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2366:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
2367:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2368:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2369:FreeRTOS/Source/tasks.c **** 		}
2370:FreeRTOS/Source/tasks.c **** 	}
2371:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2372:FreeRTOS/Source/tasks.c **** 	{
2373:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2374:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2375:FreeRTOS/Source/tasks.c **** 			will manage it correctly. */
2376:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2377:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2378:FreeRTOS/Source/tasks.c **** 	}
2379:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2380:FreeRTOS/Source/tasks.c **** }
2381:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2382:FreeRTOS/Source/tasks.c **** 
2383:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
2386:FreeRTOS/Source/tasks.c **** 	{
2387:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
2390:FreeRTOS/Source/tasks.c **** 
2391:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
2392:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2393:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2394:FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 
2397:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2398:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2399:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2400:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
2401:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2402:FreeRTOS/Source/tasks.c **** 
2403:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2404:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2405:FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
2406:FreeRTOS/Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2407:FreeRTOS/Source/tasks.c **** 		{
2408:FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2409:FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
2410:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2411:FreeRTOS/Source/tasks.c **** 		}
2412:FreeRTOS/Source/tasks.c **** 		else
2413:FreeRTOS/Source/tasks.c **** 		{
2414:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2415:FreeRTOS/Source/tasks.c **** 		}
2416:FreeRTOS/Source/tasks.c **** 
2417:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
2418:FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
2419:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
2420:FreeRTOS/Source/tasks.c **** 
2421:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
2422:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
2423:FreeRTOS/Source/tasks.c **** 	}
2424:FreeRTOS/Source/tasks.c **** 
2425:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
2426:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2427:FreeRTOS/Source/tasks.c **** 
2428:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2429:FreeRTOS/Source/tasks.c **** {
2430:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2431:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2432:FreeRTOS/Source/tasks.c **** 
2433:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2434:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
2435:FreeRTOS/Source/tasks.c **** 
2436:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2437:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2438:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
2439:FreeRTOS/Source/tasks.c **** 
2440:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2441:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2442:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2443:FreeRTOS/Source/tasks.c **** 
2444:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2445:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
2446:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
2447:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2448:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
2449:FreeRTOS/Source/tasks.c **** 
2450:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2451:FreeRTOS/Source/tasks.c **** 	{
2452:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2453:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
2454:FreeRTOS/Source/tasks.c **** 	}
2455:FreeRTOS/Source/tasks.c **** 	else
2456:FreeRTOS/Source/tasks.c **** 	{
2457:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2458:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
2459:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
2460:FreeRTOS/Source/tasks.c **** 	}
2461:FreeRTOS/Source/tasks.c **** 
2462:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2463:FreeRTOS/Source/tasks.c **** 	{
2464:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2465:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2466:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
2467:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2468:FreeRTOS/Source/tasks.c **** 
2469:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2470:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2471:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2472:FreeRTOS/Source/tasks.c **** 	}
2473:FreeRTOS/Source/tasks.c **** 	else
2474:FreeRTOS/Source/tasks.c **** 	{
2475:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2476:FreeRTOS/Source/tasks.c **** 	}
2477:FreeRTOS/Source/tasks.c **** 
2478:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE == 1 )
2479:FreeRTOS/Source/tasks.c **** 	{
2480:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2481:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2482:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2483:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically get reset to a new
2484:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2485:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2486:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2487:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
2488:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
2489:FreeRTOS/Source/tasks.c **** 	}
2490:FreeRTOS/Source/tasks.c **** 	#endif
2491:FreeRTOS/Source/tasks.c **** 
2492:FreeRTOS/Source/tasks.c **** 	return xReturn;
2493:FreeRTOS/Source/tasks.c **** }
2494:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2495:FreeRTOS/Source/tasks.c **** 
2496:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2497:FreeRTOS/Source/tasks.c **** {
2498:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2499:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2500:FreeRTOS/Source/tasks.c **** 
2501:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2502:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
2503:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2504:FreeRTOS/Source/tasks.c **** 
2505:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
2506:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
2507:FreeRTOS/Source/tasks.c **** 
2508:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2509:FreeRTOS/Source/tasks.c **** 	event flags. */
2510:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
2511:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2512:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
2513:FreeRTOS/Source/tasks.c **** 
2514:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2515:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2516:FreeRTOS/Source/tasks.c **** 	lists. */
2517:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2518:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
2519:FreeRTOS/Source/tasks.c **** 
2520:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2521:FreeRTOS/Source/tasks.c **** 	{
2522:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
2523:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
2524:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
2525:FreeRTOS/Source/tasks.c **** 		switch now. */
2526:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2529:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2530:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2531:FreeRTOS/Source/tasks.c **** 	}
2532:FreeRTOS/Source/tasks.c **** 	else
2533:FreeRTOS/Source/tasks.c **** 	{
2534:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2535:FreeRTOS/Source/tasks.c **** 	}
2536:FreeRTOS/Source/tasks.c **** 
2537:FreeRTOS/Source/tasks.c **** 	return xReturn;
2538:FreeRTOS/Source/tasks.c **** }
2539:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2540:FreeRTOS/Source/tasks.c **** 
2541:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2542:FreeRTOS/Source/tasks.c **** {
2543:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2544:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
2545:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
2546:FreeRTOS/Source/tasks.c **** }
2547:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2548:FreeRTOS/Source/tasks.c **** 
2549:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2550:FreeRTOS/Source/tasks.c **** {
2551:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2552:FreeRTOS/Source/tasks.c **** 
2553:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2554:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
2555:FreeRTOS/Source/tasks.c **** 
2556:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2557:FreeRTOS/Source/tasks.c **** 	{
2558:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2559:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
2560:FreeRTOS/Source/tasks.c **** 
2561:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2562:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2563:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2564:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2565:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2566:FreeRTOS/Source/tasks.c **** 			{
2567:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
2568:FreeRTOS/Source/tasks.c **** 			}
2569:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2570:FreeRTOS/Source/tasks.c **** 		#endif
2571:FreeRTOS/Source/tasks.c **** 
2572:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
2573:FreeRTOS/Source/tasks.c **** 		{
2574:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2575:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2576:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2577:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2578:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2579:FreeRTOS/Source/tasks.c **** 		}
2580:FreeRTOS/Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
2581:FreeRTOS/Source/tasks.c **** 		{
2582:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2583:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
2584:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2585:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
2586:FreeRTOS/Source/tasks.c **** 		}
2587:FreeRTOS/Source/tasks.c **** 		else
2588:FreeRTOS/Source/tasks.c **** 		{
2589:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2590:FreeRTOS/Source/tasks.c **** 		}
2591:FreeRTOS/Source/tasks.c **** 	}
2592:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2593:FreeRTOS/Source/tasks.c **** 
2594:FreeRTOS/Source/tasks.c **** 	return xReturn;
2595:FreeRTOS/Source/tasks.c **** }
2596:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2597:FreeRTOS/Source/tasks.c **** 
2598:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2599:FreeRTOS/Source/tasks.c **** {
2600:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
2601:FreeRTOS/Source/tasks.c **** }
2602:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2603:FreeRTOS/Source/tasks.c **** 
2604:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2605:FreeRTOS/Source/tasks.c **** 
2606:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2607:FreeRTOS/Source/tasks.c **** 	{
2608:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
2609:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2610:FreeRTOS/Source/tasks.c **** 
2611:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2612:FreeRTOS/Source/tasks.c **** 		{
2613:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2614:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2615:FreeRTOS/Source/tasks.c **** 		}
2616:FreeRTOS/Source/tasks.c **** 		else
2617:FreeRTOS/Source/tasks.c **** 		{
2618:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
2619:FreeRTOS/Source/tasks.c **** 		}
2620:FreeRTOS/Source/tasks.c **** 
2621:FreeRTOS/Source/tasks.c **** 		return uxReturn;
2622:FreeRTOS/Source/tasks.c **** 	}
2623:FreeRTOS/Source/tasks.c **** 
2624:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2625:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2626:FreeRTOS/Source/tasks.c **** 
2627:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2628:FreeRTOS/Source/tasks.c **** 
2629:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2630:FreeRTOS/Source/tasks.c **** 	{
2631:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2632:FreeRTOS/Source/tasks.c **** 
2633:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2634:FreeRTOS/Source/tasks.c **** 		{
2635:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2636:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2637:FreeRTOS/Source/tasks.c **** 		}
2638:FreeRTOS/Source/tasks.c **** 	}
2639:FreeRTOS/Source/tasks.c **** 
2640:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2641:FreeRTOS/Source/tasks.c **** 
2642:FreeRTOS/Source/tasks.c **** /*
2643:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2644:FreeRTOS/Source/tasks.c ****  * The Idle task.
2645:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2646:FreeRTOS/Source/tasks.c ****  *
2647:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2648:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2649:FreeRTOS/Source/tasks.c ****  *
2650:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2651:FreeRTOS/Source/tasks.c ****  *
2652:FreeRTOS/Source/tasks.c ****  */
2653:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2654:FreeRTOS/Source/tasks.c **** {
2655:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2656:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2657:FreeRTOS/Source/tasks.c **** 
2658:FreeRTOS/Source/tasks.c **** 	for( ;; )
2659:FreeRTOS/Source/tasks.c **** 	{
2660:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2661:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
2662:FreeRTOS/Source/tasks.c **** 
2663:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2664:FreeRTOS/Source/tasks.c **** 		{
2665:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2666:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2667:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2668:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2669:FreeRTOS/Source/tasks.c **** 			taskYIELD();
2670:FreeRTOS/Source/tasks.c **** 		}
2671:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2672:FreeRTOS/Source/tasks.c **** 
2673:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2674:FreeRTOS/Source/tasks.c **** 		{
2675:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2676:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2677:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2678:FreeRTOS/Source/tasks.c **** 			timeslice.
2679:FreeRTOS/Source/tasks.c **** 
2680:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2681:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2682:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2683:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2684:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
2685:FreeRTOS/Source/tasks.c **** 			{
2686:FreeRTOS/Source/tasks.c **** 				taskYIELD();
2687:FreeRTOS/Source/tasks.c **** 			}
2688:FreeRTOS/Source/tasks.c **** 			else
2689:FreeRTOS/Source/tasks.c **** 			{
2690:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2691:FreeRTOS/Source/tasks.c **** 			}
2692:FreeRTOS/Source/tasks.c **** 		}
2693:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2694:FreeRTOS/Source/tasks.c **** 
2695:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2696:FreeRTOS/Source/tasks.c **** 		{
2697:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2698:FreeRTOS/Source/tasks.c **** 
2699:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2700:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2701:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2702:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2703:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2704:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
2705:FreeRTOS/Source/tasks.c **** 		}
2706:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2707:FreeRTOS/Source/tasks.c **** 
2708:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2709:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2710:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2711:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2712:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2713:FreeRTOS/Source/tasks.c **** 		{
2714:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
2715:FreeRTOS/Source/tasks.c **** 
2716:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2717:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2718:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2719:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2720:FreeRTOS/Source/tasks.c **** 			valid. */
2721:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2722:FreeRTOS/Source/tasks.c **** 
2723:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2724:FreeRTOS/Source/tasks.c **** 			{
2725:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2726:FreeRTOS/Source/tasks.c **** 				{
2727:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2728:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2729:FreeRTOS/Source/tasks.c **** 					be used. */
2730:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2731:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2732:FreeRTOS/Source/tasks.c **** 
2733:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2734:FreeRTOS/Source/tasks.c **** 					{
2735:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2736:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2737:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2738:FreeRTOS/Source/tasks.c **** 					}
2739:FreeRTOS/Source/tasks.c **** 					else
2740:FreeRTOS/Source/tasks.c **** 					{
2741:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2742:FreeRTOS/Source/tasks.c **** 					}
2743:FreeRTOS/Source/tasks.c **** 				}
2744:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
2745:FreeRTOS/Source/tasks.c **** 			}
2746:FreeRTOS/Source/tasks.c **** 			else
2747:FreeRTOS/Source/tasks.c **** 			{
2748:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2749:FreeRTOS/Source/tasks.c **** 			}
2750:FreeRTOS/Source/tasks.c **** 		}
2751:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2752:FreeRTOS/Source/tasks.c **** 	}
2753:FreeRTOS/Source/tasks.c **** }
2754:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2755:FreeRTOS/Source/tasks.c **** 
2756:FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2757:FreeRTOS/Source/tasks.c **** 
2758:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2759:FreeRTOS/Source/tasks.c **** 	{
2760:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2761:FreeRTOS/Source/tasks.c **** 
2762:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2763:FreeRTOS/Source/tasks.c **** 		{
2764:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2765:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2766:FreeRTOS/Source/tasks.c **** 		}
2767:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2768:FreeRTOS/Source/tasks.c **** 		{
2769:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2770:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2771:FreeRTOS/Source/tasks.c **** 		}
2772:FreeRTOS/Source/tasks.c **** 		else
2773:FreeRTOS/Source/tasks.c **** 		{
2774:FreeRTOS/Source/tasks.c **** 			#if configUSE_TIMERS == 0
2775:FreeRTOS/Source/tasks.c **** 			{
2776:FreeRTOS/Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2777:FreeRTOS/Source/tasks.c **** 				const UBaseType_t uxNonApplicationTasks = 1;
2778:FreeRTOS/Source/tasks.c **** 
2779:FreeRTOS/Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2780:FreeRTOS/Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2781:FreeRTOS/Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2782:FreeRTOS/Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2783:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2784:FreeRTOS/Source/tasks.c **** 				{
2785:FreeRTOS/Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2786:FreeRTOS/Source/tasks.c **** 				}
2787:FreeRTOS/Source/tasks.c **** 				else
2788:FreeRTOS/Source/tasks.c **** 				{
2789:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2790:FreeRTOS/Source/tasks.c **** 				}
2791:FreeRTOS/Source/tasks.c **** 			}
2792:FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2793:FreeRTOS/Source/tasks.c **** 		}
2794:FreeRTOS/Source/tasks.c **** 
2795:FreeRTOS/Source/tasks.c **** 		return eReturn;
2796:FreeRTOS/Source/tasks.c **** 	}
2797:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2798:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2799:FreeRTOS/Source/tasks.c **** 
2800:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2801:FreeRTOS/Source/tasks.c **** {
2802:FreeRTOS/Source/tasks.c **** UBaseType_t x;
2803:FreeRTOS/Source/tasks.c **** 
2804:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
2805:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2806:FreeRTOS/Source/tasks.c **** 	{
2807:FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
2808:FreeRTOS/Source/tasks.c **** 
2809:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2810:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2811:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2812:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
2813:FreeRTOS/Source/tasks.c **** 		{
2814:FreeRTOS/Source/tasks.c **** 			break;
2815:FreeRTOS/Source/tasks.c **** 		}
2816:FreeRTOS/Source/tasks.c **** 		else
2817:FreeRTOS/Source/tasks.c **** 		{
2818:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2819:FreeRTOS/Source/tasks.c **** 		}
2820:FreeRTOS/Source/tasks.c **** 	}
2821:FreeRTOS/Source/tasks.c **** 
2822:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2823:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2824:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
2825:FreeRTOS/Source/tasks.c **** 
2826:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2827:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2828:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
2829:FreeRTOS/Source/tasks.c **** 	{
2830:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
2831:FreeRTOS/Source/tasks.c **** 	}
2832:FreeRTOS/Source/tasks.c **** 	else
2833:FreeRTOS/Source/tasks.c **** 	{
2834:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2835:FreeRTOS/Source/tasks.c **** 	}
2836:FreeRTOS/Source/tasks.c **** 
2837:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2838:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2839:FreeRTOS/Source/tasks.c **** 	{
2840:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2841:FreeRTOS/Source/tasks.c **** 		pxTCB->uxMutexesHeld = 0;
2842:FreeRTOS/Source/tasks.c **** 	}
2843:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2844:FreeRTOS/Source/tasks.c **** 
2845:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2846:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2847:FreeRTOS/Source/tasks.c **** 
2848:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2849:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2850:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2851:FreeRTOS/Source/tasks.c **** 
2852:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2853:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
2854:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2855:FreeRTOS/Source/tasks.c **** 
2856:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2857:FreeRTOS/Source/tasks.c **** 	{
2858:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2859:FreeRTOS/Source/tasks.c **** 	}
2860:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2861:FreeRTOS/Source/tasks.c **** 
2862:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2863:FreeRTOS/Source/tasks.c **** 	{
2864:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2865:FreeRTOS/Source/tasks.c **** 	}
2866:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2867:FreeRTOS/Source/tasks.c **** 
2868:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2869:FreeRTOS/Source/tasks.c **** 	{
2870:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2871:FreeRTOS/Source/tasks.c **** 	}
2872:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2873:FreeRTOS/Source/tasks.c **** 
2874:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2875:FreeRTOS/Source/tasks.c **** 	{
2876:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2877:FreeRTOS/Source/tasks.c **** 	}
2878:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2879:FreeRTOS/Source/tasks.c **** 	{
2880:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2881:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2882:FreeRTOS/Source/tasks.c **** 	}
2883:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
2886:FreeRTOS/Source/tasks.c **** 	{
2887:FreeRTOS/Source/tasks.c **** 		pxTCB->ulNotifiedValue = 0;
2888:FreeRTOS/Source/tasks.c **** 		pxTCB->eNotifyState = eNotWaitingNotification;
2889:FreeRTOS/Source/tasks.c **** 	}
2890:FreeRTOS/Source/tasks.c **** 	#endif
2891:FreeRTOS/Source/tasks.c **** 
2892:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2893:FreeRTOS/Source/tasks.c **** 	{
2894:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2895:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2896:FreeRTOS/Source/tasks.c **** 	}
2897:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2898:FreeRTOS/Source/tasks.c **** }
2899:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2900:FreeRTOS/Source/tasks.c **** 
2901:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2902:FreeRTOS/Source/tasks.c **** 
2903:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2904:FreeRTOS/Source/tasks.c **** 	{
2905:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2906:FreeRTOS/Source/tasks.c **** 
2907:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2908:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2909:FreeRTOS/Source/tasks.c **** 
2910:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2911:FreeRTOS/Source/tasks.c **** 	}
2912:FreeRTOS/Source/tasks.c **** 
2913:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2914:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2915:FreeRTOS/Source/tasks.c **** 
2916:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2917:FreeRTOS/Source/tasks.c **** {
2918:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
2919:FreeRTOS/Source/tasks.c **** 
2920:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
2921:FreeRTOS/Source/tasks.c **** 	{
2922:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
2923:FreeRTOS/Source/tasks.c **** 	}
2924:FreeRTOS/Source/tasks.c **** 
2925:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
2926:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
2927:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
2928:FreeRTOS/Source/tasks.c **** 
2929:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2930:FreeRTOS/Source/tasks.c **** 	{
2931:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
2932:FreeRTOS/Source/tasks.c **** 	}
2933:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2934:FreeRTOS/Source/tasks.c **** 
2935:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2936:FreeRTOS/Source/tasks.c **** 	{
2937:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
2938:FreeRTOS/Source/tasks.c **** 	}
2939:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2940:FreeRTOS/Source/tasks.c **** 
2941:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2942:FreeRTOS/Source/tasks.c **** 	using list2. */
2943:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2944:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2945:FreeRTOS/Source/tasks.c **** }
2946:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2947:FreeRTOS/Source/tasks.c **** 
2948:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2949:FreeRTOS/Source/tasks.c **** {
2950:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2951:FreeRTOS/Source/tasks.c **** 	{
2952:FreeRTOS/Source/tasks.c **** 		BaseType_t xListIsEmpty;
2953:FreeRTOS/Source/tasks.c **** 
2954:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2955:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2956:FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
2957:FreeRTOS/Source/tasks.c **** 		{
2958:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2959:FreeRTOS/Source/tasks.c **** 			{
2960:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2961:FreeRTOS/Source/tasks.c **** 			}
2962:FreeRTOS/Source/tasks.c **** 			( void ) xTaskResumeAll();
2963:FreeRTOS/Source/tasks.c **** 
2964:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2965:FreeRTOS/Source/tasks.c **** 			{
2966:FreeRTOS/Source/tasks.c **** 				TCB_t *pxTCB;
2967:FreeRTOS/Source/tasks.c **** 
2968:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2969:FreeRTOS/Source/tasks.c **** 				{
2970:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2971:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2972:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2973:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2974:FreeRTOS/Source/tasks.c **** 				}
2975:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2976:FreeRTOS/Source/tasks.c **** 
2977:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2978:FreeRTOS/Source/tasks.c **** 			}
2979:FreeRTOS/Source/tasks.c **** 			else
2980:FreeRTOS/Source/tasks.c **** 			{
2981:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2982:FreeRTOS/Source/tasks.c **** 			}
2983:FreeRTOS/Source/tasks.c **** 		}
2984:FreeRTOS/Source/tasks.c **** 	}
2985:FreeRTOS/Source/tasks.c **** 	#endif /* vTaskDelete */
2986:FreeRTOS/Source/tasks.c **** }
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2988:FreeRTOS/Source/tasks.c **** 
2989:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2990:FreeRTOS/Source/tasks.c **** {
2991:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2992:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
2993:FreeRTOS/Source/tasks.c **** 
2994:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
2995:FreeRTOS/Source/tasks.c **** 	{
2996:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2997:FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2998:FreeRTOS/Source/tasks.c **** 	}
2999:FreeRTOS/Source/tasks.c **** 	else
3000:FreeRTOS/Source/tasks.c **** 	{
3001:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
3002:FreeRTOS/Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3003:FreeRTOS/Source/tasks.c **** 
3004:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
3005:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
3006:FreeRTOS/Source/tasks.c **** 		too. */
3007:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
3008:FreeRTOS/Source/tasks.c **** 		{
3009:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
3010:FreeRTOS/Source/tasks.c **** 		}
3011:FreeRTOS/Source/tasks.c **** 		else
3012:FreeRTOS/Source/tasks.c **** 		{
3013:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3014:FreeRTOS/Source/tasks.c **** 		}
3015:FreeRTOS/Source/tasks.c **** 	}
3016:FreeRTOS/Source/tasks.c **** }
3017:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3018:FreeRTOS/Source/tasks.c **** 
3019:FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
3020:FreeRTOS/Source/tasks.c **** {
3021:FreeRTOS/Source/tasks.c **** TCB_t *pxNewTCB;
3022:FreeRTOS/Source/tasks.c **** 
3023:FreeRTOS/Source/tasks.c **** 	/* If the stack grows down then allocate the stack then the TCB so the stack
3024:FreeRTOS/Source/tasks.c **** 	does not grow into the TCB.  Likewise if the stack grows up then allocate
3025:FreeRTOS/Source/tasks.c **** 	the TCB then the stack. */
3026:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH > 0 )
3027:FreeRTOS/Source/tasks.c **** 	{
3028:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the TCB.  Where the memory comes from depends on
3029:FreeRTOS/Source/tasks.c **** 		the implementation of the port malloc function. */
3030:FreeRTOS/Source/tasks.c **** 		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
3033:FreeRTOS/Source/tasks.c **** 		{
3034:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created.
3035:FreeRTOS/Source/tasks.c **** 			The base of the stack memory stored in the TCB so the task can
3036:FreeRTOS/Source/tasks.c **** 			be deleted later if required. */
3037:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeo
3038:FreeRTOS/Source/tasks.c **** 
3039:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->pxStack == NULL )
3040:FreeRTOS/Source/tasks.c **** 			{
3041:FreeRTOS/Source/tasks.c **** 				/* Could not allocate the stack.  Delete the allocated TCB. */
3042:FreeRTOS/Source/tasks.c **** 				vPortFree( pxNewTCB );
3043:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
3044:FreeRTOS/Source/tasks.c **** 			}
3045:FreeRTOS/Source/tasks.c **** 		}
3046:FreeRTOS/Source/tasks.c **** 	}
3047:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
3048:FreeRTOS/Source/tasks.c **** 	{
3049:FreeRTOS/Source/tasks.c **** 	StackType_t *pxStack;
3050:FreeRTOS/Source/tasks.c **** 
3051:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created. */
3052:FreeRTOS/Source/tasks.c **** 		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackTyp
3053:FreeRTOS/Source/tasks.c **** 
3054:FreeRTOS/Source/tasks.c **** 		if( pxStack != NULL )
3055:FreeRTOS/Source/tasks.c **** 		{
3056:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
3057:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function. */
3058:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3059:FreeRTOS/Source/tasks.c **** 
3060:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
3061:FreeRTOS/Source/tasks.c **** 			{
3062:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
3063:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxStack;
3064:FreeRTOS/Source/tasks.c **** 			}
3065:FreeRTOS/Source/tasks.c **** 			else
3066:FreeRTOS/Source/tasks.c **** 			{
3067:FreeRTOS/Source/tasks.c **** 				/* The stack cannot be used as the TCB was not created.  Free it
3068:FreeRTOS/Source/tasks.c **** 				again. */
3069:FreeRTOS/Source/tasks.c **** 				vPortFree( pxStack );
3070:FreeRTOS/Source/tasks.c **** 			}
3071:FreeRTOS/Source/tasks.c **** 		}
3072:FreeRTOS/Source/tasks.c **** 		else
3073:FreeRTOS/Source/tasks.c **** 		{
3074:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
3075:FreeRTOS/Source/tasks.c **** 		}
3076:FreeRTOS/Source/tasks.c **** 	}
3077:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
3078:FreeRTOS/Source/tasks.c **** 
3079:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
3080:FreeRTOS/Source/tasks.c **** 	{
3081:FreeRTOS/Source/tasks.c **** 		/* Avoid dependency on memset() if it is not required. */
3082:FreeRTOS/Source/tasks.c **** 		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxT
3083:FreeRTOS/Source/tasks.c **** 		{
3084:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
3085:FreeRTOS/Source/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
3086:FreeRTOS/Source/tasks.c **** 		}
3087:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( IN
3088:FreeRTOS/Source/tasks.c **** 	}
3089:FreeRTOS/Source/tasks.c **** 
3090:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
3091:FreeRTOS/Source/tasks.c **** }
3092:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3093:FreeRTOS/Source/tasks.c **** 
3094:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3095:FreeRTOS/Source/tasks.c **** 
3096:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
3097:FreeRTOS/Source/tasks.c **** 	{
3098:FreeRTOS/Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3099:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3100:FreeRTOS/Source/tasks.c **** 
3101:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3102:FreeRTOS/Source/tasks.c **** 		{
3103:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3104:FreeRTOS/Source/tasks.c **** 
3105:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3106:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3107:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3108:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3109:FreeRTOS/Source/tasks.c **** 			do
3110:FreeRTOS/Source/tasks.c **** 			{
3111:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3112:FreeRTOS/Source/tasks.c **** 
3113:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
3114:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
3115:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
3116:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
3117:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
3118:FreeRTOS/Source/tasks.c **** 
3119:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3120:FreeRTOS/Source/tasks.c **** 				{
3121:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a chance
3122:FreeRTOS/Source/tasks.c **** 					it is actually just blocked indefinitely - so really it should
3123:FreeRTOS/Source/tasks.c **** 					be reported as being in the Blocked state. */
3124:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3125:FreeRTOS/Source/tasks.c **** 					{
3126:FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
3127:FreeRTOS/Source/tasks.c **** 						{
3128:FreeRTOS/Source/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
3129:FreeRTOS/Source/tasks.c **** 						}
3130:FreeRTOS/Source/tasks.c **** 					}
3131:FreeRTOS/Source/tasks.c **** 				}
3132:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3133:FreeRTOS/Source/tasks.c **** 
3134:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
3135:FreeRTOS/Source/tasks.c **** 				{
3136:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
3137:FreeRTOS/Source/tasks.c **** 				}
3138:FreeRTOS/Source/tasks.c **** 				#else
3139:FreeRTOS/Source/tasks.c **** 				{
3140:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
3141:FreeRTOS/Source/tasks.c **** 				}
3142:FreeRTOS/Source/tasks.c **** 				#endif
3143:FreeRTOS/Source/tasks.c **** 
3144:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3145:FreeRTOS/Source/tasks.c **** 				{
3146:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3147:FreeRTOS/Source/tasks.c **** 				}
3148:FreeRTOS/Source/tasks.c **** 				#else
3149:FreeRTOS/Source/tasks.c **** 				{
3150:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3151:FreeRTOS/Source/tasks.c **** 				}
3152:FreeRTOS/Source/tasks.c **** 				#endif
3153:FreeRTOS/Source/tasks.c **** 
3154:FreeRTOS/Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3155:FreeRTOS/Source/tasks.c **** 				{
3156:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3157:FreeRTOS/Source/tasks.c **** 				}
3158:FreeRTOS/Source/tasks.c **** 				#else
3159:FreeRTOS/Source/tasks.c **** 				{
3160:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3161:FreeRTOS/Source/tasks.c **** 				}
3162:FreeRTOS/Source/tasks.c **** 				#endif
3163:FreeRTOS/Source/tasks.c **** 
3164:FreeRTOS/Source/tasks.c **** 				uxTask++;
3165:FreeRTOS/Source/tasks.c **** 
3166:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3167:FreeRTOS/Source/tasks.c **** 		}
3168:FreeRTOS/Source/tasks.c **** 		else
3169:FreeRTOS/Source/tasks.c **** 		{
3170:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3171:FreeRTOS/Source/tasks.c **** 		}
3172:FreeRTOS/Source/tasks.c **** 
3173:FreeRTOS/Source/tasks.c **** 		return uxTask;
3174:FreeRTOS/Source/tasks.c **** 	}
3175:FreeRTOS/Source/tasks.c **** 
3176:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3177:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3178:FreeRTOS/Source/tasks.c **** 
3179:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3180:FreeRTOS/Source/tasks.c **** 
3181:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3182:FreeRTOS/Source/tasks.c **** 	{
3183:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3184:FreeRTOS/Source/tasks.c **** 
3185:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3186:FreeRTOS/Source/tasks.c **** 		{
3187:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3188:FreeRTOS/Source/tasks.c **** 			ulCount++;
3189:FreeRTOS/Source/tasks.c **** 		}
3190:FreeRTOS/Source/tasks.c **** 
3191:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		return ( uint16_t ) ulCount;
3194:FreeRTOS/Source/tasks.c **** 	}
3195:FreeRTOS/Source/tasks.c **** 
3196:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3197:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3198:FreeRTOS/Source/tasks.c **** 
3199:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3200:FreeRTOS/Source/tasks.c **** 
3201:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3202:FreeRTOS/Source/tasks.c **** 	{
3203:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3204:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3205:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3206:FreeRTOS/Source/tasks.c **** 
3207:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3208:FreeRTOS/Source/tasks.c **** 
3209:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3210:FreeRTOS/Source/tasks.c **** 		{
3211:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3212:FreeRTOS/Source/tasks.c **** 		}
3213:FreeRTOS/Source/tasks.c **** 		#else
3214:FreeRTOS/Source/tasks.c **** 		{
3215:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3216:FreeRTOS/Source/tasks.c **** 		}
3217:FreeRTOS/Source/tasks.c **** 		#endif
3218:FreeRTOS/Source/tasks.c **** 
3219:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3220:FreeRTOS/Source/tasks.c **** 
3221:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3222:FreeRTOS/Source/tasks.c **** 	}
3223:FreeRTOS/Source/tasks.c **** 
3224:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3225:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3226:FreeRTOS/Source/tasks.c **** 
3227:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3228:FreeRTOS/Source/tasks.c **** 
3229:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3230:FreeRTOS/Source/tasks.c **** 	{
3231:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3232:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3233:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3234:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3235:FreeRTOS/Source/tasks.c **** 
3236:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3237:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3238:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3239:FreeRTOS/Source/tasks.c **** 		{
3240:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3241:FreeRTOS/Source/tasks.c **** 		}
3242:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3243:FreeRTOS/Source/tasks.c **** 
3244:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
3245:FreeRTOS/Source/tasks.c **** 		{
3246:FreeRTOS/Source/tasks.c **** 			/* Only free the stack if it was allocated dynamically in the first
3247:FreeRTOS/Source/tasks.c **** 			place. */
3248:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
3249:FreeRTOS/Source/tasks.c **** 			{
3250:FreeRTOS/Source/tasks.c **** 				vPortFreeAligned( pxTCB->pxStack );
3251:FreeRTOS/Source/tasks.c **** 			}
3252:FreeRTOS/Source/tasks.c **** 		}
3253:FreeRTOS/Source/tasks.c **** 		#else
3254:FreeRTOS/Source/tasks.c **** 		{
3255:FreeRTOS/Source/tasks.c **** 			vPortFreeAligned( pxTCB->pxStack );
3256:FreeRTOS/Source/tasks.c **** 		}
3257:FreeRTOS/Source/tasks.c **** 		#endif
3258:FreeRTOS/Source/tasks.c **** 
3259:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
3260:FreeRTOS/Source/tasks.c **** 	}
3261:FreeRTOS/Source/tasks.c **** 
3262:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3263:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3264:FreeRTOS/Source/tasks.c **** 
3265:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3266:FreeRTOS/Source/tasks.c **** {
 142               	.LM0:
 143               	.LFBB1:
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 0 */
 147               	.L__stack_usage = 0
3267:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3268:FreeRTOS/Source/tasks.c **** 
3269:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 149               	.LM1:
 150 0000 E091 0000 		lds r30,pxDelayedTaskList
 151 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 152 0008 8081      		ld r24,Z
 153 000a 8111      		cpse r24,__zero_reg__
 154 000c 00C0      		rjmp .L2
3270:FreeRTOS/Source/tasks.c **** 	{
3271:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set
3272:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is
3273:FreeRTOS/Source/tasks.c **** 		extremely unlikely that the
3274:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3275:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3276:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 156               	.LM2:
 157 000e 8FEF      		ldi r24,lo8(-1)
 158 0010 9FEF      		ldi r25,lo8(-1)
 159 0012 00C0      		rjmp .L4
 160               	.L2:
 161               	.LBB4:
 162               	.LBB5:
3277:FreeRTOS/Source/tasks.c **** 	}
3278:FreeRTOS/Source/tasks.c **** 	else
3279:FreeRTOS/Source/tasks.c **** 	{
3280:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3281:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3282:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3283:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3284:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 164               	.LM3:
 165 0014 E091 0000 		lds r30,pxDelayedTaskList
 166 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 167 001c 0580      		ldd __tmp_reg__,Z+5
 168 001e F681      		ldd r31,Z+6
 169 0020 E02D      		mov r30,__tmp_reg__
3285:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 171               	.LM4:
 172 0022 0680      		ldd __tmp_reg__,Z+6
 173 0024 F781      		ldd r31,Z+7
 174 0026 E02D      		mov r30,__tmp_reg__
 175 0028 8281      		ldd r24,Z+2
 176 002a 9381      		ldd r25,Z+3
 177               	.L4:
 178 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 179 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 180 0034 0895      		ret
 181               	.LBE5:
 182               	.LBE4:
 184               	.Lscope1:
 186               		.stabd	78,0,0
 190               	prvAddCurrentTaskToDelayedList:
 191               		.stabd	46,0,0
2990:FreeRTOS/Source/tasks.c **** {
 193               	.LM5:
 194               	.LFBB2:
 195 0036 CF93      		push r28
 196 0038 DF93      		push r29
 197               	/* prologue: function */
 198               	/* frame size = 0 */
 199               	/* stack size = 2 */
 200               	.L__stack_usage = 2
 201 003a EC01      		movw r28,r24
2992:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 203               	.LM6:
 204 003c E091 0000 		lds r30,pxCurrentTCB
 205 0040 F091 0000 		lds r31,pxCurrentTCB+1
 206 0044 9383      		std Z+3,r25
 207 0046 8283      		std Z+2,r24
2994:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 209               	.LM7:
 210 0048 8091 0000 		lds r24,xTickCount
 211 004c 9091 0000 		lds r25,xTickCount+1
 212               	.LBB8:
 213               	.LBB9:
2997:FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 215               	.LM8:
 216 0050 6091 0000 		lds r22,pxCurrentTCB
 217 0054 7091 0000 		lds r23,pxCurrentTCB+1
 218               	.LBE9:
 219               	.LBE8:
2994:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 221               	.LM9:
 222 0058 C817      		cp r28,r24
 223 005a D907      		cpc r29,r25
 224 005c 00F4      		brsh .L6
 225               	.LBB12:
 226               	.LBB10:
2997:FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 228               	.LM10:
 229 005e 8091 0000 		lds r24,pxOverflowDelayedTaskList
 230 0062 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 231 0066 6E5F      		subi r22,-2
 232 0068 7F4F      		sbci r23,-1
 233               	/* epilogue start */
 234               	.LBE10:
 235               	.LBE12:
3016:FreeRTOS/Source/tasks.c **** }
 237               	.LM11:
 238 006a DF91      		pop r29
 239 006c CF91      		pop r28
 240               	.LBB13:
 241               	.LBB11:
2997:FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 243               	.LM12:
 244 006e 0C94 0000 		jmp vListInsert
 245               	.L6:
 246               	.LBE11:
 247               	.LBE13:
3002:FreeRTOS/Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 249               	.LM13:
 250 0072 8091 0000 		lds r24,pxDelayedTaskList
 251 0076 9091 0000 		lds r25,pxDelayedTaskList+1
 252 007a 6E5F      		subi r22,-2
 253 007c 7F4F      		sbci r23,-1
 254 007e 0E94 0000 		call vListInsert
3007:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 256               	.LM14:
 257 0082 8091 0000 		lds r24,xNextTaskUnblockTime
 258 0086 9091 0000 		lds r25,xNextTaskUnblockTime+1
 259 008a C817      		cp r28,r24
 260 008c D907      		cpc r29,r25
 261 008e 00F4      		brsh .L5
3009:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 263               	.LM15:
 264 0090 D093 0000 		sts xNextTaskUnblockTime+1,r29
 265 0094 C093 0000 		sts xNextTaskUnblockTime,r28
 266               	.L5:
 267               	/* epilogue start */
3016:FreeRTOS/Source/tasks.c **** }
 269               	.LM16:
 270 0098 DF91      		pop r29
 271 009a CF91      		pop r28
 272 009c 0895      		ret
 274               	.Lscope2:
 276               		.stabd	78,0,0
 285               	.global	xTaskGenericCreate
 287               	xTaskGenericCreate:
 288               		.stabd	46,0,0
 548:FreeRTOS/Source/tasks.c **** {
 290               	.LM17:
 291               	.LFBB3:
 292 009e 5F92      		push r5
 293 00a0 6F92      		push r6
 294 00a2 7F92      		push r7
 295 00a4 8F92      		push r8
 296 00a6 9F92      		push r9
 297 00a8 AF92      		push r10
 298 00aa BF92      		push r11
 299 00ac CF92      		push r12
 300 00ae DF92      		push r13
 301 00b0 EF92      		push r14
 302 00b2 FF92      		push r15
 303 00b4 0F93      		push r16
 304 00b6 1F93      		push r17
 305 00b8 CF93      		push r28
 306 00ba DF93      		push r29
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 15 */
 310               	.L__stack_usage = 15
 311 00bc 4C01      		movw r8,r24
 312 00be 162F      		mov r17,r22
 313 00c0 572E      		mov r5,r23
 314 00c2 5A01      		movw r10,r20
 315 00c4 3901      		movw r6,r18
 316               	.LBB21:
 317               	.LBB22:
 318               	.LBB23:
3052:FreeRTOS/Source/tasks.c **** 		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackTyp
 320               	.LM18:
 321 00c6 C114      		cp r12,__zero_reg__
 322 00c8 D104      		cpc r13,__zero_reg__
 323 00ca 01F4      		brne .L9
 324 00cc CA01      		movw r24,r20
 325 00ce 0E94 0000 		call pvPortMalloc
 326 00d2 6C01      		movw r12,r24
3054:FreeRTOS/Source/tasks.c **** 		if( pxStack != NULL )
 328               	.LM19:
 329 00d4 0097      		sbiw r24,0
 330 00d6 01F4      		brne .+2
 331 00d8 00C0      		rjmp .L10
 332               	.L9:
3058:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 334               	.LM20:
 335 00da 86E2      		ldi r24,lo8(38)
 336 00dc 90E0      		ldi r25,0
 337 00de 0E94 0000 		call pvPortMalloc
 338 00e2 EC01      		movw r28,r24
3060:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 340               	.LM21:
 341 00e4 0097      		sbiw r24,0
 342 00e6 01F0      		breq .L11
3063:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxStack;
 344               	.LM22:
 345 00e8 D88E      		std Y+24,r13
 346 00ea CF8A      		std Y+23,r12
 347               	.LBE23:
 348               	.LBE22:
 349               	.LBE21:
 596:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 351               	.LM23:
 352 00ec 21E0      		ldi r18,1
 353 00ee A21A      		sub r10,r18
 354 00f0 B108      		sbc r11,__zero_reg__
 355 00f2 AC0C      		add r10,r12
 356 00f4 BD1C      		adc r11,r13
 357 00f6 E12F      		mov r30,r17
 358 00f8 F52D      		mov r31,r5
 359 00fa 80E0      		ldi r24,0
 360 00fc 90E0      		ldi r25,0
 361 00fe 00C0      		rjmp .L12
 362               	.L11:
 363               	.LBB26:
 364               	.LBB25:
 365               	.LBB24:
3069:FreeRTOS/Source/tasks.c **** 				vPortFree( pxStack );
 367               	.LM24:
 368 0100 C601      		movw r24,r12
 369 0102 0E94 0000 		call vPortFree
 370 0106 00C0      		rjmp .L10
 371               	.L12:
 547:FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 373               	.LM25:
 374 0108 BF01      		movw r22,r30
 375               	.LBE24:
 376               	.LBE25:
 377               	.LBE26:
 378               	.LBB27:
 379               	.LBB28:
2807:FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 381               	.LM26:
 382 010a 4191      		ld r20,Z+
 547:FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 384               	.LM27:
 385 010c 9E01      		movw r18,r28
 386 010e 280F      		add r18,r24
 387 0110 391F      		adc r19,r25
2807:FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 389               	.LM28:
 390 0112 D901      		movw r26,r18
 391 0114 5996      		adiw r26,25
 392 0116 4C93      		st X,r20
2812:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 394               	.LM29:
 395 0118 DB01      		movw r26,r22
 396 011a 2C91      		ld r18,X
 397 011c 2223      		tst r18
 398 011e 01F0      		breq .L13
 399 0120 0196      		adiw r24,1
2805:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 401               	.LM30:
 402 0122 8830      		cpi r24,8
 403 0124 9105      		cpc r25,__zero_reg__
 404 0126 01F4      		brne .L12
 405               	.L13:
2824:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 407               	.LM31:
 408 0128 18A2      		std Y+32,__zero_reg__
 409 012a 102F      		mov r17,r16
 410 012c 0430      		cpi r16,lo8(4)
 411 012e 00F0      		brlo .L14
 412 0130 13E0      		ldi r17,lo8(3)
 413               	.L14:
2837:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 415               	.LM32:
 416 0132 1E8B      		std Y+22,r17
2845:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 418               	.LM33:
 419 0134 6E01      		movw r12,r28
 420 0136 B2E0      		ldi r27,2
 421 0138 CB0E      		add r12,r27
 422 013a D11C      		adc r13,__zero_reg__
 423 013c C601      		movw r24,r12
 424 013e 0E94 0000 		call vListInitialiseItem
2846:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 426               	.LM34:
 427 0142 CE01      		movw r24,r28
 428 0144 0C96      		adiw r24,12
 429 0146 0E94 0000 		call vListInitialiseItem
2850:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 431               	.LM35:
 432 014a D987      		std Y+9,r29
 433 014c C887      		std Y+8,r28
2853:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
 435               	.LM36:
 436 014e 84E0      		ldi r24,lo8(4)
 437 0150 90E0      		ldi r25,0
 438 0152 811B      		sub r24,r17
 439 0154 9109      		sbc r25,__zero_reg__
 440 0156 9D87      		std Y+13,r25
 441 0158 8C87      		std Y+12,r24
2854:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 443               	.LM37:
 444 015a DB8B      		std Y+19,r29
 445 015c CA8B      		std Y+18,r28
2887:FreeRTOS/Source/tasks.c **** 		pxTCB->ulNotifiedValue = 0;
 447               	.LM38:
 448 015e 19A2      		std Y+33,__zero_reg__
 449 0160 1AA2      		std Y+34,__zero_reg__
 450 0162 1BA2      		std Y+35,__zero_reg__
 451 0164 1CA2      		std Y+36,__zero_reg__
2888:FreeRTOS/Source/tasks.c **** 		pxTCB->eNotifyState = eNotWaitingNotification;
 453               	.LM39:
 454 0166 1DA2      		std Y+37,__zero_reg__
 455               	.LBE28:
 456               	.LBE27:
 629:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 458               	.LM40:
 459 0168 A301      		movw r20,r6
 460 016a B401      		movw r22,r8
 461 016c C501      		movw r24,r10
 462 016e 0E94 0000 		call pxPortInitialiseStack
 463 0172 9983      		std Y+1,r25
 464 0174 8883      		st Y,r24
 633:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 466               	.LM41:
 467 0176 E114      		cp r14,__zero_reg__
 468 0178 F104      		cpc r15,__zero_reg__
 469 017a 01F0      		breq .L15
 638:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 471               	.LM42:
 472 017c F701      		movw r30,r14
 473 017e D183      		std Z+1,r29
 474 0180 C083      		st Z,r28
 475               	.L15:
 647:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 477               	.LM43:
 478               	/* #APP */
 479               	 ;  647 "FreeRTOS/Source/tasks.c" 1
 480 0182 0FB6      		in		__tmp_reg__, __SREG__
 481               	 ;  0 "" 2
 482               	 ;  647 "FreeRTOS/Source/tasks.c" 1
 483 0184 F894      		cli
 484               	 ;  0 "" 2
 485               	 ;  647 "FreeRTOS/Source/tasks.c" 1
 486 0186 0F92      		push	__tmp_reg__
 487               	 ;  0 "" 2
 649:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 489               	.LM44:
 490               	/* #NOAPP */
 491 0188 8091 0000 		lds r24,uxCurrentNumberOfTasks
 492 018c 8F5F      		subi r24,lo8(-(1))
 493 018e 8093 0000 		sts uxCurrentNumberOfTasks,r24
 650:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 495               	.LM45:
 496 0192 8091 0000 		lds r24,pxCurrentTCB
 497 0196 9091 0000 		lds r25,pxCurrentTCB+1
 498 019a 892B      		or r24,r25
 499 019c 01F4      		brne .L16
 654:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 501               	.LM46:
 502 019e D093 0000 		sts pxCurrentTCB+1,r29
 503 01a2 C093 0000 		sts pxCurrentTCB,r28
 656:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 505               	.LM47:
 506 01a6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 507 01aa 8130      		cpi r24,lo8(1)
 508 01ac 01F0      		breq .+2
 509 01ae 00C0      		rjmp .L18
 510 01b0 E12C      		mov r14,__zero_reg__
 511 01b2 F12C      		mov r15,__zero_reg__
 512               	.LBB29:
 513               	.LBB30:
2922:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 515               	.LM48:
 516 01b4 19E0      		ldi r17,lo8(9)
 517               	.L17:
 518 01b6 1E9D      		mul r17,r14
 519 01b8 C001      		movw r24,r0
 520 01ba 1F9D      		mul r17,r15
 521 01bc 900D      		add r25,r0
 522 01be 1124      		clr __zero_reg__
 523 01c0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 524 01c2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 525 01c4 0E94 0000 		call vListInitialise
 526 01c8 FFEF      		ldi r31,-1
 527 01ca EF1A      		sub r14,r31
 528 01cc FF0A      		sbc r15,r31
2920:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 530               	.LM49:
 531 01ce 24E0      		ldi r18,4
 532 01d0 E216      		cp r14,r18
 533 01d2 F104      		cpc r15,__zero_reg__
 534 01d4 01F4      		brne .L17
2925:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 536               	.LM50:
 537 01d6 80E0      		ldi r24,lo8(xDelayedTaskList1)
 538 01d8 90E0      		ldi r25,hi8(xDelayedTaskList1)
 539 01da 0E94 0000 		call vListInitialise
2926:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 541               	.LM51:
 542 01de 80E0      		ldi r24,lo8(xDelayedTaskList2)
 543 01e0 90E0      		ldi r25,hi8(xDelayedTaskList2)
 544 01e2 0E94 0000 		call vListInitialise
2927:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 546               	.LM52:
 547 01e6 80E0      		ldi r24,lo8(xPendingReadyList)
 548 01e8 90E0      		ldi r25,hi8(xPendingReadyList)
 549 01ea 0E94 0000 		call vListInitialise
2931:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 551               	.LM53:
 552 01ee 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 553 01f0 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 554 01f2 0E94 0000 		call vListInitialise
2943:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 556               	.LM54:
 557 01f6 80E0      		ldi r24,lo8(xDelayedTaskList1)
 558 01f8 90E0      		ldi r25,hi8(xDelayedTaskList1)
 559 01fa 9093 0000 		sts pxDelayedTaskList+1,r25
 560 01fe 8093 0000 		sts pxDelayedTaskList,r24
2944:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 562               	.LM55:
 563 0202 80E0      		ldi r24,lo8(xDelayedTaskList2)
 564 0204 90E0      		ldi r25,hi8(xDelayedTaskList2)
 565 0206 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 566 020a 8093 0000 		sts pxOverflowDelayedTaskList,r24
 567 020e 00C0      		rjmp .L18
 568               	.L16:
 569               	.LBE30:
 570               	.LBE29:
 673:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 572               	.LM56:
 573 0210 8091 0000 		lds r24,xSchedulerRunning
 574 0214 8111      		cpse r24,__zero_reg__
 575 0216 00C0      		rjmp .L18
 675:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 577               	.LM57:
 578 0218 E091 0000 		lds r30,pxCurrentTCB
 579 021c F091 0000 		lds r31,pxCurrentTCB+1
 580 0220 8689      		ldd r24,Z+22
 581 0222 0817      		cp r16,r24
 582 0224 00F0      		brlo .L18
 677:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 584               	.LM58:
 585 0226 D093 0000 		sts pxCurrentTCB+1,r29
 586 022a C093 0000 		sts pxCurrentTCB,r28
 587               	.L18:
 690:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 589               	.LM59:
 590 022e 8091 0000 		lds r24,uxTaskNumber
 591 0232 8F5F      		subi r24,lo8(-(1))
 592 0234 8093 0000 		sts uxTaskNumber,r24
 700:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 594               	.LM60:
 595 0238 8E89      		ldd r24,Y+22
 596 023a 9091 0000 		lds r25,uxTopReadyPriority
 597 023e 9817      		cp r25,r24
 598 0240 00F4      		brsh .L20
 700:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 600               	.LM61:
 601 0242 8093 0000 		sts uxTopReadyPriority,r24
 602               	.L20:
 700:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 604               	.LM62:
 605 0246 A9E0      		ldi r26,lo8(9)
 606 0248 8A9F      		mul r24,r26
 607 024a C001      		movw r24,r0
 608 024c 1124      		clr __zero_reg__
 609 024e B601      		movw r22,r12
 610 0250 8050      		subi r24,lo8(-(pxReadyTasksLists))
 611 0252 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 612 0254 0E94 0000 		call vListInsertEnd
 705:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 614               	.LM63:
 615               	/* #APP */
 616               	 ;  705 "FreeRTOS/Source/tasks.c" 1
 617 0258 0F90      		pop		__tmp_reg__
 618               	 ;  0 "" 2
 619               	 ;  705 "FreeRTOS/Source/tasks.c" 1
 620 025a 0FBE      		out		__SREG__, __tmp_reg__
 621               	 ;  0 "" 2
 715:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 623               	.LM64:
 624               	/* #NOAPP */
 625 025c 8091 0000 		lds r24,xSchedulerRunning
 626 0260 8823      		tst r24
 627 0262 01F0      		breq .L25
 719:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 629               	.LM65:
 630 0264 E091 0000 		lds r30,pxCurrentTCB
 631 0268 F091 0000 		lds r31,pxCurrentTCB+1
 632 026c 8689      		ldd r24,Z+22
 633 026e 8017      		cp r24,r16
 634 0270 00F4      		brsh .L25
 721:FreeRTOS/Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 636               	.LM66:
 637 0272 0E94 0000 		call vPortYield
 638               	.L25:
 702:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 640               	.LM67:
 641 0276 81E0      		ldi r24,lo8(1)
 642 0278 00C0      		rjmp .L37
 643               	.L10:
 709:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 645               	.LM68:
 646 027a 8FEF      		ldi r24,lo8(-1)
 647               	.L37:
 648               	/* epilogue start */
 735:FreeRTOS/Source/tasks.c **** }
 650               	.LM69:
 651 027c DF91      		pop r29
 652 027e CF91      		pop r28
 653 0280 1F91      		pop r17
 654 0282 0F91      		pop r16
 655 0284 FF90      		pop r15
 656 0286 EF90      		pop r14
 657 0288 DF90      		pop r13
 658 028a CF90      		pop r12
 659 028c BF90      		pop r11
 660 028e AF90      		pop r10
 661 0290 9F90      		pop r9
 662 0292 8F90      		pop r8
 663 0294 7F90      		pop r7
 664 0296 6F90      		pop r6
 665 0298 5F90      		pop r5
 666 029a 0895      		ret
 679               	.Lscope3:
 681               		.stabd	78,0,0
 684               	.global	vTaskDelete
 686               	vTaskDelete:
 687               		.stabd	46,0,0
 741:FreeRTOS/Source/tasks.c **** 	{
 689               	.LM70:
 690               	.LFBB4:
 691 029c 0F93      		push r16
 692 029e 1F93      		push r17
 693 02a0 CF93      		push r28
 694 02a2 DF93      		push r29
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 697               	/* stack size = 4 */
 698               	.L__stack_usage = 4
 744:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 700               	.LM71:
 701               	/* #APP */
 702               	 ;  744 "FreeRTOS/Source/tasks.c" 1
 703 02a4 0FB6      		in		__tmp_reg__, __SREG__
 704               	 ;  0 "" 2
 705               	 ;  744 "FreeRTOS/Source/tasks.c" 1
 706 02a6 F894      		cli
 707               	 ;  0 "" 2
 708               	 ;  744 "FreeRTOS/Source/tasks.c" 1
 709 02a8 0F92      		push	__tmp_reg__
 710               	 ;  0 "" 2
 748:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 712               	.LM72:
 713               	/* #NOAPP */
 714 02aa 0097      		sbiw r24,0
 715 02ac 01F4      		brne .L43
 748:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 717               	.LM73:
 718 02ae C091 0000 		lds r28,pxCurrentTCB
 719 02b2 D091 0000 		lds r29,pxCurrentTCB+1
 720 02b6 00C0      		rjmp .L39
 721               	.L43:
 748:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 723               	.LM74:
 724 02b8 EC01      		movw r28,r24
 725               	.L39:
 754:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 727               	.LM75:
 728 02ba 8E01      		movw r16,r28
 729 02bc 0E5F      		subi r16,-2
 730 02be 1F4F      		sbci r17,-1
 731 02c0 C801      		movw r24,r16
 732 02c2 0E94 0000 		call uxListRemove
 764:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 734               	.LM76:
 735 02c6 8C89      		ldd r24,Y+20
 736 02c8 9D89      		ldd r25,Y+21
 737 02ca 892B      		or r24,r25
 738 02cc 01F0      		breq .L40
 766:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 740               	.LM77:
 741 02ce CE01      		movw r24,r28
 742 02d0 0C96      		adiw r24,12
 743 02d2 0E94 0000 		call uxListRemove
 744               	.L40:
 773:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 746               	.LM78:
 747 02d6 B801      		movw r22,r16
 748 02d8 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 749 02da 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 750 02dc 0E94 0000 		call vListInsertEnd
 778:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 752               	.LM79:
 753 02e0 8091 0000 		lds r24,uxTasksDeleted
 754 02e4 8F5F      		subi r24,lo8(-(1))
 755 02e6 8093 0000 		sts uxTasksDeleted,r24
 782:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 757               	.LM80:
 758 02ea 8091 0000 		lds r24,uxTaskNumber
 759 02ee 8F5F      		subi r24,lo8(-(1))
 760 02f0 8093 0000 		sts uxTaskNumber,r24
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 762               	.LM81:
 763               	/* #APP */
 764               	 ;  786 "FreeRTOS/Source/tasks.c" 1
 765 02f4 0F90      		pop		__tmp_reg__
 766               	 ;  0 "" 2
 767               	 ;  786 "FreeRTOS/Source/tasks.c" 1
 768 02f6 0FBE      		out		__SREG__, __tmp_reg__
 769               	 ;  0 "" 2
 790:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 771               	.LM82:
 772               	/* #NOAPP */
 773 02f8 8091 0000 		lds r24,xSchedulerRunning
 774 02fc 8823      		tst r24
 775 02fe 01F0      		breq .L38
 792:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 777               	.LM83:
 778 0300 8091 0000 		lds r24,pxCurrentTCB
 779 0304 9091 0000 		lds r25,pxCurrentTCB+1
 780 0308 C817      		cp r28,r24
 781 030a D907      		cpc r29,r25
 782 030c 01F4      		brne .L42
 802:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 784               	.LM84:
 785 030e 0E94 0000 		call vPortYield
 786 0312 00C0      		rjmp .L38
 787               	.L42:
 808:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 789               	.LM85:
 790               	/* #APP */
 791               	 ;  808 "FreeRTOS/Source/tasks.c" 1
 792 0314 0FB6      		in		__tmp_reg__, __SREG__
 793               	 ;  0 "" 2
 794               	 ;  808 "FreeRTOS/Source/tasks.c" 1
 795 0316 F894      		cli
 796               	 ;  0 "" 2
 797               	 ;  808 "FreeRTOS/Source/tasks.c" 1
 798 0318 0F92      		push	__tmp_reg__
 799               	 ;  0 "" 2
 810:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 801               	.LM86:
 802               	/* #NOAPP */
 803 031a 0E94 0000 		call prvResetNextTaskUnblockTime
 812:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 805               	.LM87:
 806               	/* #APP */
 807               	 ;  812 "FreeRTOS/Source/tasks.c" 1
 808 031e 0F90      		pop		__tmp_reg__
 809               	 ;  0 "" 2
 810               	 ;  812 "FreeRTOS/Source/tasks.c" 1
 811 0320 0FBE      		out		__SREG__, __tmp_reg__
 812               	 ;  0 "" 2
 813               	/* #NOAPP */
 814               	.L38:
 815               	/* epilogue start */
 815:FreeRTOS/Source/tasks.c **** 	}
 817               	.LM88:
 818 0322 DF91      		pop r29
 819 0324 CF91      		pop r28
 820 0326 1F91      		pop r17
 821 0328 0F91      		pop r16
 822 032a 0895      		ret
 827               	.Lscope4:
 829               		.stabd	78,0,0
 830               		.section	.rodata.str1.1,"aMS",@progbits,1
 831               	.LC0:
 832 0000 4944 4C45 		.string	"IDLE"
 832      00
 833               		.text
 835               	.global	vTaskStartScheduler
 837               	vTaskStartScheduler:
 838               		.stabd	46,0,0
1540:FreeRTOS/Source/tasks.c **** {
 840               	.LM89:
 841               	.LFBB5:
 842 032c AF92      		push r10
 843 032e BF92      		push r11
 844 0330 CF92      		push r12
 845 0332 DF92      		push r13
 846 0334 EF92      		push r14
 847 0336 FF92      		push r15
 848 0338 0F93      		push r16
 849               	/* prologue: function */
 850               	/* frame size = 0 */
 851               	/* stack size = 7 */
 852               	.L__stack_usage = 7
1553:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
 854               	.LM90:
 855 033a A12C      		mov r10,__zero_reg__
 856 033c B12C      		mov r11,__zero_reg__
 857 033e C12C      		mov r12,__zero_reg__
 858 0340 D12C      		mov r13,__zero_reg__
 859 0342 E12C      		mov r14,__zero_reg__
 860 0344 F12C      		mov r15,__zero_reg__
 861 0346 00E0      		ldi r16,0
 862 0348 20E0      		ldi r18,0
 863 034a 30E0      		ldi r19,0
 864 034c 45E5      		ldi r20,lo8(85)
 865 034e 50E0      		ldi r21,0
 866 0350 60E0      		ldi r22,lo8(.LC0)
 867 0352 70E0      		ldi r23,hi8(.LC0)
 868 0354 80E0      		ldi r24,lo8(gs(prvIdleTask))
 869 0356 90E0      		ldi r25,hi8(gs(prvIdleTask))
 870 0358 0E94 0000 		call xTaskGenericCreate
1570:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 872               	.LM91:
 873 035c 8130      		cpi r24,lo8(1)
 874 035e 01F4      		brne .L50
1577:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 876               	.LM92:
 877               	/* #APP */
 878               	 ;  1577 "FreeRTOS/Source/tasks.c" 1
 879 0360 F894      		cli
 880               	 ;  0 "" 2
1587:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 882               	.LM93:
 883               	/* #NOAPP */
 884 0362 8093 0000 		sts xSchedulerRunning,r24
1588:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 886               	.LM94:
 887 0366 1092 0000 		sts xTickCount+1,__zero_reg__
 888 036a 1092 0000 		sts xTickCount,__zero_reg__
 889               	/* epilogue start */
1614:FreeRTOS/Source/tasks.c **** }
 891               	.LM95:
 892 036e 0F91      		pop r16
 893 0370 FF90      		pop r15
 894 0372 EF90      		pop r14
 895 0374 DF90      		pop r13
 896 0376 CF90      		pop r12
 897 0378 BF90      		pop r11
 898 037a AF90      		pop r10
1597:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 900               	.LM96:
 901 037c 0C94 0000 		jmp xPortStartScheduler
 902               	.L50:
 903               	/* epilogue start */
1614:FreeRTOS/Source/tasks.c **** }
 905               	.LM97:
 906 0380 0F91      		pop r16
 907 0382 FF90      		pop r15
 908 0384 EF90      		pop r14
 909 0386 DF90      		pop r13
 910 0388 CF90      		pop r12
 911 038a BF90      		pop r11
 912 038c AF90      		pop r10
 913 038e 0895      		ret
 915               	.Lscope5:
 917               		.stabd	78,0,0
 919               	.global	vTaskEndScheduler
 921               	vTaskEndScheduler:
 922               		.stabd	46,0,0
1618:FreeRTOS/Source/tasks.c **** {
 924               	.LM98:
 925               	.LFBB6:
 926               	/* prologue: function */
 927               	/* frame size = 0 */
 928               	/* stack size = 0 */
 929               	.L__stack_usage = 0
1622:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 931               	.LM99:
 932               	/* #APP */
 933               	 ;  1622 "FreeRTOS/Source/tasks.c" 1
 934 0390 F894      		cli
 935               	 ;  0 "" 2
1623:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 937               	.LM100:
 938               	/* #NOAPP */
 939 0392 1092 0000 		sts xSchedulerRunning,__zero_reg__
1624:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 941               	.LM101:
 942 0396 0C94 0000 		jmp vPortEndScheduler
 944               	.Lscope6:
 946               		.stabd	78,0,0
 948               	.global	vTaskSuspendAll
 950               	vTaskSuspendAll:
 951               		.stabd	46,0,0
1629:FreeRTOS/Source/tasks.c **** {
 953               	.LM102:
 954               	.LFBB7:
 955               	/* prologue: function */
 956               	/* frame size = 0 */
 957               	/* stack size = 0 */
 958               	.L__stack_usage = 0
1634:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 960               	.LM103:
 961 039a 8091 0000 		lds r24,uxSchedulerSuspended
 962 039e 8F5F      		subi r24,lo8(-(1))
 963 03a0 8093 0000 		sts uxSchedulerSuspended,r24
 964 03a4 0895      		ret
 966               	.Lscope7:
 968               		.stabd	78,0,0
 970               	.global	xTaskGetTickCount
 972               	xTaskGetTickCount:
 973               		.stabd	46,0,0
1760:FreeRTOS/Source/tasks.c **** {
 975               	.LM104:
 976               	.LFBB8:
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 0 */
 980               	.L__stack_usage = 0
1764:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
 982               	.LM105:
 983               	/* #APP */
 984               	 ;  1764 "FreeRTOS/Source/tasks.c" 1
 985 03a6 0FB6      		in		__tmp_reg__, __SREG__
 986               	 ;  0 "" 2
 987               	 ;  1764 "FreeRTOS/Source/tasks.c" 1
 988 03a8 F894      		cli
 989               	 ;  0 "" 2
 990               	 ;  1764 "FreeRTOS/Source/tasks.c" 1
 991 03aa 0F92      		push	__tmp_reg__
 992               	 ;  0 "" 2
1766:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 994               	.LM106:
 995               	/* #NOAPP */
 996 03ac 2091 0000 		lds r18,xTickCount
 997 03b0 3091 0000 		lds r19,xTickCount+1
1768:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
 999               	.LM107:
 1000               	/* #APP */
 1001               	 ;  1768 "FreeRTOS/Source/tasks.c" 1
 1002 03b4 0F90      		pop		__tmp_reg__
 1003               	 ;  0 "" 2
 1004               	 ;  1768 "FreeRTOS/Source/tasks.c" 1
 1005 03b6 0FBE      		out		__SREG__, __tmp_reg__
 1006               	 ;  0 "" 2
1771:FreeRTOS/Source/tasks.c **** }
 1008               	.LM108:
 1009               	/* #NOAPP */
 1010 03b8 C901      		movw r24,r18
 1011 03ba 0895      		ret
 1016               	.Lscope8:
 1018               		.stabd	78,0,0
 1020               	.global	xTaskGetTickCountFromISR
 1022               	xTaskGetTickCountFromISR:
 1023               		.stabd	46,0,0
1775:FreeRTOS/Source/tasks.c **** {
 1025               	.LM109:
 1026               	.LFBB9:
 1027               	/* prologue: function */
 1028               	/* frame size = 0 */
 1029               	/* stack size = 0 */
 1030               	.L__stack_usage = 0
1797:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
 1032               	.LM110:
 1033 03bc 2091 0000 		lds r18,xTickCount
 1034 03c0 3091 0000 		lds r19,xTickCount+1
1802:FreeRTOS/Source/tasks.c **** }
 1036               	.LM111:
 1037 03c4 C901      		movw r24,r18
 1038 03c6 0895      		ret
 1043               	.Lscope9:
 1045               		.stabd	78,0,0
 1047               	.global	uxTaskGetNumberOfTasks
 1049               	uxTaskGetNumberOfTasks:
 1050               		.stabd	46,0,0
1806:FreeRTOS/Source/tasks.c **** {
 1052               	.LM112:
 1053               	.LFBB10:
 1054               	/* prologue: function */
 1055               	/* frame size = 0 */
 1056               	/* stack size = 0 */
 1057               	.L__stack_usage = 0
1809:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1059               	.LM113:
 1060 03c8 8091 0000 		lds r24,uxCurrentNumberOfTasks
1810:FreeRTOS/Source/tasks.c **** }
 1062               	.LM114:
 1063 03cc 0895      		ret
 1065               	.Lscope10:
 1067               		.stabd	78,0,0
 1069               	.global	xTaskIncrementTick
 1071               	xTaskIncrementTick:
 1072               		.stabd	46,0,0
1935:FreeRTOS/Source/tasks.c **** {
 1074               	.LM115:
 1075               	.LFBB11:
 1076 03ce CF92      		push r12
 1077 03d0 DF92      		push r13
 1078 03d2 EF92      		push r14
 1079 03d4 FF92      		push r15
 1080 03d6 0F93      		push r16
 1081 03d8 1F93      		push r17
 1082 03da CF93      		push r28
 1083 03dc DF93      		push r29
 1084               	/* prologue: function */
 1085               	/* frame size = 0 */
 1086               	/* stack size = 8 */
 1087               	.L__stack_usage = 8
1944:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1089               	.LM116:
 1090 03de 8091 0000 		lds r24,uxSchedulerSuspended
 1091 03e2 8111      		cpse r24,__zero_reg__
 1092 03e4 00C0      		rjmp .L58
1948:FreeRTOS/Source/tasks.c **** 		++xTickCount;
 1094               	.LM117:
 1095 03e6 8091 0000 		lds r24,xTickCount
 1096 03ea 9091 0000 		lds r25,xTickCount+1
 1097 03ee 0196      		adiw r24,1
 1098 03f0 9093 0000 		sts xTickCount+1,r25
 1099 03f4 8093 0000 		sts xTickCount,r24
 1100               	.LBB31:
1953:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 1102               	.LM118:
 1103 03f8 0091 0000 		lds r16,xTickCount
 1104 03fc 1091 0000 		lds r17,xTickCount+1
1955:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
 1106               	.LM119:
 1107 0400 0115      		cp r16,__zero_reg__
 1108 0402 1105      		cpc r17,__zero_reg__
 1109 0404 01F4      		brne .L59
 1110               	.LBB32:
1957:FreeRTOS/Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 1112               	.LM120:
 1113 0406 8091 0000 		lds r24,pxDelayedTaskList
 1114 040a 9091 0000 		lds r25,pxDelayedTaskList+1
 1115 040e 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1116 0412 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1117 0416 3093 0000 		sts pxDelayedTaskList+1,r19
 1118 041a 2093 0000 		sts pxDelayedTaskList,r18
 1119 041e 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1120 0422 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1121 0426 8091 0000 		lds r24,xNumOfOverflows
 1122 042a 8F5F      		subi r24,lo8(-(1))
 1123 042c 8093 0000 		sts xNumOfOverflows,r24
 1124 0430 0E94 0000 		call prvResetNextTaskUnblockTime
 1125               	.L59:
 1126               	.LBE32:
1968:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 1128               	.LM121:
 1129 0434 8091 0000 		lds r24,xNextTaskUnblockTime
 1130 0438 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1131 043c D12C      		mov r13,__zero_reg__
 1132 043e 0817      		cp r16,r24
 1133 0440 1907      		cpc r17,r25
 1134 0442 00F4      		brsh .L70
 1135 0444 00C0      		rjmp .L61
 1136               	.L71:
2034:FreeRTOS/Source/tasks.c **** 								xSwitchRequired = pdTRUE;
 1138               	.LM122:
 1139 0446 DD24      		clr r13
 1140 0448 D394      		inc r13
 1141 044a 00C0      		rjmp .L77
 1142               	.L70:
2022:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1144               	.LM123:
 1145 044c 89E0      		ldi r24,lo8(9)
 1146 044e C82E      		mov r12,r24
 1147               	.L77:
1972:FreeRTOS/Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1149               	.LM124:
 1150 0450 E091 0000 		lds r30,pxDelayedTaskList
 1151 0454 F091 0000 		lds r31,pxDelayedTaskList+1
 1152 0458 8081      		ld r24,Z
 1153 045a 8111      		cpse r24,__zero_reg__
 1154 045c 00C0      		rjmp .L62
1979:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 1156               	.LM125:
 1157 045e 8FEF      		ldi r24,lo8(-1)
 1158 0460 9FEF      		ldi r25,lo8(-1)
 1159 0462 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1160 0466 8093 0000 		sts xNextTaskUnblockTime,r24
1980:FreeRTOS/Source/tasks.c **** 						break;
 1162               	.LM126:
 1163 046a 00C0      		rjmp .L61
 1164               	.L62:
1988:FreeRTOS/Source/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1166               	.LM127:
 1167 046c E091 0000 		lds r30,pxDelayedTaskList
 1168 0470 F091 0000 		lds r31,pxDelayedTaskList+1
 1169 0474 0580      		ldd __tmp_reg__,Z+5
 1170 0476 F681      		ldd r31,Z+6
 1171 0478 E02D      		mov r30,__tmp_reg__
 1172 047a C681      		ldd r28,Z+6
 1173 047c D781      		ldd r29,Z+7
1989:FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1175               	.LM128:
 1176 047e 2A81      		ldd r18,Y+2
 1177 0480 3B81      		ldd r19,Y+3
1991:FreeRTOS/Source/tasks.c **** 						if( xConstTickCount < xItemValue )
 1179               	.LM129:
 1180 0482 0217      		cp r16,r18
 1181 0484 1307      		cpc r17,r19
 1182 0486 00F4      		brsh .L63
1998:FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 1184               	.LM130:
 1185 0488 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1186 048c 2093 0000 		sts xNextTaskUnblockTime,r18
1999:FreeRTOS/Source/tasks.c **** 							break;
 1188               	.LM131:
 1189 0490 00C0      		rjmp .L61
 1190               	.L63:
2007:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1192               	.LM132:
 1193 0492 7E01      		movw r14,r28
 1194 0494 82E0      		ldi r24,2
 1195 0496 E80E      		add r14,r24
 1196 0498 F11C      		adc r15,__zero_reg__
 1197 049a C701      		movw r24,r14
 1198 049c 0E94 0000 		call uxListRemove
2011:FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1200               	.LM133:
 1201 04a0 2C89      		ldd r18,Y+20
 1202 04a2 3D89      		ldd r19,Y+21
 1203 04a4 232B      		or r18,r19
 1204 04a6 01F0      		breq .L64
2013:FreeRTOS/Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1206               	.LM134:
 1207 04a8 CE01      		movw r24,r28
 1208 04aa 0C96      		adiw r24,12
 1209 04ac 0E94 0000 		call uxListRemove
 1210               	.L64:
2022:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1212               	.LM135:
 1213 04b0 2E89      		ldd r18,Y+22
 1214 04b2 8091 0000 		lds r24,uxTopReadyPriority
 1215 04b6 8217      		cp r24,r18
 1216 04b8 00F4      		brsh .L65
2022:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1218               	.LM136:
 1219 04ba 2093 0000 		sts uxTopReadyPriority,r18
 1220               	.L65:
2022:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 1222               	.LM137:
 1223 04be C29E      		mul r12,r18
 1224 04c0 C001      		movw r24,r0
 1225 04c2 1124      		clr __zero_reg__
 1226 04c4 B701      		movw r22,r14
 1227 04c6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1228 04c8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1229 04ca 0E94 0000 		call vListInsertEnd
2032:FreeRTOS/Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1231               	.LM138:
 1232 04ce E091 0000 		lds r30,pxCurrentTCB
 1233 04d2 F091 0000 		lds r31,pxCurrentTCB+1
 1234 04d6 9E89      		ldd r25,Y+22
 1235 04d8 8689      		ldd r24,Z+22
 1236 04da 9817      		cp r25,r24
 1237 04dc 00F0      		brlo .+2
 1238 04de 00C0      		rjmp .L71
 1239 04e0 00C0      		rjmp .L77
 1240               	.L61:
 1241               	.LBE31:
2052:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 1243               	.LM139:
 1244 04e2 E091 0000 		lds r30,pxCurrentTCB
 1245 04e6 F091 0000 		lds r31,pxCurrentTCB+1
 1246 04ea E689      		ldd r30,Z+22
 1247 04ec 89E0      		ldi r24,lo8(9)
 1248 04ee E89F      		mul r30,r24
 1249 04f0 F001      		movw r30,r0
 1250 04f2 1124      		clr __zero_reg__
 1251 04f4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1252 04f6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1253 04f8 8081      		ld r24,Z
 1254 04fa 8230      		cpi r24,lo8(2)
 1255 04fc 00F4      		brsh .L72
 1256 04fe 00C0      		rjmp .L68
 1257               	.L58:
2080:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
 1259               	.LM140:
 1260 0500 8091 0000 		lds r24,uxPendedTicks
 1261 0504 8F5F      		subi r24,lo8(-(1))
 1262 0506 8093 0000 		sts uxPendedTicks,r24
1938:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 1264               	.LM141:
 1265 050a D12C      		mov r13,__zero_reg__
 1266 050c 00C0      		rjmp .L68
 1267               	.L72:
2054:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 1269               	.LM142:
 1270 050e DD24      		clr r13
 1271 0510 D394      		inc r13
 1272               	.L68:
2093:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 1274               	.LM143:
 1275 0512 8091 0000 		lds r24,xYieldPending
 1276 0516 8823      		tst r24
 1277 0518 01F0      		breq .L69
2095:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 1279               	.LM144:
 1280 051a DD24      		clr r13
 1281 051c D394      		inc r13
 1282               	.L69:
2105:FreeRTOS/Source/tasks.c **** }
 1284               	.LM145:
 1285 051e 8D2D      		mov r24,r13
 1286               	/* epilogue start */
 1287 0520 DF91      		pop r29
 1288 0522 CF91      		pop r28
 1289 0524 1F91      		pop r17
 1290 0526 0F91      		pop r16
 1291 0528 FF90      		pop r15
 1292 052a EF90      		pop r14
 1293 052c DF90      		pop r13
 1294 052e CF90      		pop r12
 1295 0530 0895      		ret
 1308               	.Lscope11:
 1310               		.stabd	78,0,0
 1312               	.global	xTaskResumeAll
 1314               	xTaskResumeAll:
 1315               		.stabd	46,0,0
1667:FreeRTOS/Source/tasks.c **** {
 1317               	.LM146:
 1318               	.LFBB12:
 1319 0532 EF92      		push r14
 1320 0534 FF92      		push r15
 1321 0536 0F93      		push r16
 1322 0538 1F93      		push r17
 1323 053a CF93      		push r28
 1324 053c DF93      		push r29
 1325               	/* prologue: function */
 1326               	/* frame size = 0 */
 1327               	/* stack size = 6 */
 1328               	.L__stack_usage = 6
1680:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1330               	.LM147:
 1331               	/* #APP */
 1332               	 ;  1680 "FreeRTOS/Source/tasks.c" 1
 1333 053e 0FB6      		in		__tmp_reg__, __SREG__
 1334               	 ;  0 "" 2
 1335               	 ;  1680 "FreeRTOS/Source/tasks.c" 1
 1336 0540 F894      		cli
 1337               	 ;  0 "" 2
 1338               	 ;  1680 "FreeRTOS/Source/tasks.c" 1
 1339 0542 0F92      		push	__tmp_reg__
 1340               	 ;  0 "" 2
1682:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1342               	.LM148:
 1343               	/* #NOAPP */
 1344 0544 8091 0000 		lds r24,uxSchedulerSuspended
 1345 0548 8150      		subi r24,lo8(-(-1))
 1346 054a 8093 0000 		sts uxSchedulerSuspended,r24
1684:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1348               	.LM149:
 1349 054e 8091 0000 		lds r24,uxSchedulerSuspended
 1350 0552 8823      		tst r24
 1351 0554 01F0      		breq .L79
 1352               	.L82:
1669:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1354               	.LM150:
 1355 0556 80E0      		ldi r24,0
 1356 0558 00C0      		rjmp .L80
 1357               	.L79:
1686:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1359               	.LM151:
 1360 055a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1361 055e 8111      		cpse r24,__zero_reg__
 1362 0560 00C0      		rjmp .L94
 1363 0562 00C0      		rjmp .L82
 1364               	.L85:
1692:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1366               	.LM152:
 1367 0564 E091 0000 		lds r30,xPendingReadyList+5
 1368 0568 F091 0000 		lds r31,xPendingReadyList+5+1
 1369 056c C681      		ldd r28,Z+6
 1370 056e D781      		ldd r29,Z+7
1693:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1372               	.LM153:
 1373 0570 CE01      		movw r24,r28
 1374 0572 0C96      		adiw r24,12
 1375 0574 0E94 0000 		call uxListRemove
1694:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1377               	.LM154:
 1378 0578 8E01      		movw r16,r28
 1379 057a 0E5F      		subi r16,-2
 1380 057c 1F4F      		sbci r17,-1
 1381 057e C801      		movw r24,r16
 1382 0580 0E94 0000 		call uxListRemove
1695:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1384               	.LM155:
 1385 0584 8E89      		ldd r24,Y+22
 1386 0586 9091 0000 		lds r25,uxTopReadyPriority
 1387 058a 9817      		cp r25,r24
 1388 058c 00F4      		brsh .L83
1695:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1390               	.LM156:
 1391 058e 8093 0000 		sts uxTopReadyPriority,r24
 1392               	.L83:
1695:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1394               	.LM157:
 1395 0592 F89E      		mul r15,r24
 1396 0594 C001      		movw r24,r0
 1397 0596 1124      		clr __zero_reg__
 1398 0598 B801      		movw r22,r16
 1399 059a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1400 059c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1401 059e 0E94 0000 		call vListInsertEnd
1699:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1403               	.LM158:
 1404 05a2 E091 0000 		lds r30,pxCurrentTCB
 1405 05a6 F091 0000 		lds r31,pxCurrentTCB+1
 1406 05aa 9E89      		ldd r25,Y+22
 1407 05ac 8689      		ldd r24,Z+22
 1408 05ae 9817      		cp r25,r24
 1409 05b0 00F0      		brlo .L97
1701:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
 1411               	.LM159:
 1412 05b2 E092 0000 		sts xYieldPending,r14
 1413 05b6 00C0      		rjmp .L97
 1414               	.L94:
1695:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1416               	.LM160:
 1417 05b8 99E0      		ldi r25,lo8(9)
 1418 05ba F92E      		mov r15,r25
1701:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
 1420               	.LM161:
 1421 05bc EE24      		clr r14
 1422 05be E394      		inc r14
 1423               	.L97:
1690:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1425               	.LM162:
 1426 05c0 8091 0000 		lds r24,xPendingReadyList
 1427 05c4 8111      		cpse r24,__zero_reg__
 1428 05c6 00C0      		rjmp .L85
1713:FreeRTOS/Source/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
 1430               	.LM163:
 1431 05c8 8091 0000 		lds r24,uxPendedTicks
 1432 05cc 8111      		cpse r24,__zero_reg__
 1433 05ce 00C0      		rjmp .L86
 1434               	.L90:
1733:FreeRTOS/Source/tasks.c **** 				if( xYieldPending == pdTRUE )
 1436               	.LM164:
 1437 05d0 8091 0000 		lds r24,xYieldPending
 1438 05d4 8130      		cpi r24,lo8(1)
 1439 05d6 01F0      		breq .+2
 1440 05d8 00C0      		rjmp .L82
 1441 05da 00C0      		rjmp .L87
 1442               	.L89:
1717:FreeRTOS/Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1444               	.LM165:
 1445 05dc 0E94 0000 		call xTaskIncrementTick
 1446 05e0 8111      		cpse r24,__zero_reg__
1719:FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
 1448               	.LM166:
 1449 05e2 C093 0000 		sts xYieldPending,r28
 1450               	.L88:
1725:FreeRTOS/Source/tasks.c **** 						--uxPendedTicks;
 1452               	.LM167:
 1453 05e6 8091 0000 		lds r24,uxPendedTicks
 1454 05ea 8150      		subi r24,lo8(-(-1))
 1455 05ec 8093 0000 		sts uxPendedTicks,r24
 1456 05f0 00C0      		rjmp .L98
 1457               	.L86:
1719:FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
 1459               	.LM168:
 1460 05f2 C1E0      		ldi r28,lo8(1)
 1461               	.L98:
1715:FreeRTOS/Source/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
 1463               	.LM169:
 1464 05f4 8091 0000 		lds r24,uxPendedTicks
 1465 05f8 8111      		cpse r24,__zero_reg__
 1466 05fa 00C0      		rjmp .L89
 1467 05fc 00C0      		rjmp .L90
 1468               	.L87:
1740:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1470               	.LM170:
 1471 05fe 0E94 0000 		call vPortYield
1737:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 1473               	.LM171:
 1474 0602 81E0      		ldi r24,lo8(1)
 1475               	.L80:
1753:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1477               	.LM172:
 1478               	/* #APP */
 1479               	 ;  1753 "FreeRTOS/Source/tasks.c" 1
 1480 0604 0F90      		pop		__tmp_reg__
 1481               	 ;  0 "" 2
 1482               	 ;  1753 "FreeRTOS/Source/tasks.c" 1
 1483 0606 0FBE      		out		__SREG__, __tmp_reg__
 1484               	 ;  0 "" 2
 1485               	/* epilogue start */
1756:FreeRTOS/Source/tasks.c **** }
 1487               	.LM173:
 1488               	/* #NOAPP */
 1489 0608 DF91      		pop r29
 1490 060a CF91      		pop r28
 1491 060c 1F91      		pop r17
 1492 060e 0F91      		pop r16
 1493 0610 FF90      		pop r15
 1494 0612 EF90      		pop r14
 1495 0614 0895      		ret
 1501               	.Lscope12:
 1503               		.stabd	78,0,0
 1507               	prvIdleTask:
 1508               		.stabd	46,0,0
2654:FreeRTOS/Source/tasks.c **** {
 1510               	.LM174:
 1511               	.LFBB13:
 1512               	/* prologue: function */
 1513               	/* frame size = 0 */
 1514               	/* stack size = 0 */
 1515               	.L__stack_usage = 0
 1516 0616 00C0      		rjmp .L109
 1517               	.L102:
 1518               	.LBB40:
 1519               	.LBB41:
2958:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 1521               	.LM175:
 1522 0618 0E94 0000 		call vTaskSuspendAll
2960:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1524               	.LM176:
 1525 061c C091 0000 		lds r28,xTasksWaitingTermination
2962:FreeRTOS/Source/tasks.c **** 			( void ) xTaskResumeAll();
 1527               	.LM177:
 1528 0620 0E94 0000 		call xTaskResumeAll
2964:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 1530               	.LM178:
 1531 0624 CC23      		tst r28
 1532 0626 01F0      		breq .L109
 1533               	.LBB42:
2968:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 1535               	.LM179:
 1536               	/* #APP */
 1537               	 ;  2968 "FreeRTOS/Source/tasks.c" 1
 1538 0628 0FB6      		in		__tmp_reg__, __SREG__
 1539               	 ;  0 "" 2
 1540               	 ;  2968 "FreeRTOS/Source/tasks.c" 1
 1541 062a F894      		cli
 1542               	 ;  0 "" 2
 1543               	 ;  2968 "FreeRTOS/Source/tasks.c" 1
 1544 062c 0F92      		push	__tmp_reg__
 1545               	 ;  0 "" 2
2970:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 1547               	.LM180:
 1548               	/* #NOAPP */
 1549 062e E091 0000 		lds r30,xTasksWaitingTermination+5
 1550 0632 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 1551 0636 C681      		ldd r28,Z+6
 1552 0638 D781      		ldd r29,Z+7
2971:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1554               	.LM181:
 1555 063a CE01      		movw r24,r28
 1556 063c 0296      		adiw r24,2
 1557 063e 0E94 0000 		call uxListRemove
2972:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 1559               	.LM182:
 1560 0642 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1561 0646 8150      		subi r24,lo8(-(-1))
 1562 0648 8093 0000 		sts uxCurrentNumberOfTasks,r24
2973:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 1564               	.LM183:
 1565 064c 8091 0000 		lds r24,uxTasksDeleted
 1566 0650 8150      		subi r24,lo8(-(-1))
 1567 0652 8093 0000 		sts uxTasksDeleted,r24
2975:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 1569               	.LM184:
 1570               	/* #APP */
 1571               	 ;  2975 "FreeRTOS/Source/tasks.c" 1
 1572 0656 0F90      		pop		__tmp_reg__
 1573               	 ;  0 "" 2
 1574               	 ;  2975 "FreeRTOS/Source/tasks.c" 1
 1575 0658 0FBE      		out		__SREG__, __tmp_reg__
 1576               	 ;  0 "" 2
 1577               	/* #NOAPP */
 1578               	.LBB43:
 1579               	.LBB44:
3255:FreeRTOS/Source/tasks.c **** 			vPortFreeAligned( pxTCB->pxStack );
 1581               	.LM185:
 1582 065a 8F89      		ldd r24,Y+23
 1583 065c 988D      		ldd r25,Y+24
 1584 065e 0E94 0000 		call vPortFree
3259:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 1586               	.LM186:
 1587 0662 CE01      		movw r24,r28
 1588 0664 0E94 0000 		call vPortFree
 1589               	.L109:
 1590               	.LBE44:
 1591               	.LBE43:
 1592               	.LBE42:
2956:FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 1594               	.LM187:
 1595 0668 8091 0000 		lds r24,uxTasksDeleted
 1596 066c 8111      		cpse r24,__zero_reg__
 1597 066e 00C0      		rjmp .L102
 1598               	.LBE41:
 1599               	.LBE40:
2684:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 1601               	.LM188:
 1602 0670 8091 0000 		lds r24,pxReadyTasksLists
 1603 0674 8230      		cpi r24,lo8(2)
 1604 0676 00F0      		brlo .L103
2686:FreeRTOS/Source/tasks.c **** 				taskYIELD();
 1606               	.LM189:
 1607 0678 0E94 0000 		call vPortYield
 1608               	.L103:
 1609               	.LBB45:
2704:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
 1611               	.LM190:
 1612 067c 0E94 0000 		call vApplicationIdleHook
 1613               	.LBE45:
2752:FreeRTOS/Source/tasks.c **** 	}
 1615               	.LM191:
 1616 0680 00C0      		rjmp .L109
 1621               	.Lscope13:
 1623               		.stabd	78,0,0
 1626               	.global	vTaskDelay
 1628               	vTaskDelay:
 1629               		.stabd	46,0,0
 919:FreeRTOS/Source/tasks.c **** 	{
 1631               	.LM192:
 1632               	.LFBB14:
 1633 0682 0F93      		push r16
 1634 0684 1F93      		push r17
 1635 0686 CF93      		push r28
 1636 0688 DF93      		push r29
 1637               	/* prologue: function */
 1638               	/* frame size = 0 */
 1639               	/* stack size = 4 */
 1640               	.L__stack_usage = 4
 1641 068a 8C01      		movw r16,r24
 925:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 1643               	.LM193:
 1644 068c 0097      		sbiw r24,0
 1645 068e 01F4      		brne .L111
 1646               	.L113:
 971:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1648               	.LM194:
 1649 0690 0E94 0000 		call vPortYield
 1650 0694 00C0      		rjmp .L110
 1651               	.L111:
 928:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 1653               	.LM195:
 1654 0696 0E94 0000 		call vTaskSuspendAll
 942:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1656               	.LM196:
 1657 069a C091 0000 		lds r28,xTickCount
 1658 069e D091 0000 		lds r29,xTickCount+1
 1659 06a2 C00F      		add r28,r16
 1660 06a4 D11F      		adc r29,r17
 947:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1662               	.LM197:
 1663 06a6 8091 0000 		lds r24,pxCurrentTCB
 1664 06aa 9091 0000 		lds r25,pxCurrentTCB+1
 1665 06ae 0296      		adiw r24,2
 1666 06b0 0E94 0000 		call uxListRemove
 958:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1668               	.LM198:
 1669 06b4 CE01      		movw r24,r28
 1670 06b6 0E94 0000 		call prvAddCurrentTaskToDelayedList
 960:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1672               	.LM199:
 1673 06ba 0E94 0000 		call xTaskResumeAll
 969:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1675               	.LM200:
 1676 06be 8823      		tst r24
 1677 06c0 01F0      		breq .L113
 1678               	.L110:
 1679               	/* epilogue start */
 977:FreeRTOS/Source/tasks.c **** 	}
 1681               	.LM201:
 1682 06c2 DF91      		pop r29
 1683 06c4 CF91      		pop r28
 1684 06c6 1F91      		pop r17
 1685 06c8 0F91      		pop r16
 1686 06ca 0895      		ret
 1691               	.Lscope14:
 1693               		.stabd	78,0,0
 1697               	.global	vTaskDelayUntil
 1699               	vTaskDelayUntil:
 1700               		.stabd	46,0,0
 823:FreeRTOS/Source/tasks.c **** 	{
 1702               	.LM202:
 1703               	.LFBB15:
 1704 06cc 0F93      		push r16
 1705 06ce 1F93      		push r17
 1706 06d0 CF93      		push r28
 1707 06d2 DF93      		push r29
 1708               	/* prologue: function */
 1709               	/* frame size = 0 */
 1710               	/* stack size = 4 */
 1711               	.L__stack_usage = 4
 1712 06d4 8C01      		movw r16,r24
 1713 06d6 EB01      		movw r28,r22
 831:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1715               	.LM203:
 1716 06d8 0E94 0000 		call vTaskSuspendAll
 1717               	.LBB46:
 835:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 1719               	.LM204:
 1720 06dc 4091 0000 		lds r20,xTickCount
 1721 06e0 5091 0000 		lds r21,xTickCount+1
 838:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1723               	.LM205:
 1724 06e4 F801      		movw r30,r16
 1725 06e6 2081      		ld r18,Z
 1726 06e8 3181      		ldd r19,Z+1
 1727 06ea C20F      		add r28,r18
 1728 06ec D31F      		adc r29,r19
 840:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 1730               	.LM206:
 1731 06ee 4217      		cp r20,r18
 1732 06f0 5307      		cpc r21,r19
 1733 06f2 00F4      		brsh .L118
 847:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1735               	.LM207:
 1736 06f4 C217      		cp r28,r18
 1737 06f6 D307      		cpc r29,r19
 1738 06f8 00F4      		brsh .L124
 847:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1740               	.LM208:
 1741 06fa 81E0      		ldi r24,lo8(1)
 1742 06fc 00C0      		rjmp .L131
 1743               	.L118:
 863:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 1745               	.LM209:
 1746 06fe 81E0      		ldi r24,lo8(1)
 861:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1748               	.LM210:
 1749 0700 C217      		cp r28,r18
 1750 0702 D307      		cpc r29,r19
 1751 0704 00F0      		brlo .L119
 1752               	.L131:
 861:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1754               	.LM211:
 1755 0706 4C17      		cp r20,r28
 1756 0708 5D07      		cpc r21,r29
 1757 070a 00F0      		brlo .L119
 1758               	.L124:
 825:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 1760               	.LM212:
 1761 070c 80E0      		ldi r24,0
 1762               	.L119:
 872:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1764               	.LM213:
 1765 070e F801      		movw r30,r16
 1766 0710 D183      		std Z+1,r29
 1767 0712 C083      		st Z,r28
 874:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1769               	.LM214:
 1770 0714 8823      		tst r24
 1771 0716 01F0      		breq .L122
 880:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1773               	.LM215:
 1774 0718 8091 0000 		lds r24,pxCurrentTCB
 1775 071c 9091 0000 		lds r25,pxCurrentTCB+1
 1776 0720 0296      		adiw r24,2
 1777 0722 0E94 0000 		call uxListRemove
 892:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1779               	.LM216:
 1780 0726 CE01      		movw r24,r28
 1781 0728 0E94 0000 		call prvAddCurrentTaskToDelayedList
 1782               	.L122:
 1783               	.LBE46:
 899:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1785               	.LM217:
 1786 072c 0E94 0000 		call xTaskResumeAll
 903:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1788               	.LM218:
 1789 0730 8111      		cpse r24,__zero_reg__
 1790 0732 00C0      		rjmp .L117
 905:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1792               	.LM219:
 1793 0734 0E94 0000 		call vPortYield
 1794               	.L117:
 1795               	/* epilogue start */
 911:FreeRTOS/Source/tasks.c **** 	}
 1797               	.LM220:
 1798 0738 DF91      		pop r29
 1799 073a CF91      		pop r28
 1800 073c 1F91      		pop r17
 1801 073e 0F91      		pop r16
 1802 0740 0895      		ret
 1811               	.Lscope15:
 1813               		.stabd	78,0,0
 1815               	.global	vTaskSwitchContext
 1817               	vTaskSwitchContext:
 1818               		.stabd	46,0,0
2199:FreeRTOS/Source/tasks.c **** {
 1820               	.LM221:
 1821               	.LFBB16:
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
 1824               	/* stack size = 0 */
 1825               	.L__stack_usage = 0
2200:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1827               	.LM222:
 1828 0742 8091 0000 		lds r24,uxSchedulerSuspended
 1829 0746 8823      		tst r24
 1830 0748 01F0      		breq .L133
2204:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 1832               	.LM223:
 1833 074a 81E0      		ldi r24,lo8(1)
 1834 074c 8093 0000 		sts xYieldPending,r24
 1835 0750 0895      		ret
 1836               	.L133:
2208:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
 1838               	.LM224:
 1839 0752 1092 0000 		sts xYieldPending,__zero_reg__
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1841               	.LM225:
 1842 0756 99E0      		ldi r25,lo8(9)
 1843 0758 00C0      		rjmp .L135
 1844               	.L136:
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1846               	.LM226:
 1847 075a 8091 0000 		lds r24,uxTopReadyPriority
 1848 075e 8150      		subi r24,lo8(-(-1))
 1849 0760 8093 0000 		sts uxTopReadyPriority,r24
 1850               	.L135:
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1852               	.LM227:
 1853 0764 E091 0000 		lds r30,uxTopReadyPriority
 1854 0768 9E9F      		mul r25,r30
 1855 076a F001      		movw r30,r0
 1856 076c 1124      		clr __zero_reg__
 1857 076e E050      		subi r30,lo8(-(pxReadyTasksLists))
 1858 0770 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1859 0772 8081      		ld r24,Z
 1860 0774 8823      		tst r24
 1861 0776 01F0      		breq .L136
 1862               	.LBB47:
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1864               	.LM228:
 1865 0778 E091 0000 		lds r30,uxTopReadyPriority
 1866 077c 89E0      		ldi r24,lo8(9)
 1867 077e E89F      		mul r30,r24
 1868 0780 F001      		movw r30,r0
 1869 0782 1124      		clr __zero_reg__
 1870 0784 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1871 0786 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1872 0788 A181      		ldd r26,Z+1
 1873 078a B281      		ldd r27,Z+2
 1874 078c 1296      		adiw r26,2
 1875 078e 0D90      		ld __tmp_reg__,X+
 1876 0790 BC91      		ld r27,X
 1877 0792 A02D      		mov r26,__tmp_reg__
 1878 0794 B283      		std Z+2,r27
 1879 0796 A183      		std Z+1,r26
 1880 0798 CF01      		movw r24,r30
 1881 079a 0396      		adiw r24,3
 1882 079c A817      		cp r26,r24
 1883 079e B907      		cpc r27,r25
 1884 07a0 01F4      		brne .L137
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1886               	.LM229:
 1887 07a2 1296      		adiw r26,2
 1888 07a4 8D91      		ld r24,X+
 1889 07a6 9C91      		ld r25,X
 1890 07a8 1397      		sbiw r26,2+1
 1891 07aa 9283      		std Z+2,r25
 1892 07ac 8183      		std Z+1,r24
 1893               	.L137:
2244:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 1895               	.LM230:
 1896 07ae 0180      		ldd __tmp_reg__,Z+1
 1897 07b0 F281      		ldd r31,Z+2
 1898 07b2 E02D      		mov r30,__tmp_reg__
 1899 07b4 8681      		ldd r24,Z+6
 1900 07b6 9781      		ldd r25,Z+7
 1901 07b8 9093 0000 		sts pxCurrentTCB+1,r25
 1902 07bc 8093 0000 		sts pxCurrentTCB,r24
 1903 07c0 0895      		ret
 1904               	.LBE47:
 1909               	.Lscope16:
 1911               		.stabd	78,0,0
 1915               	.global	vTaskPlaceOnEventList
 1917               	vTaskPlaceOnEventList:
 1918               		.stabd	46,0,0
2259:FreeRTOS/Source/tasks.c **** {
 1920               	.LM231:
 1921               	.LFBB17:
 1922 07c2 CF93      		push r28
 1923 07c4 DF93      		push r29
 1924               	/* prologue: function */
 1925               	/* frame size = 0 */
 1926               	/* stack size = 2 */
 1927               	.L__stack_usage = 2
 1928 07c6 EB01      		movw r28,r22
2271:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1930               	.LM232:
 1931 07c8 6091 0000 		lds r22,pxCurrentTCB
 1932 07cc 7091 0000 		lds r23,pxCurrentTCB+1
 1933 07d0 645F      		subi r22,-12
 1934 07d2 7F4F      		sbci r23,-1
 1935 07d4 0E94 0000 		call vListInsert
2276:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1937               	.LM233:
 1938 07d8 8091 0000 		lds r24,pxCurrentTCB
 1939 07dc 9091 0000 		lds r25,pxCurrentTCB+1
 1940 07e0 0296      		adiw r24,2
 1941 07e2 0E94 0000 		call uxListRemove
2310:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1943               	.LM234:
 1944 07e6 8091 0000 		lds r24,xTickCount
 1945 07ea 9091 0000 		lds r25,xTickCount+1
2311:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1947               	.LM235:
 1948 07ee 8C0F      		add r24,r28
 1949 07f0 9D1F      		adc r25,r29
 1950               	/* epilogue start */
2314:FreeRTOS/Source/tasks.c **** }
 1952               	.LM236:
 1953 07f2 DF91      		pop r29
 1954 07f4 CF91      		pop r28
2311:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1956               	.LM237:
 1957 07f6 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 1959               	.Lscope17:
 1961               		.stabd	78,0,0
 1966               	.global	vTaskPlaceOnUnorderedEventList
 1968               	vTaskPlaceOnUnorderedEventList:
 1969               		.stabd	46,0,0
2318:FreeRTOS/Source/tasks.c **** {
 1971               	.LM238:
 1972               	.LFBB18:
 1973 07fa CF93      		push r28
 1974 07fc DF93      		push r29
 1975               	/* prologue: function */
 1976               	/* frame size = 0 */
 1977               	/* stack size = 2 */
 1978               	.L__stack_usage = 2
 1979 07fe EA01      		movw r28,r20
2330:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 1981               	.LM239:
 1982 0800 E091 0000 		lds r30,pxCurrentTCB
 1983 0804 F091 0000 		lds r31,pxCurrentTCB+1
 1984 0808 7068      		ori r23,128
 1985 080a 7587      		std Z+13,r23
 1986 080c 6487      		std Z+12,r22
2337:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1988               	.LM240:
 1989 080e 6091 0000 		lds r22,pxCurrentTCB
 1990 0812 7091 0000 		lds r23,pxCurrentTCB+1
 1991 0816 645F      		subi r22,-12
 1992 0818 7F4F      		sbci r23,-1
 1993 081a 0E94 0000 		call vListInsertEnd
2342:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1995               	.LM241:
 1996 081e 8091 0000 		lds r24,pxCurrentTCB
 1997 0822 9091 0000 		lds r25,pxCurrentTCB+1
 1998 0826 0296      		adiw r24,2
 1999 0828 0E94 0000 		call uxListRemove
2376:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2001               	.LM242:
 2002 082c 8091 0000 		lds r24,xTickCount
 2003 0830 9091 0000 		lds r25,xTickCount+1
2377:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2005               	.LM243:
 2006 0834 8C0F      		add r24,r28
 2007 0836 9D1F      		adc r25,r29
 2008               	/* epilogue start */
2380:FreeRTOS/Source/tasks.c **** }
 2010               	.LM244:
 2011 0838 DF91      		pop r29
 2012 083a CF91      		pop r28
2377:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2014               	.LM245:
 2015 083c 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2017               	.Lscope18:
 2019               		.stabd	78,0,0
 2022               	.global	xTaskRemoveFromEventList
 2024               	xTaskRemoveFromEventList:
 2025               		.stabd	46,0,0
2429:FreeRTOS/Source/tasks.c **** {
 2027               	.LM246:
 2028               	.LFBB19:
 2029 0840 0F93      		push r16
 2030 0842 1F93      		push r17
 2031 0844 CF93      		push r28
 2032 0846 DF93      		push r29
 2033               	/* prologue: function */
 2034               	/* frame size = 0 */
 2035               	/* stack size = 4 */
 2036               	.L__stack_usage = 4
2446:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2038               	.LM247:
 2039 0848 DC01      		movw r26,r24
 2040 084a 1596      		adiw r26,5
 2041 084c ED91      		ld r30,X+
 2042 084e FC91      		ld r31,X
 2043 0850 1697      		sbiw r26,5+1
 2044 0852 C681      		ldd r28,Z+6
 2045 0854 D781      		ldd r29,Z+7
2448:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2047               	.LM248:
 2048 0856 8E01      		movw r16,r28
 2049 0858 045F      		subi r16,-12
 2050 085a 1F4F      		sbci r17,-1
 2051 085c C801      		movw r24,r16
 2052 085e 0E94 0000 		call uxListRemove
2450:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2054               	.LM249:
 2055 0862 8091 0000 		lds r24,uxSchedulerSuspended
 2056 0866 8111      		cpse r24,__zero_reg__
 2057 0868 00C0      		rjmp .L141
2452:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2059               	.LM250:
 2060 086a 8E01      		movw r16,r28
 2061 086c 0E5F      		subi r16,-2
 2062 086e 1F4F      		sbci r17,-1
 2063 0870 C801      		movw r24,r16
 2064 0872 0E94 0000 		call uxListRemove
2453:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2066               	.LM251:
 2067 0876 8E89      		ldd r24,Y+22
 2068 0878 9091 0000 		lds r25,uxTopReadyPriority
 2069 087c 9817      		cp r25,r24
 2070 087e 00F4      		brsh .L142
2453:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2072               	.LM252:
 2073 0880 8093 0000 		sts uxTopReadyPriority,r24
 2074               	.L142:
2453:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2076               	.LM253:
 2077 0884 B9E0      		ldi r27,lo8(9)
 2078 0886 8B9F      		mul r24,r27
 2079 0888 C001      		movw r24,r0
 2080 088a 1124      		clr __zero_reg__
 2081 088c B801      		movw r22,r16
 2082 088e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2083 0890 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2084 0892 00C0      		rjmp .L146
 2085               	.L141:
2459:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2087               	.LM254:
 2088 0894 B801      		movw r22,r16
 2089 0896 80E0      		ldi r24,lo8(xPendingReadyList)
 2090 0898 90E0      		ldi r25,hi8(xPendingReadyList)
 2091               	.L146:
 2092 089a 0E94 0000 		call vListInsertEnd
2462:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2094               	.LM255:
 2095 089e E091 0000 		lds r30,pxCurrentTCB
 2096 08a2 F091 0000 		lds r31,pxCurrentTCB+1
 2097 08a6 9E89      		ldd r25,Y+22
 2098 08a8 8689      		ldd r24,Z+22
 2099 08aa 8917      		cp r24,r25
 2100 08ac 00F4      		brsh .L145
2471:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 2102               	.LM256:
 2103 08ae 81E0      		ldi r24,lo8(1)
 2104 08b0 8093 0000 		sts xYieldPending,r24
 2105 08b4 00C0      		rjmp .L144
 2106               	.L145:
2475:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2108               	.LM257:
 2109 08b6 80E0      		ldi r24,0
 2110               	.L144:
 2111               	/* epilogue start */
2493:FreeRTOS/Source/tasks.c **** }
 2113               	.LM258:
 2114 08b8 DF91      		pop r29
 2115 08ba CF91      		pop r28
 2116 08bc 1F91      		pop r17
 2117 08be 0F91      		pop r16
 2118 08c0 0895      		ret
 2124               	.Lscope19:
 2126               		.stabd	78,0,0
 2130               	.global	xTaskRemoveFromUnorderedEventList
 2132               	xTaskRemoveFromUnorderedEventList:
 2133               		.stabd	46,0,0
2497:FreeRTOS/Source/tasks.c **** {
 2135               	.LM259:
 2136               	.LFBB20:
 2137 08c2 0F93      		push r16
 2138 08c4 1F93      		push r17
 2139 08c6 CF93      		push r28
 2140 08c8 DF93      		push r29
 2141               	/* prologue: function */
 2142               	/* frame size = 0 */
 2143               	/* stack size = 4 */
 2144               	.L__stack_usage = 4
2506:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2146               	.LM260:
 2147 08ca 7068      		ori r23,128
 2148 08cc FC01      		movw r30,r24
 2149 08ce 7183      		std Z+1,r23
 2150 08d0 6083      		st Z,r22
2510:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 2152               	.LM261:
 2153 08d2 C681      		ldd r28,Z+6
 2154 08d4 D781      		ldd r29,Z+7
2512:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 2156               	.LM262:
 2157 08d6 0E94 0000 		call uxListRemove
2517:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2159               	.LM263:
 2160 08da 8E01      		movw r16,r28
 2161 08dc 0E5F      		subi r16,-2
 2162 08de 1F4F      		sbci r17,-1
 2163 08e0 C801      		movw r24,r16
 2164 08e2 0E94 0000 		call uxListRemove
2518:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2166               	.LM264:
 2167 08e6 8E89      		ldd r24,Y+22
 2168 08e8 9091 0000 		lds r25,uxTopReadyPriority
 2169 08ec 9817      		cp r25,r24
 2170 08ee 00F4      		brsh .L148
2518:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2172               	.LM265:
 2173 08f0 8093 0000 		sts uxTopReadyPriority,r24
 2174               	.L148:
2518:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2176               	.LM266:
 2177 08f4 F9E0      		ldi r31,lo8(9)
 2178 08f6 8F9F      		mul r24,r31
 2179 08f8 C001      		movw r24,r0
 2180 08fa 1124      		clr __zero_reg__
 2181 08fc B801      		movw r22,r16
 2182 08fe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2183 0900 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2184 0902 0E94 0000 		call vListInsertEnd
2520:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2186               	.LM267:
 2187 0906 E091 0000 		lds r30,pxCurrentTCB
 2188 090a F091 0000 		lds r31,pxCurrentTCB+1
 2189 090e 9E89      		ldd r25,Y+22
 2190 0910 8689      		ldd r24,Z+22
 2191 0912 8917      		cp r24,r25
 2192 0914 00F4      		brsh .L150
2530:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 2194               	.LM268:
 2195 0916 81E0      		ldi r24,lo8(1)
 2196 0918 8093 0000 		sts xYieldPending,r24
 2197 091c 00C0      		rjmp .L149
 2198               	.L150:
2534:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2200               	.LM269:
 2201 091e 80E0      		ldi r24,0
 2202               	.L149:
 2203               	/* epilogue start */
2538:FreeRTOS/Source/tasks.c **** }
 2205               	.LM270:
 2206 0920 DF91      		pop r29
 2207 0922 CF91      		pop r28
 2208 0924 1F91      		pop r17
 2209 0926 0F91      		pop r16
 2210 0928 0895      		ret
 2216               	.Lscope20:
 2218               		.stabd	78,0,0
 2221               	.global	vTaskSetTimeOutState
 2223               	vTaskSetTimeOutState:
 2224               		.stabd	46,0,0
2542:FreeRTOS/Source/tasks.c **** {
 2226               	.LM271:
 2227               	.LFBB21:
 2228               	/* prologue: function */
 2229               	/* frame size = 0 */
 2230               	/* stack size = 0 */
 2231               	.L__stack_usage = 0
2544:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2233               	.LM272:
 2234 092a 2091 0000 		lds r18,xNumOfOverflows
 2235 092e FC01      		movw r30,r24
 2236 0930 2083      		st Z,r18
2545:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2238               	.LM273:
 2239 0932 2091 0000 		lds r18,xTickCount
 2240 0936 3091 0000 		lds r19,xTickCount+1
 2241 093a 3283      		std Z+2,r19
 2242 093c 2183      		std Z+1,r18
 2243 093e 0895      		ret
 2245               	.Lscope21:
 2247               		.stabd	78,0,0
 2251               	.global	xTaskCheckForTimeOut
 2253               	xTaskCheckForTimeOut:
 2254               		.stabd	46,0,0
2550:FreeRTOS/Source/tasks.c **** {
 2256               	.LM274:
 2257               	.LFBB22:
 2258               	/* prologue: function */
 2259               	/* frame size = 0 */
 2260               	/* stack size = 0 */
 2261               	.L__stack_usage = 0
2556:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2263               	.LM275:
 2264               	/* #APP */
 2265               	 ;  2556 "FreeRTOS/Source/tasks.c" 1
 2266 0940 0FB6      		in		__tmp_reg__, __SREG__
 2267               	 ;  0 "" 2
 2268               	 ;  2556 "FreeRTOS/Source/tasks.c" 1
 2269 0942 F894      		cli
 2270               	 ;  0 "" 2
 2271               	 ;  2556 "FreeRTOS/Source/tasks.c" 1
 2272 0944 0F92      		push	__tmp_reg__
 2273               	 ;  0 "" 2
 2274               	/* #NOAPP */
 2275               	.LBB48:
2559:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 2277               	.LM276:
 2278 0946 4091 0000 		lds r20,xTickCount
 2279 094a 5091 0000 		lds r21,xTickCount+1
2572:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2281               	.LM277:
 2282 094e F091 0000 		lds r31,xNumOfOverflows
 2283 0952 DC01      		movw r26,r24
 2284 0954 EC91      		ld r30,X
 2285 0956 1196      		adiw r26,1
 2286 0958 2D91      		ld r18,X+
 2287 095a 3C91      		ld r19,X
 2288 095c 1297      		sbiw r26,1+1
 2289 095e FE17      		cp r31,r30
 2290 0960 01F0      		breq .L153
2572:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2292               	.LM278:
 2293 0962 4217      		cp r20,r18
 2294 0964 5307      		cpc r21,r19
 2295 0966 00F4      		brsh .L156
 2296               	.L153:
2580:FreeRTOS/Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2298               	.LM279:
 2299 0968 DB01      		movw r26,r22
 2300 096a ED91      		ld r30,X+
 2301 096c FC91      		ld r31,X
 2302 096e DA01      		movw r26,r20
 2303 0970 A21B      		sub r26,r18
 2304 0972 B30B      		sbc r27,r19
 2305 0974 AE17      		cp r26,r30
 2306 0976 BF07      		cpc r27,r31
 2307 0978 00F4      		brsh .L156
2583:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2309               	.LM280:
 2310 097a 241B      		sub r18,r20
 2311 097c 350B      		sbc r19,r21
 2312 097e 2E0F      		add r18,r30
 2313 0980 3F1F      		adc r19,r31
 2314 0982 FB01      		movw r30,r22
 2315 0984 3183      		std Z+1,r19
 2316 0986 2083      		st Z,r18
2584:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2318               	.LM281:
 2319 0988 0E94 0000 		call vTaskSetTimeOutState
2585:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2321               	.LM282:
 2322 098c 80E0      		ldi r24,0
 2323 098e 00C0      		rjmp .L154
 2324               	.L156:
2578:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2326               	.LM283:
 2327 0990 81E0      		ldi r24,lo8(1)
 2328               	.L154:
 2329               	.LBE48:
2592:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2331               	.LM284:
 2332               	/* #APP */
 2333               	 ;  2592 "FreeRTOS/Source/tasks.c" 1
 2334 0992 0F90      		pop		__tmp_reg__
 2335               	 ;  0 "" 2
 2336               	 ;  2592 "FreeRTOS/Source/tasks.c" 1
 2337 0994 0FBE      		out		__SREG__, __tmp_reg__
 2338               	 ;  0 "" 2
2595:FreeRTOS/Source/tasks.c **** }
 2340               	.LM285:
 2341               	/* #NOAPP */
 2342 0996 0895      		ret
 2350               	.Lscope22:
 2352               		.stabd	78,0,0
 2354               	.global	vTaskMissedYield
 2356               	vTaskMissedYield:
 2357               		.stabd	46,0,0
2599:FreeRTOS/Source/tasks.c **** {
 2359               	.LM286:
 2360               	.LFBB23:
 2361               	/* prologue: function */
 2362               	/* frame size = 0 */
 2363               	/* stack size = 0 */
 2364               	.L__stack_usage = 0
2600:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2366               	.LM287:
 2367 0998 81E0      		ldi r24,lo8(1)
 2368 099a 8093 0000 		sts xYieldPending,r24
 2369 099e 0895      		ret
 2371               	.Lscope23:
 2373               		.stabd	78,0,0
 2375               	.global	uxTaskResetEventItemValue
 2377               	uxTaskResetEventItemValue:
 2378               		.stabd	46,0,0
3286:FreeRTOS/Source/tasks.c **** 	}
3287:FreeRTOS/Source/tasks.c **** }
3288:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3289:FreeRTOS/Source/tasks.c **** 
3290:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3291:FreeRTOS/Source/tasks.c **** 
3292:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3293:FreeRTOS/Source/tasks.c **** 	{
3294:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3295:FreeRTOS/Source/tasks.c **** 
3296:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3297:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3298:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3299:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3300:FreeRTOS/Source/tasks.c **** 
3301:FreeRTOS/Source/tasks.c **** 		return xReturn;
3302:FreeRTOS/Source/tasks.c **** 	}
3303:FreeRTOS/Source/tasks.c **** 
3304:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3305:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3306:FreeRTOS/Source/tasks.c **** 
3307:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3308:FreeRTOS/Source/tasks.c **** 
3309:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3310:FreeRTOS/Source/tasks.c **** 	{
3311:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3312:FreeRTOS/Source/tasks.c **** 
3313:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3314:FreeRTOS/Source/tasks.c **** 		{
3315:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3316:FreeRTOS/Source/tasks.c **** 		}
3317:FreeRTOS/Source/tasks.c **** 		else
3318:FreeRTOS/Source/tasks.c **** 		{
3319:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3320:FreeRTOS/Source/tasks.c **** 			{
3321:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3322:FreeRTOS/Source/tasks.c **** 			}
3323:FreeRTOS/Source/tasks.c **** 			else
3324:FreeRTOS/Source/tasks.c **** 			{
3325:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3326:FreeRTOS/Source/tasks.c **** 			}
3327:FreeRTOS/Source/tasks.c **** 		}
3328:FreeRTOS/Source/tasks.c **** 
3329:FreeRTOS/Source/tasks.c **** 		return xReturn;
3330:FreeRTOS/Source/tasks.c **** 	}
3331:FreeRTOS/Source/tasks.c **** 
3332:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3333:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3334:FreeRTOS/Source/tasks.c **** 
3335:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3336:FreeRTOS/Source/tasks.c **** 
3337:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3338:FreeRTOS/Source/tasks.c **** 	{
3339:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3340:FreeRTOS/Source/tasks.c **** 
3341:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3342:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3343:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3344:FreeRTOS/Source/tasks.c **** 		{
3345:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
3346:FreeRTOS/Source/tasks.c **** 			{
3347:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3348:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3349:FreeRTOS/Source/tasks.c **** 				not	being used for anything else. */
3350:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
3351:FreeRTOS/Source/tasks.c **** 				{
3352:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3353:FreeRTOS/Source/tasks.c **** 				}
3354:FreeRTOS/Source/tasks.c **** 				else
3355:FreeRTOS/Source/tasks.c **** 				{
3356:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3357:FreeRTOS/Source/tasks.c **** 				}
3358:FreeRTOS/Source/tasks.c **** 
3359:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
3360:FreeRTOS/Source/tasks.c **** 				be moved into a new list. */
3361:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
3362:FreeRTOS/Source/tasks.c **** 				{
3363:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
3364:FreeRTOS/Source/tasks.c **** 					{
3365:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3366:FreeRTOS/Source/tasks.c **** 					}
3367:FreeRTOS/Source/tasks.c **** 					else
3368:FreeRTOS/Source/tasks.c **** 					{
3369:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3370:FreeRTOS/Source/tasks.c **** 					}
3371:FreeRTOS/Source/tasks.c **** 
3372:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3373:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3374:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3375:FreeRTOS/Source/tasks.c **** 				}
3376:FreeRTOS/Source/tasks.c **** 				else
3377:FreeRTOS/Source/tasks.c **** 				{
3378:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3379:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3380:FreeRTOS/Source/tasks.c **** 				}
3381:FreeRTOS/Source/tasks.c **** 
3382:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3383:FreeRTOS/Source/tasks.c **** 			}
3384:FreeRTOS/Source/tasks.c **** 			else
3385:FreeRTOS/Source/tasks.c **** 			{
3386:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3387:FreeRTOS/Source/tasks.c **** 			}
3388:FreeRTOS/Source/tasks.c **** 		}
3389:FreeRTOS/Source/tasks.c **** 		else
3390:FreeRTOS/Source/tasks.c **** 		{
3391:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3392:FreeRTOS/Source/tasks.c **** 		}
3393:FreeRTOS/Source/tasks.c **** 	}
3394:FreeRTOS/Source/tasks.c **** 
3395:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3396:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3397:FreeRTOS/Source/tasks.c **** 
3398:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3399:FreeRTOS/Source/tasks.c **** 
3400:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3401:FreeRTOS/Source/tasks.c **** 	{
3402:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3403:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3404:FreeRTOS/Source/tasks.c **** 
3405:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3406:FreeRTOS/Source/tasks.c **** 		{
3407:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3408:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3409:FreeRTOS/Source/tasks.c **** 
3410:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3411:FreeRTOS/Source/tasks.c **** 			{
3412:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3413:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3414:FreeRTOS/Source/tasks.c **** 				{
3415:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inhertied priority if it holds
3416:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3417:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3418:FreeRTOS/Source/tasks.c **** 					holding	task then it must be the running state task.  Remove
3419:FreeRTOS/Source/tasks.c **** 					the	holding task from the ready	list. */
3420:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
3421:FreeRTOS/Source/tasks.c **** 					{
3422:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3423:FreeRTOS/Source/tasks.c **** 					}
3424:FreeRTOS/Source/tasks.c **** 					else
3425:FreeRTOS/Source/tasks.c **** 					{
3426:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3427:FreeRTOS/Source/tasks.c **** 					}
3428:FreeRTOS/Source/tasks.c **** 
3429:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3430:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3431:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3432:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3433:FreeRTOS/Source/tasks.c **** 
3434:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3435:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3436:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3437:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3438:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3439:FreeRTOS/Source/tasks.c **** 
3440:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3441:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
3442:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3443:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
3444:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
3445:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
3446:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
3447:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
3448:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3449:FreeRTOS/Source/tasks.c **** 				}
3450:FreeRTOS/Source/tasks.c **** 				else
3451:FreeRTOS/Source/tasks.c **** 				{
3452:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3453:FreeRTOS/Source/tasks.c **** 				}
3454:FreeRTOS/Source/tasks.c **** 			}
3455:FreeRTOS/Source/tasks.c **** 			else
3456:FreeRTOS/Source/tasks.c **** 			{
3457:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3458:FreeRTOS/Source/tasks.c **** 			}
3459:FreeRTOS/Source/tasks.c **** 		}
3460:FreeRTOS/Source/tasks.c **** 		else
3461:FreeRTOS/Source/tasks.c **** 		{
3462:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3463:FreeRTOS/Source/tasks.c **** 		}
3464:FreeRTOS/Source/tasks.c **** 
3465:FreeRTOS/Source/tasks.c **** 		return xReturn;
3466:FreeRTOS/Source/tasks.c **** 	}
3467:FreeRTOS/Source/tasks.c **** 
3468:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3469:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3470:FreeRTOS/Source/tasks.c **** 
3471:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3472:FreeRTOS/Source/tasks.c **** 
3473:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
3474:FreeRTOS/Source/tasks.c **** 	{
3475:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3476:FreeRTOS/Source/tasks.c **** 
3477:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3478:FreeRTOS/Source/tasks.c **** 		{
3479:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3480:FreeRTOS/Source/tasks.c **** 
3481:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3482:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
3483:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3484:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3485:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
3486:FreeRTOS/Source/tasks.c **** 			critical section. */
3487:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3488:FreeRTOS/Source/tasks.c **** 			{
3489:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
3490:FreeRTOS/Source/tasks.c **** 			}
3491:FreeRTOS/Source/tasks.c **** 
3492:FreeRTOS/Source/tasks.c **** 		}
3493:FreeRTOS/Source/tasks.c **** 		else
3494:FreeRTOS/Source/tasks.c **** 		{
3495:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3496:FreeRTOS/Source/tasks.c **** 		}
3497:FreeRTOS/Source/tasks.c **** 	}
3498:FreeRTOS/Source/tasks.c **** 
3499:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3500:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3501:FreeRTOS/Source/tasks.c **** 
3502:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3503:FreeRTOS/Source/tasks.c **** 
3504:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
3505:FreeRTOS/Source/tasks.c **** 	{
3506:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3507:FreeRTOS/Source/tasks.c **** 		{
3508:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3509:FreeRTOS/Source/tasks.c **** 			{
3510:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3511:FreeRTOS/Source/tasks.c **** 
3512:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3513:FreeRTOS/Source/tasks.c **** 				{
3514:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
3515:FreeRTOS/Source/tasks.c **** 				}
3516:FreeRTOS/Source/tasks.c **** 				else
3517:FreeRTOS/Source/tasks.c **** 				{
3518:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3519:FreeRTOS/Source/tasks.c **** 				}
3520:FreeRTOS/Source/tasks.c **** 			}
3521:FreeRTOS/Source/tasks.c **** 			else
3522:FreeRTOS/Source/tasks.c **** 			{
3523:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3524:FreeRTOS/Source/tasks.c **** 			}
3525:FreeRTOS/Source/tasks.c **** 		}
3526:FreeRTOS/Source/tasks.c **** 		else
3527:FreeRTOS/Source/tasks.c **** 		{
3528:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3529:FreeRTOS/Source/tasks.c **** 		}
3530:FreeRTOS/Source/tasks.c **** 	}
3531:FreeRTOS/Source/tasks.c **** 
3532:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3533:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3534:FreeRTOS/Source/tasks.c **** 
3535:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3536:FreeRTOS/Source/tasks.c **** 
3537:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3538:FreeRTOS/Source/tasks.c **** 	{
3539:FreeRTOS/Source/tasks.c **** 	BaseType_t x;
3540:FreeRTOS/Source/tasks.c **** 
3541:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
3542:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3543:FreeRTOS/Source/tasks.c **** 
3544:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3545:FreeRTOS/Source/tasks.c **** 		printed out. */
3546:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3547:FreeRTOS/Source/tasks.c **** 		{
3548:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
3549:FreeRTOS/Source/tasks.c **** 		}
3550:FreeRTOS/Source/tasks.c **** 
3551:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
3552:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = 0x00;
3553:FreeRTOS/Source/tasks.c **** 
3554:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
3555:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
3556:FreeRTOS/Source/tasks.c **** 	}
3557:FreeRTOS/Source/tasks.c **** 
3558:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3559:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3560:FreeRTOS/Source/tasks.c **** 
3561:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3562:FreeRTOS/Source/tasks.c **** 
3563:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3564:FreeRTOS/Source/tasks.c **** 	{
3565:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3566:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3567:FreeRTOS/Source/tasks.c **** 	char cStatus;
3568:FreeRTOS/Source/tasks.c **** 
3569:FreeRTOS/Source/tasks.c **** 		/*
3570:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3571:FreeRTOS/Source/tasks.c **** 		 *
3572:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3573:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3574:FreeRTOS/Source/tasks.c **** 		 * scheduler.
3575:FreeRTOS/Source/tasks.c **** 		 *
3576:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3577:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3578:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
3579:FreeRTOS/Source/tasks.c **** 		 *
3580:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3581:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3582:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3583:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3584:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3585:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3586:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
3587:FreeRTOS/Source/tasks.c **** 		 *
3588:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3589:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3590:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
3591:FreeRTOS/Source/tasks.c **** 		 */
3592:FreeRTOS/Source/tasks.c **** 
3593:FreeRTOS/Source/tasks.c **** 
3594:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3595:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3596:FreeRTOS/Source/tasks.c **** 
3597:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3598:FreeRTOS/Source/tasks.c **** 		function is executing. */
3599:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3600:FreeRTOS/Source/tasks.c **** 
3601:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3602:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3603:FreeRTOS/Source/tasks.c **** 
3604:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3605:FreeRTOS/Source/tasks.c **** 		{
3606:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3607:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3608:FreeRTOS/Source/tasks.c **** 
3609:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3610:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3611:FreeRTOS/Source/tasks.c **** 			{
3612:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3613:FreeRTOS/Source/tasks.c **** 				{
3614:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3615:FreeRTOS/Source/tasks.c **** 										break;
3616:FreeRTOS/Source/tasks.c **** 
3617:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3618:FreeRTOS/Source/tasks.c **** 										break;
3619:FreeRTOS/Source/tasks.c **** 
3620:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3621:FreeRTOS/Source/tasks.c **** 										break;
3622:FreeRTOS/Source/tasks.c **** 
3623:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
3624:FreeRTOS/Source/tasks.c **** 										break;
3625:FreeRTOS/Source/tasks.c **** 
3626:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
3627:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
3628:FreeRTOS/Source/tasks.c **** 										cStatus = 0x00;
3629:FreeRTOS/Source/tasks.c **** 										break;
3630:FreeRTOS/Source/tasks.c **** 				}
3631:FreeRTOS/Source/tasks.c **** 
3632:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
3633:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
3634:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3635:FreeRTOS/Source/tasks.c **** 
3636:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
3637:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
3638:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3639:FreeRTOS/Source/tasks.c **** 			}
3640:FreeRTOS/Source/tasks.c **** 
3641:FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3642:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3643:FreeRTOS/Source/tasks.c **** 		}
3644:FreeRTOS/Source/tasks.c **** 		else
3645:FreeRTOS/Source/tasks.c **** 		{
3646:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3647:FreeRTOS/Source/tasks.c **** 		}
3648:FreeRTOS/Source/tasks.c **** 	}
3649:FreeRTOS/Source/tasks.c **** 
3650:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3651:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
3652:FreeRTOS/Source/tasks.c **** 
3653:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3654:FreeRTOS/Source/tasks.c **** 
3655:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3656:FreeRTOS/Source/tasks.c **** 	{
3657:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3658:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3659:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3660:FreeRTOS/Source/tasks.c **** 
3661:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3662:FreeRTOS/Source/tasks.c **** 		{
3663:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3664:FreeRTOS/Source/tasks.c **** 		}
3665:FreeRTOS/Source/tasks.c **** 		#endif
3666:FreeRTOS/Source/tasks.c **** 
3667:FreeRTOS/Source/tasks.c **** 		/*
3668:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3669:FreeRTOS/Source/tasks.c **** 		 *
3670:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3671:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3672:FreeRTOS/Source/tasks.c **** 		 * scheduler.
3673:FreeRTOS/Source/tasks.c **** 		 *
3674:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3675:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3676:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3677:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
3678:FreeRTOS/Source/tasks.c **** 		 *
3679:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3680:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3681:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3682:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3683:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3684:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3685:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
3686:FreeRTOS/Source/tasks.c **** 		 *
3687:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3688:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3689:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3690:FreeRTOS/Source/tasks.c **** 		 */
3691:FreeRTOS/Source/tasks.c **** 
3692:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3693:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3694:FreeRTOS/Source/tasks.c **** 
3695:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3696:FreeRTOS/Source/tasks.c **** 		function is executing. */
3697:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3698:FreeRTOS/Source/tasks.c **** 
3699:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3700:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3701:FreeRTOS/Source/tasks.c **** 
3702:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3703:FreeRTOS/Source/tasks.c **** 		{
3704:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3705:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3706:FreeRTOS/Source/tasks.c **** 
3707:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
3708:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
3709:FreeRTOS/Source/tasks.c **** 
3710:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
3711:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0 )
3712:FreeRTOS/Source/tasks.c **** 			{
3713:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
3714:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3715:FreeRTOS/Source/tasks.c **** 				{
3716:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
3717:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
3718:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3719:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3720:FreeRTOS/Source/tasks.c **** 
3721:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
3722:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
3723:FreeRTOS/Source/tasks.c **** 					easily. */
3724:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3725:FreeRTOS/Source/tasks.c **** 
3726:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3727:FreeRTOS/Source/tasks.c **** 					{
3728:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3729:FreeRTOS/Source/tasks.c **** 						{
3730:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
3731:FreeRTOS/Source/tasks.c **** 						}
3732:FreeRTOS/Source/tasks.c **** 						#else
3733:FreeRTOS/Source/tasks.c **** 						{
3734:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3735:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3736:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3737:FreeRTOS/Source/tasks.c **** 						}
3738:FreeRTOS/Source/tasks.c **** 						#endif
3739:FreeRTOS/Source/tasks.c **** 					}
3740:FreeRTOS/Source/tasks.c **** 					else
3741:FreeRTOS/Source/tasks.c **** 					{
3742:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
3743:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
3744:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3745:FreeRTOS/Source/tasks.c **** 						{
3746:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
3747:FreeRTOS/Source/tasks.c **** 						}
3748:FreeRTOS/Source/tasks.c **** 						#else
3749:FreeRTOS/Source/tasks.c **** 						{
3750:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3751:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3752:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3753:FreeRTOS/Source/tasks.c **** 						}
3754:FreeRTOS/Source/tasks.c **** 						#endif
3755:FreeRTOS/Source/tasks.c **** 					}
3756:FreeRTOS/Source/tasks.c **** 
3757:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3758:FreeRTOS/Source/tasks.c **** 				}
3759:FreeRTOS/Source/tasks.c **** 			}
3760:FreeRTOS/Source/tasks.c **** 			else
3761:FreeRTOS/Source/tasks.c **** 			{
3762:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3763:FreeRTOS/Source/tasks.c **** 			}
3764:FreeRTOS/Source/tasks.c **** 
3765:FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3766:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3767:FreeRTOS/Source/tasks.c **** 		}
3768:FreeRTOS/Source/tasks.c **** 		else
3769:FreeRTOS/Source/tasks.c **** 		{
3770:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3771:FreeRTOS/Source/tasks.c **** 		}
3772:FreeRTOS/Source/tasks.c **** 	}
3773:FreeRTOS/Source/tasks.c **** 
3774:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
3775:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3776:FreeRTOS/Source/tasks.c **** 
3777:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3778:FreeRTOS/Source/tasks.c **** {
 2380               	.LM288:
 2381               	.LFBB24:
 2382               	/* prologue: function */
 2383               	/* frame size = 0 */
 2384               	/* stack size = 0 */
 2385               	.L__stack_usage = 0
3779:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
3780:FreeRTOS/Source/tasks.c **** 
3781:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 2387               	.LM289:
 2388 09a0 E091 0000 		lds r30,pxCurrentTCB
 2389 09a4 F091 0000 		lds r31,pxCurrentTCB+1
 2390 09a8 8485      		ldd r24,Z+12
 2391 09aa 9585      		ldd r25,Z+13
3782:FreeRTOS/Source/tasks.c **** 
3783:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3784:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
3785:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 2393               	.LM290:
 2394 09ac E091 0000 		lds r30,pxCurrentTCB
 2395 09b0 F091 0000 		lds r31,pxCurrentTCB+1
 2396 09b4 A091 0000 		lds r26,pxCurrentTCB
 2397 09b8 B091 0000 		lds r27,pxCurrentTCB+1
 2398 09bc 5696      		adiw r26,22
 2399 09be 4C91      		ld r20,X
 2400 09c0 24E0      		ldi r18,lo8(4)
 2401 09c2 30E0      		ldi r19,0
 2402 09c4 241B      		sub r18,r20
 2403 09c6 3109      		sbc r19,__zero_reg__
 2404 09c8 3587      		std Z+13,r19
 2405 09ca 2487      		std Z+12,r18
3786:FreeRTOS/Source/tasks.c **** 
3787:FreeRTOS/Source/tasks.c **** 	return uxReturn;
3788:FreeRTOS/Source/tasks.c **** }
 2407               	.LM291:
 2408 09cc 0895      		ret
 2410               	.Lscope24:
 2412               		.stabd	78,0,0
 2416               	.global	ulTaskNotifyTake
 2418               	ulTaskNotifyTake:
 2419               		.stabd	46,0,0
3789:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3790:FreeRTOS/Source/tasks.c **** 
3791:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
3794:FreeRTOS/Source/tasks.c **** 	{
3795:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3796:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
3797:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
3798:FreeRTOS/Source/tasks.c **** 		{
3799:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
3800:FreeRTOS/Source/tasks.c **** 		}
3801:FreeRTOS/Source/tasks.c **** 
3802:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
3803:FreeRTOS/Source/tasks.c **** 	}
3804:FreeRTOS/Source/tasks.c **** 
3805:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3806:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3807:FreeRTOS/Source/tasks.c **** 
3808:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
3809:FreeRTOS/Source/tasks.c **** 
3810:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
3811:FreeRTOS/Source/tasks.c **** 	{
 2421               	.LM292:
 2422               	.LFBB25:
 2423 09ce 0F93      		push r16
 2424 09d0 1F93      		push r17
 2425 09d2 CF93      		push r28
 2426               	/* prologue: function */
 2427               	/* frame size = 0 */
 2428               	/* stack size = 3 */
 2429               	.L__stack_usage = 3
 2430 09d4 C82F      		mov r28,r24
 2431 09d6 8B01      		movw r16,r22
3812:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
3813:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
3814:FreeRTOS/Source/tasks.c **** 
3815:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2433               	.LM293:
 2434               	/* #APP */
 2435               	 ;  3815 "FreeRTOS/Source/tasks.c" 1
 2436 09d8 0FB6      		in		__tmp_reg__, __SREG__
 2437               	 ;  0 "" 2
 2438               	 ;  3815 "FreeRTOS/Source/tasks.c" 1
 2439 09da F894      		cli
 2440               	 ;  0 "" 2
 2441               	 ;  3815 "FreeRTOS/Source/tasks.c" 1
 2442 09dc 0F92      		push	__tmp_reg__
 2443               	 ;  0 "" 2
3816:FreeRTOS/Source/tasks.c **** 		{
3817:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
3818:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 2445               	.LM294:
 2446               	/* #NOAPP */
 2447 09de E091 0000 		lds r30,pxCurrentTCB
 2448 09e2 F091 0000 		lds r31,pxCurrentTCB+1
 2449 09e6 41A1      		ldd r20,Z+33
 2450 09e8 52A1      		ldd r21,Z+34
 2451 09ea 63A1      		ldd r22,Z+35
 2452 09ec 74A1      		ldd r23,Z+36
 2453 09ee 452B      		or r20,r21
 2454 09f0 462B      		or r20,r22
 2455 09f2 472B      		or r20,r23
 2456 09f4 01F4      		brne .L161
3819:FreeRTOS/Source/tasks.c **** 			{
3820:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
3821:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 2458               	.LM295:
 2459 09f6 E091 0000 		lds r30,pxCurrentTCB
 2460 09fa F091 0000 		lds r31,pxCurrentTCB+1
 2461 09fe 81E0      		ldi r24,lo8(1)
 2462 0a00 85A3      		std Z+37,r24
3822:FreeRTOS/Source/tasks.c **** 
3823:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2464               	.LM296:
 2465 0a02 0115      		cp r16,__zero_reg__
 2466 0a04 1105      		cpc r17,__zero_reg__
 2467 0a06 01F0      		breq .L161
3824:FreeRTOS/Source/tasks.c **** 				{
3825:FreeRTOS/Source/tasks.c **** 					/* The task is going to block.  First it must be removed
3826:FreeRTOS/Source/tasks.c **** 					from the ready list. */
3827:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2469               	.LM297:
 2470 0a08 8091 0000 		lds r24,pxCurrentTCB
 2471 0a0c 9091 0000 		lds r25,pxCurrentTCB+1
 2472 0a10 0296      		adiw r24,2
 2473 0a12 0E94 0000 		call uxListRemove
3828:FreeRTOS/Source/tasks.c **** 					{
3829:FreeRTOS/Source/tasks.c **** 						/* The current task must be in a ready list, so there is
3830:FreeRTOS/Source/tasks.c **** 						no need to check, and the port reset macro can be called
3831:FreeRTOS/Source/tasks.c **** 						directly. */
3832:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
3833:FreeRTOS/Source/tasks.c **** 					}
3834:FreeRTOS/Source/tasks.c **** 					else
3835:FreeRTOS/Source/tasks.c **** 					{
3836:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3837:FreeRTOS/Source/tasks.c **** 					}
3838:FreeRTOS/Source/tasks.c **** 
3839:FreeRTOS/Source/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
3840:FreeRTOS/Source/tasks.c **** 					{
3841:FreeRTOS/Source/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
3842:FreeRTOS/Source/tasks.c **** 						{
3843:FreeRTOS/Source/tasks.c **** 							/* Add the task to the suspended task list instead
3844:FreeRTOS/Source/tasks.c **** 							of a delayed task list to ensure the task is not
3845:FreeRTOS/Source/tasks.c **** 							woken by a timing event.  It will block
3846:FreeRTOS/Source/tasks.c **** 							indefinitely. */
3847:FreeRTOS/Source/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3848:FreeRTOS/Source/tasks.c **** 						}
3849:FreeRTOS/Source/tasks.c **** 						else
3850:FreeRTOS/Source/tasks.c **** 						{
3851:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3852:FreeRTOS/Source/tasks.c **** 							woken if no notification events occur.  This may
3853:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3854:FreeRTOS/Source/tasks.c **** 							handle it. */
3855:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
3856:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
3857:FreeRTOS/Source/tasks.c **** 						}
3858:FreeRTOS/Source/tasks.c **** 					}
3859:FreeRTOS/Source/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
3860:FreeRTOS/Source/tasks.c **** 					{
3861:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3862:FreeRTOS/Source/tasks.c **** 							woken if the event does not occur.  This may
3863:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3864:FreeRTOS/Source/tasks.c **** 							handle it. */
3865:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
 2475               	.LM298:
 2476 0a16 8091 0000 		lds r24,xTickCount
 2477 0a1a 9091 0000 		lds r25,xTickCount+1
3866:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 2479               	.LM299:
 2480 0a1e 800F      		add r24,r16
 2481 0a20 911F      		adc r25,r17
 2482 0a22 0E94 0000 		call prvAddCurrentTaskToDelayedList
3867:FreeRTOS/Source/tasks.c **** 					}
3868:FreeRTOS/Source/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
3869:FreeRTOS/Source/tasks.c **** 
3870:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
3871:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
3872:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
3873:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
3874:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2484               	.LM300:
 2485 0a26 0E94 0000 		call vPortYield
 2486               	.L161:
3875:FreeRTOS/Source/tasks.c **** 				}
3876:FreeRTOS/Source/tasks.c **** 				else
3877:FreeRTOS/Source/tasks.c **** 				{
3878:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3879:FreeRTOS/Source/tasks.c **** 				}
3880:FreeRTOS/Source/tasks.c **** 			}
3881:FreeRTOS/Source/tasks.c **** 			else
3882:FreeRTOS/Source/tasks.c **** 			{
3883:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3884:FreeRTOS/Source/tasks.c **** 			}
3885:FreeRTOS/Source/tasks.c **** 		}
3886:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2488               	.LM301:
 2489               	/* #APP */
 2490               	 ;  3886 "FreeRTOS/Source/tasks.c" 1
 2491 0a2a 0F90      		pop		__tmp_reg__
 2492               	 ;  0 "" 2
 2493               	 ;  3886 "FreeRTOS/Source/tasks.c" 1
 2494 0a2c 0FBE      		out		__SREG__, __tmp_reg__
 2495               	 ;  0 "" 2
3887:FreeRTOS/Source/tasks.c **** 
3888:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2497               	.LM302:
 2498               	 ;  3888 "FreeRTOS/Source/tasks.c" 1
 2499 0a2e 0FB6      		in		__tmp_reg__, __SREG__
 2500               	 ;  0 "" 2
 2501               	 ;  3888 "FreeRTOS/Source/tasks.c" 1
 2502 0a30 F894      		cli
 2503               	 ;  0 "" 2
 2504               	 ;  3888 "FreeRTOS/Source/tasks.c" 1
 2505 0a32 0F92      		push	__tmp_reg__
 2506               	 ;  0 "" 2
3889:FreeRTOS/Source/tasks.c **** 		{
3890:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 2508               	.LM303:
 2509               	/* #NOAPP */
 2510 0a34 E091 0000 		lds r30,pxCurrentTCB
 2511 0a38 F091 0000 		lds r31,pxCurrentTCB+1
 2512 0a3c 01A1      		ldd r16,Z+33
 2513 0a3e 12A1      		ldd r17,Z+34
 2514 0a40 23A1      		ldd r18,Z+35
 2515 0a42 34A1      		ldd r19,Z+36
3891:FreeRTOS/Source/tasks.c **** 
3892:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
 2517               	.LM304:
 2518 0a44 0115      		cp r16,__zero_reg__
 2519 0a46 1105      		cpc r17,__zero_reg__
 2520 0a48 2105      		cpc r18,__zero_reg__
 2521 0a4a 3105      		cpc r19,__zero_reg__
 2522 0a4c 01F0      		breq .L163
3893:FreeRTOS/Source/tasks.c **** 			{
3894:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
3895:FreeRTOS/Source/tasks.c **** 				{
3896:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 2524               	.LM305:
 2525 0a4e E091 0000 		lds r30,pxCurrentTCB
 2526 0a52 F091 0000 		lds r31,pxCurrentTCB+1
3894:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 2528               	.LM306:
 2529 0a56 CC23      		tst r28
 2530 0a58 01F0      		breq .L164
 2532               	.LM307:
 2533 0a5a 11A2      		std Z+33,__zero_reg__
 2534 0a5c 12A2      		std Z+34,__zero_reg__
 2535 0a5e 13A2      		std Z+35,__zero_reg__
 2536 0a60 14A2      		std Z+36,__zero_reg__
 2537 0a62 00C0      		rjmp .L163
 2538               	.L164:
3897:FreeRTOS/Source/tasks.c **** 				}
3898:FreeRTOS/Source/tasks.c **** 				else
3899:FreeRTOS/Source/tasks.c **** 				{
3900:FreeRTOS/Source/tasks.c **** 					( pxCurrentTCB->ulNotifiedValue )--;
 2540               	.LM308:
 2541 0a64 81A1      		ldd r24,Z+33
 2542 0a66 92A1      		ldd r25,Z+34
 2543 0a68 A3A1      		ldd r26,Z+35
 2544 0a6a B4A1      		ldd r27,Z+36
 2545 0a6c 0197      		sbiw r24,1
 2546 0a6e A109      		sbc r26,__zero_reg__
 2547 0a70 B109      		sbc r27,__zero_reg__
 2548 0a72 81A3      		std Z+33,r24
 2549 0a74 92A3      		std Z+34,r25
 2550 0a76 A3A3      		std Z+35,r26
 2551 0a78 B4A3      		std Z+36,r27
 2552               	.L163:
3901:FreeRTOS/Source/tasks.c **** 				}
3902:FreeRTOS/Source/tasks.c **** 			}
3903:FreeRTOS/Source/tasks.c **** 			else
3904:FreeRTOS/Source/tasks.c **** 			{
3905:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3906:FreeRTOS/Source/tasks.c **** 			}
3907:FreeRTOS/Source/tasks.c **** 
3908:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 2554               	.LM309:
 2555 0a7a E091 0000 		lds r30,pxCurrentTCB
 2556 0a7e F091 0000 		lds r31,pxCurrentTCB+1
 2557 0a82 15A2      		std Z+37,__zero_reg__
3909:FreeRTOS/Source/tasks.c **** 		}
3910:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2559               	.LM310:
 2560               	/* #APP */
 2561               	 ;  3910 "FreeRTOS/Source/tasks.c" 1
 2562 0a84 0F90      		pop		__tmp_reg__
 2563               	 ;  0 "" 2
 2564               	 ;  3910 "FreeRTOS/Source/tasks.c" 1
 2565 0a86 0FBE      		out		__SREG__, __tmp_reg__
 2566               	 ;  0 "" 2
3911:FreeRTOS/Source/tasks.c **** 
3912:FreeRTOS/Source/tasks.c **** 		return ulReturn;
3913:FreeRTOS/Source/tasks.c **** 	}
 2568               	.LM311:
 2569               	/* #NOAPP */
 2570 0a88 B801      		movw r22,r16
 2571 0a8a C901      		movw r24,r18
 2572               	/* epilogue start */
 2573 0a8c CF91      		pop r28
 2574 0a8e 1F91      		pop r17
 2575 0a90 0F91      		pop r16
 2576 0a92 0895      		ret
 2581               	.Lscope25:
 2583               		.stabd	78,0,0
 2589               	.global	xTaskNotifyWait
 2591               	xTaskNotifyWait:
 2592               		.stabd	46,0,0
3914:FreeRTOS/Source/tasks.c **** 
3915:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
3916:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3917:FreeRTOS/Source/tasks.c **** 
3918:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
3919:FreeRTOS/Source/tasks.c **** 
3920:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
3921:FreeRTOS/Source/tasks.c **** 	{
 2594               	.LM312:
 2595               	.LFBB26:
 2596 0a94 4F92      		push r4
 2597 0a96 5F92      		push r5
 2598 0a98 6F92      		push r6
 2599 0a9a 7F92      		push r7
 2600 0a9c 8F92      		push r8
 2601 0a9e 9F92      		push r9
 2602 0aa0 AF92      		push r10
 2603 0aa2 BF92      		push r11
 2604 0aa4 EF92      		push r14
 2605 0aa6 FF92      		push r15
 2606 0aa8 0F93      		push r16
 2607 0aaa 1F93      		push r17
 2608 0aac CF93      		push r28
 2609 0aae DF93      		push r29
 2610 0ab0 00D0      		rcall .
 2611 0ab2 00D0      		rcall .
 2612 0ab4 CDB7      		in r28,__SP_L__
 2613 0ab6 DEB7      		in r29,__SP_H__
 2614               	/* prologue: function */
 2615               	/* frame size = 4 */
 2616               	/* stack size = 18 */
 2617               	.L__stack_usage = 18
3922:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
3923:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3924:FreeRTOS/Source/tasks.c **** 
3925:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2619               	.LM313:
 2620               	/* #APP */
 2621               	 ;  3925 "FreeRTOS/Source/tasks.c" 1
 2622 0ab8 0FB6      		in		__tmp_reg__, __SREG__
 2623               	 ;  0 "" 2
 2624               	 ;  3925 "FreeRTOS/Source/tasks.c" 1
 2625 0aba F894      		cli
 2626               	 ;  0 "" 2
 2627               	 ;  3925 "FreeRTOS/Source/tasks.c" 1
 2628 0abc 0F92      		push	__tmp_reg__
 2629               	 ;  0 "" 2
3926:FreeRTOS/Source/tasks.c **** 		{
3927:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
3928:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->eNotifyState != eNotified )
 2631               	.LM314:
 2632               	/* #NOAPP */
 2633 0abe E091 0000 		lds r30,pxCurrentTCB
 2634 0ac2 F091 0000 		lds r31,pxCurrentTCB+1
 2635 0ac6 E5A1      		ldd r30,Z+37
 2636 0ac8 E230      		cpi r30,lo8(2)
 2637 0aca 01F0      		breq .L173
3929:FreeRTOS/Source/tasks.c **** 			{
3930:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
3931:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
3932:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
3933:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 2639               	.LM315:
 2640 0acc E091 0000 		lds r30,pxCurrentTCB
 2641 0ad0 F091 0000 		lds r31,pxCurrentTCB+1
 2642 0ad4 41A0      		ldd r4,Z+33
 2643 0ad6 52A0      		ldd r5,Z+34
 2644 0ad8 63A0      		ldd r6,Z+35
 2645 0ada 74A0      		ldd r7,Z+36
 2646 0adc DC01      		movw r26,r24
 2647 0ade CB01      		movw r24,r22
 2648 0ae0 8095      		com r24
 2649 0ae2 9095      		com r25
 2650 0ae4 A095      		com r26
 2651 0ae6 B095      		com r27
 2652 0ae8 8421      		and r24,r4
 2653 0aea 9521      		and r25,r5
 2654 0aec A621      		and r26,r6
 2655 0aee B721      		and r27,r7
 2656 0af0 81A3      		std Z+33,r24
 2657 0af2 92A3      		std Z+34,r25
 2658 0af4 A3A3      		std Z+35,r26
 2659 0af6 B4A3      		std Z+36,r27
3934:FreeRTOS/Source/tasks.c **** 
3935:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
3936:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 2661               	.LM316:
 2662 0af8 E091 0000 		lds r30,pxCurrentTCB
 2663 0afc F091 0000 		lds r31,pxCurrentTCB+1
 2664 0b00 81E0      		ldi r24,lo8(1)
 2665 0b02 85A3      		std Z+37,r24
3937:FreeRTOS/Source/tasks.c **** 
3938:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2667               	.LM317:
 2668 0b04 E114      		cp r14,__zero_reg__
 2669 0b06 F104      		cpc r15,__zero_reg__
 2670 0b08 01F0      		breq .L173
3939:FreeRTOS/Source/tasks.c **** 				{
3940:FreeRTOS/Source/tasks.c **** 					/* The task is going to block.  First it must be removed
3941:FreeRTOS/Source/tasks.c **** 					from the	ready list. */
3942:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2672               	.LM318:
 2673 0b0a 8091 0000 		lds r24,pxCurrentTCB
 2674 0b0e 9091 0000 		lds r25,pxCurrentTCB+1
 2675 0b12 0296      		adiw r24,2
 2676 0b14 2983      		std Y+1,r18
 2677 0b16 3A83      		std Y+2,r19
 2678 0b18 4B83      		std Y+3,r20
 2679 0b1a 5C83      		std Y+4,r21
 2680 0b1c 0E94 0000 		call uxListRemove
3943:FreeRTOS/Source/tasks.c **** 					{
3944:FreeRTOS/Source/tasks.c **** 						/* The current task must be in a ready list, so there is
3945:FreeRTOS/Source/tasks.c **** 						no need to check, and the port reset macro can be called
3946:FreeRTOS/Source/tasks.c **** 						directly. */
3947:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
3948:FreeRTOS/Source/tasks.c **** 					}
3949:FreeRTOS/Source/tasks.c **** 					else
3950:FreeRTOS/Source/tasks.c **** 					{
3951:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3952:FreeRTOS/Source/tasks.c **** 					}
3953:FreeRTOS/Source/tasks.c **** 
3954:FreeRTOS/Source/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
3955:FreeRTOS/Source/tasks.c **** 					{
3956:FreeRTOS/Source/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
3957:FreeRTOS/Source/tasks.c **** 						{
3958:FreeRTOS/Source/tasks.c **** 							/* Add the task to the suspended task list instead
3959:FreeRTOS/Source/tasks.c **** 							of a delayed task list to ensure the task is not
3960:FreeRTOS/Source/tasks.c **** 							woken by a timing event.  It will block
3961:FreeRTOS/Source/tasks.c **** 							indefinitely. */
3962:FreeRTOS/Source/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3963:FreeRTOS/Source/tasks.c **** 						}
3964:FreeRTOS/Source/tasks.c **** 						else
3965:FreeRTOS/Source/tasks.c **** 						{
3966:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3967:FreeRTOS/Source/tasks.c **** 							woken if no notification events occur.  This may
3968:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3969:FreeRTOS/Source/tasks.c **** 							handle it. */
3970:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
3971:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
3972:FreeRTOS/Source/tasks.c **** 						}
3973:FreeRTOS/Source/tasks.c **** 					}
3974:FreeRTOS/Source/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
3975:FreeRTOS/Source/tasks.c **** 					{
3976:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3977:FreeRTOS/Source/tasks.c **** 							woken if the event does not occur.  This may
3978:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3979:FreeRTOS/Source/tasks.c **** 							handle it. */
3980:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
 2682               	.LM319:
 2683 0b20 8091 0000 		lds r24,xTickCount
 2684 0b24 9091 0000 		lds r25,xTickCount+1
3981:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 2686               	.LM320:
 2687 0b28 8E0D      		add r24,r14
 2688 0b2a 9F1D      		adc r25,r15
 2689 0b2c 0E94 0000 		call prvAddCurrentTaskToDelayedList
3982:FreeRTOS/Source/tasks.c **** 					}
3983:FreeRTOS/Source/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
3984:FreeRTOS/Source/tasks.c **** 
3985:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
3986:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
3987:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
3988:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
3989:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2691               	.LM321:
 2692 0b30 0E94 0000 		call vPortYield
 2693 0b34 5C81      		ldd r21,Y+4
 2694 0b36 4B81      		ldd r20,Y+3
 2695 0b38 3A81      		ldd r19,Y+2
 2696 0b3a 2981      		ldd r18,Y+1
 2697               	.L173:
3990:FreeRTOS/Source/tasks.c **** 				}
3991:FreeRTOS/Source/tasks.c **** 				else
3992:FreeRTOS/Source/tasks.c **** 				{
3993:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3994:FreeRTOS/Source/tasks.c **** 				}
3995:FreeRTOS/Source/tasks.c **** 			}
3996:FreeRTOS/Source/tasks.c **** 			else
3997:FreeRTOS/Source/tasks.c **** 			{
3998:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3999:FreeRTOS/Source/tasks.c **** 			}
4000:FreeRTOS/Source/tasks.c **** 		}
4001:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2699               	.LM322:
 2700               	/* #APP */
 2701               	 ;  4001 "FreeRTOS/Source/tasks.c" 1
 2702 0b3c 0F90      		pop		__tmp_reg__
 2703               	 ;  0 "" 2
 2704               	 ;  4001 "FreeRTOS/Source/tasks.c" 1
 2705 0b3e 0FBE      		out		__SREG__, __tmp_reg__
 2706               	 ;  0 "" 2
4002:FreeRTOS/Source/tasks.c **** 
4003:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2708               	.LM323:
 2709               	 ;  4003 "FreeRTOS/Source/tasks.c" 1
 2710 0b40 0FB6      		in		__tmp_reg__, __SREG__
 2711               	 ;  0 "" 2
 2712               	 ;  4003 "FreeRTOS/Source/tasks.c" 1
 2713 0b42 F894      		cli
 2714               	 ;  0 "" 2
 2715               	 ;  4003 "FreeRTOS/Source/tasks.c" 1
 2716 0b44 0F92      		push	__tmp_reg__
 2717               	 ;  0 "" 2
4004:FreeRTOS/Source/tasks.c **** 		{
4005:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
 2719               	.LM324:
 2720               	/* #NOAPP */
 2721 0b46 0115      		cp r16,__zero_reg__
 2722 0b48 1105      		cpc r17,__zero_reg__
 2723 0b4a 01F0      		breq .L175
4006:FreeRTOS/Source/tasks.c **** 			{
4007:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4008:FreeRTOS/Source/tasks.c **** 				have changed. */
4009:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 2725               	.LM325:
 2726 0b4c E091 0000 		lds r30,pxCurrentTCB
 2727 0b50 F091 0000 		lds r31,pxCurrentTCB+1
 2728 0b54 81A1      		ldd r24,Z+33
 2729 0b56 92A1      		ldd r25,Z+34
 2730 0b58 A3A1      		ldd r26,Z+35
 2731 0b5a B4A1      		ldd r27,Z+36
 2732 0b5c F801      		movw r30,r16
 2733 0b5e 8083      		st Z,r24
 2734 0b60 9183      		std Z+1,r25
 2735 0b62 A283      		std Z+2,r26
 2736 0b64 B383      		std Z+3,r27
 2737               	.L175:
4010:FreeRTOS/Source/tasks.c **** 			}
4011:FreeRTOS/Source/tasks.c **** 
4012:FreeRTOS/Source/tasks.c **** 			/* If eNotifyValue is set then either the task never entered the
4013:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4014:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4015:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4016:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
 2739               	.LM326:
 2740 0b66 E091 0000 		lds r30,pxCurrentTCB
 2741 0b6a F091 0000 		lds r31,pxCurrentTCB+1
 2742 0b6e 85A1      		ldd r24,Z+37
 2743 0b70 8130      		cpi r24,lo8(1)
 2744 0b72 01F0      		breq .L177
4017:FreeRTOS/Source/tasks.c **** 			{
4018:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4019:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4020:FreeRTOS/Source/tasks.c **** 			}
4021:FreeRTOS/Source/tasks.c **** 			else
4022:FreeRTOS/Source/tasks.c **** 			{
4023:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4024:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4025:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 2746               	.LM327:
 2747 0b74 E091 0000 		lds r30,pxCurrentTCB
 2748 0b78 F091 0000 		lds r31,pxCurrentTCB+1
 2749 0b7c 81A0      		ldd r8,Z+33
 2750 0b7e 92A0      		ldd r9,Z+34
 2751 0b80 A3A0      		ldd r10,Z+35
 2752 0b82 B4A0      		ldd r11,Z+36
 2753 0b84 DA01      		movw r26,r20
 2754 0b86 C901      		movw r24,r18
 2755 0b88 8095      		com r24
 2756 0b8a 9095      		com r25
 2757 0b8c A095      		com r26
 2758 0b8e B095      		com r27
 2759 0b90 8821      		and r24,r8
 2760 0b92 9921      		and r25,r9
 2761 0b94 AA21      		and r26,r10
 2762 0b96 BB21      		and r27,r11
 2763 0b98 81A3      		std Z+33,r24
 2764 0b9a 92A3      		std Z+34,r25
 2765 0b9c A3A3      		std Z+35,r26
 2766 0b9e B4A3      		std Z+36,r27
4026:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 2768               	.LM328:
 2769 0ba0 81E0      		ldi r24,lo8(1)
 2770 0ba2 00C0      		rjmp .L176
 2771               	.L177:
4019:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2773               	.LM329:
 2774 0ba4 80E0      		ldi r24,0
 2775               	.L176:
4027:FreeRTOS/Source/tasks.c **** 			}
4028:FreeRTOS/Source/tasks.c **** 
4029:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 2777               	.LM330:
 2778 0ba6 E091 0000 		lds r30,pxCurrentTCB
 2779 0baa F091 0000 		lds r31,pxCurrentTCB+1
 2780 0bae 15A2      		std Z+37,__zero_reg__
4030:FreeRTOS/Source/tasks.c **** 		}
4031:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2782               	.LM331:
 2783               	/* #APP */
 2784               	 ;  4031 "FreeRTOS/Source/tasks.c" 1
 2785 0bb0 0F90      		pop		__tmp_reg__
 2786               	 ;  0 "" 2
 2787               	 ;  4031 "FreeRTOS/Source/tasks.c" 1
 2788 0bb2 0FBE      		out		__SREG__, __tmp_reg__
 2789               	 ;  0 "" 2
 2790               	/* epilogue start */
4032:FreeRTOS/Source/tasks.c **** 
4033:FreeRTOS/Source/tasks.c **** 		return xReturn;
4034:FreeRTOS/Source/tasks.c **** 	}
 2792               	.LM332:
 2793               	/* #NOAPP */
 2794 0bb4 0F90      		pop __tmp_reg__
 2795 0bb6 0F90      		pop __tmp_reg__
 2796 0bb8 0F90      		pop __tmp_reg__
 2797 0bba 0F90      		pop __tmp_reg__
 2798 0bbc DF91      		pop r29
 2799 0bbe CF91      		pop r28
 2800 0bc0 1F91      		pop r17
 2801 0bc2 0F91      		pop r16
 2802 0bc4 FF90      		pop r15
 2803 0bc6 EF90      		pop r14
 2804 0bc8 BF90      		pop r11
 2805 0bca AF90      		pop r10
 2806 0bcc 9F90      		pop r9
 2807 0bce 8F90      		pop r8
 2808 0bd0 7F90      		pop r7
 2809 0bd2 6F90      		pop r6
 2810 0bd4 5F90      		pop r5
 2811 0bd6 4F90      		pop r4
 2812 0bd8 0895      		ret
 2817               	.Lscope26:
 2819               		.stabd	78,0,0
 2824               	.global	xTaskNotify
 2826               	xTaskNotify:
 2827               		.stabd	46,0,0
4035:FreeRTOS/Source/tasks.c **** 
4036:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4037:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4038:FreeRTOS/Source/tasks.c **** 
4039:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4040:FreeRTOS/Source/tasks.c **** 
4041:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction )
4042:FreeRTOS/Source/tasks.c **** 	{
 2829               	.LM333:
 2830               	.LFBB27:
 2831 0bda 0F93      		push r16
 2832 0bdc 1F93      		push r17
 2833 0bde CF93      		push r28
 2834 0be0 DF93      		push r29
 2835               	/* prologue: function */
 2836               	/* frame size = 0 */
 2837               	/* stack size = 4 */
 2838               	.L__stack_usage = 4
 2839 0be2 EC01      		movw r28,r24
4043:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4044:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4045:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4046:FreeRTOS/Source/tasks.c **** 
4047:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4048:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4049:FreeRTOS/Source/tasks.c **** 
4050:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2841               	.LM334:
 2842               	/* #APP */
 2843               	 ;  4050 "FreeRTOS/Source/tasks.c" 1
 2844 0be4 0FB6      		in		__tmp_reg__, __SREG__
 2845               	 ;  0 "" 2
 2846               	 ;  4050 "FreeRTOS/Source/tasks.c" 1
 2847 0be6 F894      		cli
 2848               	 ;  0 "" 2
 2849               	 ;  4050 "FreeRTOS/Source/tasks.c" 1
 2850 0be8 0F92      		push	__tmp_reg__
 2851               	 ;  0 "" 2
4051:FreeRTOS/Source/tasks.c **** 		{
4052:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 2853               	.LM335:
 2854               	/* #NOAPP */
 2855 0bea 3DA1      		ldd r19,Y+37
4053:FreeRTOS/Source/tasks.c **** 
4054:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 2857               	.LM336:
 2858 0bec 82E0      		ldi r24,lo8(2)
 2859 0bee 8DA3      		std Y+37,r24
4055:FreeRTOS/Source/tasks.c **** 
4056:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 2861               	.LM337:
 2862 0bf0 2230      		cpi r18,lo8(2)
 2863 0bf2 01F0      		breq .L187
 2864 0bf4 00F4      		brsh .L190
 2865 0bf6 2130      		cpi r18,lo8(1)
 2866 0bf8 01F4      		brne .L185
 2867 0bfa 00C0      		rjmp .L186
 2868               	.L190:
 2869 0bfc 2330      		cpi r18,lo8(3)
 2870 0bfe 01F0      		breq .L196
 2871 0c00 2430      		cpi r18,lo8(4)
 2872 0c02 01F4      		brne .L185
 2873 0c04 00C0      		rjmp .L189
 2874               	.L186:
4057:FreeRTOS/Source/tasks.c **** 			{
4058:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4059:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 2876               	.LM338:
 2877 0c06 89A1      		ldd r24,Y+33
 2878 0c08 9AA1      		ldd r25,Y+34
 2879 0c0a ABA1      		ldd r26,Y+35
 2880 0c0c BCA1      		ldd r27,Y+36
 2881 0c0e 842B      		or r24,r20
 2882 0c10 952B      		or r25,r21
 2883 0c12 A62B      		or r26,r22
 2884 0c14 B72B      		or r27,r23
 2885 0c16 89A3      		std Y+33,r24
 2886 0c18 9AA3      		std Y+34,r25
 2887 0c1a ABA3      		std Y+35,r26
 2888 0c1c BCA3      		std Y+36,r27
4060:FreeRTOS/Source/tasks.c **** 					break;
 2890               	.LM339:
 2891 0c1e 00C0      		rjmp .L185
 2892               	.L187:
4061:FreeRTOS/Source/tasks.c **** 
4062:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4063:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 2894               	.LM340:
 2895 0c20 49A1      		ldd r20,Y+33
 2896 0c22 5AA1      		ldd r21,Y+34
 2897 0c24 6BA1      		ldd r22,Y+35
 2898 0c26 7CA1      		ldd r23,Y+36
 2899 0c28 4F5F      		subi r20,-1
 2900 0c2a 5F4F      		sbci r21,-1
 2901 0c2c 6F4F      		sbci r22,-1
 2902 0c2e 7F4F      		sbci r23,-1
 2903 0c30 00C0      		rjmp .L196
 2904               	.L189:
4064:FreeRTOS/Source/tasks.c **** 					break;
4065:FreeRTOS/Source/tasks.c **** 
4066:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4067:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4068:FreeRTOS/Source/tasks.c **** 					break;
4069:FreeRTOS/Source/tasks.c **** 
4070:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4071:FreeRTOS/Source/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 2906               	.LM341:
 2907 0c32 3230      		cpi r19,lo8(2)
 2908 0c34 01F0      		breq .L195
 2909               	.L196:
4072:FreeRTOS/Source/tasks.c **** 					{
4073:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 2911               	.LM342:
 2912 0c36 49A3      		std Y+33,r20
 2913 0c38 5AA3      		std Y+34,r21
 2914 0c3a 6BA3      		std Y+35,r22
 2915 0c3c 7CA3      		std Y+36,r23
 2916               	.L185:
4074:FreeRTOS/Source/tasks.c **** 					}
4075:FreeRTOS/Source/tasks.c **** 					else
4076:FreeRTOS/Source/tasks.c **** 					{
4077:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4078:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4079:FreeRTOS/Source/tasks.c **** 					}
4080:FreeRTOS/Source/tasks.c **** 					break;
4081:FreeRTOS/Source/tasks.c **** 
4082:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4083:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4084:FreeRTOS/Source/tasks.c **** 					updated. */
4085:FreeRTOS/Source/tasks.c **** 					break;
4086:FreeRTOS/Source/tasks.c **** 			}
4087:FreeRTOS/Source/tasks.c **** 
4088:FreeRTOS/Source/tasks.c **** 
4089:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4090:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4091:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 2918               	.LM343:
 2919 0c3e 3130      		cpi r19,lo8(1)
 2920 0c40 01F0      		breq .L192
 2921 0c42 00C0      		rjmp .L197
 2922               	.L192:
4092:FreeRTOS/Source/tasks.c **** 			{
4093:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2924               	.LM344:
 2925 0c44 8E01      		movw r16,r28
 2926 0c46 0E5F      		subi r16,-2
 2927 0c48 1F4F      		sbci r17,-1
 2928 0c4a C801      		movw r24,r16
 2929 0c4c 0E94 0000 		call uxListRemove
4094:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 2931               	.LM345:
 2932 0c50 8E89      		ldd r24,Y+22
 2933 0c52 9091 0000 		lds r25,uxTopReadyPriority
 2934 0c56 9817      		cp r25,r24
 2935 0c58 00F4      		brsh .L193
 2937               	.LM346:
 2938 0c5a 8093 0000 		sts uxTopReadyPriority,r24
 2939               	.L193:
 2941               	.LM347:
 2942 0c5e 29E0      		ldi r18,lo8(9)
 2943 0c60 829F      		mul r24,r18
 2944 0c62 C001      		movw r24,r0
 2945 0c64 1124      		clr __zero_reg__
 2946 0c66 B801      		movw r22,r16
 2947 0c68 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2948 0c6a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2949 0c6c 0E94 0000 		call vListInsertEnd
4095:FreeRTOS/Source/tasks.c **** 
4096:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4097:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4098:FreeRTOS/Source/tasks.c **** 
4099:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2951               	.LM348:
 2952 0c70 E091 0000 		lds r30,pxCurrentTCB
 2953 0c74 F091 0000 		lds r31,pxCurrentTCB+1
 2954 0c78 9E89      		ldd r25,Y+22
 2955 0c7a 8689      		ldd r24,Z+22
 2956 0c7c 8917      		cp r24,r25
 2957 0c7e 00F4      		brsh .L197
4100:FreeRTOS/Source/tasks.c **** 				{
4101:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4102:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4103:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 2959               	.LM349:
 2960 0c80 0E94 0000 		call vPortYield
 2961               	.L197:
 2962 0c84 81E0      		ldi r24,lo8(1)
 2963 0c86 00C0      		rjmp .L191
 2964               	.L195:
4078:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
 2966               	.LM350:
 2967 0c88 80E0      		ldi r24,0
 2968               	.L191:
4104:FreeRTOS/Source/tasks.c **** 				}
4105:FreeRTOS/Source/tasks.c **** 				else
4106:FreeRTOS/Source/tasks.c **** 				{
4107:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4108:FreeRTOS/Source/tasks.c **** 				}
4109:FreeRTOS/Source/tasks.c **** 			}
4110:FreeRTOS/Source/tasks.c **** 			else
4111:FreeRTOS/Source/tasks.c **** 			{
4112:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4113:FreeRTOS/Source/tasks.c **** 			}
4114:FreeRTOS/Source/tasks.c **** 		}
4115:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2970               	.LM351:
 2971               	/* #APP */
 2972               	 ;  4115 "FreeRTOS/Source/tasks.c" 1
 2973 0c8a 0F90      		pop		__tmp_reg__
 2974               	 ;  0 "" 2
 2975               	 ;  4115 "FreeRTOS/Source/tasks.c" 1
 2976 0c8c 0FBE      		out		__SREG__, __tmp_reg__
 2977               	 ;  0 "" 2
 2978               	/* epilogue start */
4116:FreeRTOS/Source/tasks.c **** 
4117:FreeRTOS/Source/tasks.c **** 		return xReturn;
4118:FreeRTOS/Source/tasks.c **** 	}
 2980               	.LM352:
 2981               	/* #NOAPP */
 2982 0c8e DF91      		pop r29
 2983 0c90 CF91      		pop r28
 2984 0c92 1F91      		pop r17
 2985 0c94 0F91      		pop r16
 2986 0c96 0895      		ret
 2992               	.Lscope27:
 2994               		.stabd	78,0,0
 3000               	.global	xTaskNotifyFromISR
 3002               	xTaskNotifyFromISR:
 3003               		.stabd	46,0,0
4119:FreeRTOS/Source/tasks.c **** 
4120:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4121:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4122:FreeRTOS/Source/tasks.c **** 
4123:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4124:FreeRTOS/Source/tasks.c **** 
4125:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4126:FreeRTOS/Source/tasks.c **** 	{
 3005               	.LM353:
 3006               	.LFBB28:
 3007 0c98 EF92      		push r14
 3008 0c9a FF92      		push r15
 3009 0c9c 0F93      		push r16
 3010 0c9e 1F93      		push r17
 3011 0ca0 CF93      		push r28
 3012 0ca2 DF93      		push r29
 3013               	/* prologue: function */
 3014               	/* frame size = 0 */
 3015               	/* stack size = 6 */
 3016               	.L__stack_usage = 6
 3017 0ca4 EC01      		movw r28,r24
4127:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4128:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4129:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4130:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4131:FreeRTOS/Source/tasks.c **** 
4132:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4133:FreeRTOS/Source/tasks.c **** 
4134:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4135:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4136:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4137:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4138:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4139:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4140:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4141:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4142:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4143:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4144:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4145:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4146:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4147:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4148:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4149:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4150:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4151:FreeRTOS/Source/tasks.c **** 
4152:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4153:FreeRTOS/Source/tasks.c **** 
4154:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4155:FreeRTOS/Source/tasks.c **** 		{
4156:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 3019               	.LM354:
 3020 0ca6 3DA1      		ldd r19,Y+37
4157:FreeRTOS/Source/tasks.c **** 
4158:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3022               	.LM355:
 3023 0ca8 82E0      		ldi r24,lo8(2)
 3024 0caa 8DA3      		std Y+37,r24
4159:FreeRTOS/Source/tasks.c **** 
4160:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 3026               	.LM356:
 3027 0cac 2230      		cpi r18,lo8(2)
 3028 0cae 01F0      		breq .L201
 3029 0cb0 00F4      		brsh .L204
 3030 0cb2 2130      		cpi r18,lo8(1)
 3031 0cb4 01F4      		brne .L199
 3032 0cb6 00C0      		rjmp .L200
 3033               	.L204:
 3034 0cb8 2330      		cpi r18,lo8(3)
 3035 0cba 01F0      		breq .L216
 3036 0cbc 2430      		cpi r18,lo8(4)
 3037 0cbe 01F4      		brne .L199
 3038 0cc0 00C0      		rjmp .L203
 3039               	.L200:
4161:FreeRTOS/Source/tasks.c **** 			{
4162:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4163:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 3041               	.LM357:
 3042 0cc2 89A1      		ldd r24,Y+33
 3043 0cc4 9AA1      		ldd r25,Y+34
 3044 0cc6 ABA1      		ldd r26,Y+35
 3045 0cc8 BCA1      		ldd r27,Y+36
 3046 0cca 842B      		or r24,r20
 3047 0ccc 952B      		or r25,r21
 3048 0cce A62B      		or r26,r22
 3049 0cd0 B72B      		or r27,r23
 3050 0cd2 00C0      		rjmp .L215
 3051               	.L201:
4164:FreeRTOS/Source/tasks.c **** 					break;
4165:FreeRTOS/Source/tasks.c **** 
4166:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4167:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 3053               	.LM358:
 3054 0cd4 89A1      		ldd r24,Y+33
 3055 0cd6 9AA1      		ldd r25,Y+34
 3056 0cd8 ABA1      		ldd r26,Y+35
 3057 0cda BCA1      		ldd r27,Y+36
 3058 0cdc 0196      		adiw r24,1
 3059 0cde A11D      		adc r26,__zero_reg__
 3060 0ce0 B11D      		adc r27,__zero_reg__
 3061               	.L215:
 3062 0ce2 89A3      		std Y+33,r24
 3063 0ce4 9AA3      		std Y+34,r25
 3064 0ce6 ABA3      		std Y+35,r26
 3065 0ce8 BCA3      		std Y+36,r27
4168:FreeRTOS/Source/tasks.c **** 					break;
 3067               	.LM359:
 3068 0cea 00C0      		rjmp .L199
 3069               	.L203:
4169:FreeRTOS/Source/tasks.c **** 
4170:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4171:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4172:FreeRTOS/Source/tasks.c **** 					break;
4173:FreeRTOS/Source/tasks.c **** 
4174:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4175:FreeRTOS/Source/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 3071               	.LM360:
 3072 0cec 3230      		cpi r19,lo8(2)
 3073 0cee 01F0      		breq .L211
 3074               	.L216:
4176:FreeRTOS/Source/tasks.c **** 					{
4177:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 3076               	.LM361:
 3077 0cf0 49A3      		std Y+33,r20
 3078 0cf2 5AA3      		std Y+34,r21
 3079 0cf4 6BA3      		std Y+35,r22
 3080 0cf6 7CA3      		std Y+36,r23
 3081               	.L199:
4178:FreeRTOS/Source/tasks.c **** 					}
4179:FreeRTOS/Source/tasks.c **** 					else
4180:FreeRTOS/Source/tasks.c **** 					{
4181:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4182:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4183:FreeRTOS/Source/tasks.c **** 					}
4184:FreeRTOS/Source/tasks.c **** 					break;
4185:FreeRTOS/Source/tasks.c **** 
4186:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4187:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4188:FreeRTOS/Source/tasks.c **** 					updated. */
4189:FreeRTOS/Source/tasks.c **** 					break;
4190:FreeRTOS/Source/tasks.c **** 			}
4191:FreeRTOS/Source/tasks.c **** 
4192:FreeRTOS/Source/tasks.c **** 
4193:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4194:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4195:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 3083               	.LM362:
 3084 0cf8 3130      		cpi r19,lo8(1)
 3085 0cfa 01F0      		breq .L206
 3086               	.L210:
4126:FreeRTOS/Source/tasks.c **** 	{
 3088               	.LM363:
 3089 0cfc 81E0      		ldi r24,lo8(1)
 3090 0cfe 00C0      		rjmp .L205
 3091               	.L206:
4196:FreeRTOS/Source/tasks.c **** 			{
4197:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4198:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4199:FreeRTOS/Source/tasks.c **** 
4200:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3093               	.LM364:
 3094 0d00 8091 0000 		lds r24,uxSchedulerSuspended
 3095 0d04 8111      		cpse r24,__zero_reg__
 3096 0d06 00C0      		rjmp .L207
4201:FreeRTOS/Source/tasks.c **** 				{
4202:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3098               	.LM365:
 3099 0d08 7E01      		movw r14,r28
 3100 0d0a 22E0      		ldi r18,2
 3101 0d0c E20E      		add r14,r18
 3102 0d0e F11C      		adc r15,__zero_reg__
 3103 0d10 C701      		movw r24,r14
 3104 0d12 0E94 0000 		call uxListRemove
4203:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3106               	.LM366:
 3107 0d16 8E89      		ldd r24,Y+22
 3108 0d18 9091 0000 		lds r25,uxTopReadyPriority
 3109 0d1c 9817      		cp r25,r24
 3110 0d1e 00F4      		brsh .L208
 3112               	.LM367:
 3113 0d20 8093 0000 		sts uxTopReadyPriority,r24
 3114               	.L208:
 3116               	.LM368:
 3117 0d24 E9E0      		ldi r30,lo8(9)
 3118 0d26 8E9F      		mul r24,r30
 3119 0d28 C001      		movw r24,r0
 3120 0d2a 1124      		clr __zero_reg__
 3121 0d2c B701      		movw r22,r14
 3122 0d2e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3123 0d30 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3124 0d32 00C0      		rjmp .L217
 3125               	.L207:
4204:FreeRTOS/Source/tasks.c **** 				}
4205:FreeRTOS/Source/tasks.c **** 				else
4206:FreeRTOS/Source/tasks.c **** 				{
4207:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4208:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4209:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 3127               	.LM369:
 3128 0d34 BE01      		movw r22,r28
 3129 0d36 645F      		subi r22,-12
 3130 0d38 7F4F      		sbci r23,-1
 3131 0d3a 80E0      		ldi r24,lo8(xPendingReadyList)
 3132 0d3c 90E0      		ldi r25,hi8(xPendingReadyList)
 3133               	.L217:
 3134 0d3e 0E94 0000 		call vListInsertEnd
4210:FreeRTOS/Source/tasks.c **** 				}
4211:FreeRTOS/Source/tasks.c **** 
4212:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 3136               	.LM370:
 3137 0d42 E091 0000 		lds r30,pxCurrentTCB
 3138 0d46 F091 0000 		lds r31,pxCurrentTCB+1
 3139 0d4a 9E89      		ldd r25,Y+22
 3140 0d4c 8689      		ldd r24,Z+22
 3141 0d4e 8917      		cp r24,r25
 3142 0d50 00F4      		brsh .L210
4213:FreeRTOS/Source/tasks.c **** 				{
4214:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4215:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4216:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 3144               	.LM371:
 3145 0d52 0115      		cp r16,__zero_reg__
 3146 0d54 1105      		cpc r17,__zero_reg__
 3147 0d56 01F0      		breq .L210
4217:FreeRTOS/Source/tasks.c **** 					{
4218:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 3149               	.LM372:
 3150 0d58 81E0      		ldi r24,lo8(1)
 3151 0d5a F801      		movw r30,r16
 3152 0d5c 8083      		st Z,r24
 3153 0d5e 00C0      		rjmp .L205
 3154               	.L211:
4182:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
 3156               	.LM373:
 3157 0d60 80E0      		ldi r24,0
 3158               	.L205:
 3159               	/* epilogue start */
4219:FreeRTOS/Source/tasks.c **** 					}
4220:FreeRTOS/Source/tasks.c **** 				}
4221:FreeRTOS/Source/tasks.c **** 				else
4222:FreeRTOS/Source/tasks.c **** 				{
4223:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4224:FreeRTOS/Source/tasks.c **** 				}
4225:FreeRTOS/Source/tasks.c **** 			}
4226:FreeRTOS/Source/tasks.c **** 		}
4227:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4228:FreeRTOS/Source/tasks.c **** 
4229:FreeRTOS/Source/tasks.c **** 		return xReturn;
4230:FreeRTOS/Source/tasks.c **** 	}
 3161               	.LM374:
 3162 0d62 DF91      		pop r29
 3163 0d64 CF91      		pop r28
 3164 0d66 1F91      		pop r17
 3165 0d68 0F91      		pop r16
 3166 0d6a FF90      		pop r15
 3167 0d6c EF90      		pop r14
 3168 0d6e 0895      		ret
 3174               	.Lscope28:
 3176               		.stabd	78,0,0
 3180               	.global	vTaskNotifyGiveFromISR
 3182               	vTaskNotifyGiveFromISR:
 3183               		.stabd	46,0,0
4231:FreeRTOS/Source/tasks.c **** 
4232:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4233:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4234:FreeRTOS/Source/tasks.c **** 
4235:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4236:FreeRTOS/Source/tasks.c **** 
4237:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4238:FreeRTOS/Source/tasks.c **** 	{
 3185               	.LM375:
 3186               	.LFBB29:
 3187 0d70 EF92      		push r14
 3188 0d72 FF92      		push r15
 3189 0d74 0F93      		push r16
 3190 0d76 1F93      		push r17
 3191 0d78 CF93      		push r28
 3192 0d7a DF93      		push r29
 3193               	/* prologue: function */
 3194               	/* frame size = 0 */
 3195               	/* stack size = 6 */
 3196               	.L__stack_usage = 6
 3197 0d7c EC01      		movw r28,r24
 3198 0d7e 8B01      		movw r16,r22
4239:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4240:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4241:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4242:FreeRTOS/Source/tasks.c **** 
4243:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4244:FreeRTOS/Source/tasks.c **** 
4245:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4246:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4247:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4248:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4249:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4250:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4251:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4252:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4253:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4254:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4255:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4256:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4257:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4258:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4259:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4260:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4261:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4262:FreeRTOS/Source/tasks.c **** 
4263:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4264:FreeRTOS/Source/tasks.c **** 
4265:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4266:FreeRTOS/Source/tasks.c **** 		{
4267:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 3200               	.LM376:
 3201 0d80 8DA1      		ldd r24,Y+37
4268:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3203               	.LM377:
 3204 0d82 92E0      		ldi r25,lo8(2)
 3205 0d84 9DA3      		std Y+37,r25
4269:FreeRTOS/Source/tasks.c **** 
4270:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4271:FreeRTOS/Source/tasks.c **** 			semaphore. */
4272:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 3207               	.LM378:
 3208 0d86 49A1      		ldd r20,Y+33
 3209 0d88 5AA1      		ldd r21,Y+34
 3210 0d8a 6BA1      		ldd r22,Y+35
 3211 0d8c 7CA1      		ldd r23,Y+36
 3212 0d8e 4F5F      		subi r20,-1
 3213 0d90 5F4F      		sbci r21,-1
 3214 0d92 6F4F      		sbci r22,-1
 3215 0d94 7F4F      		sbci r23,-1
 3216 0d96 49A3      		std Y+33,r20
 3217 0d98 5AA3      		std Y+34,r21
 3218 0d9a 6BA3      		std Y+35,r22
 3219 0d9c 7CA3      		std Y+36,r23
4273:FreeRTOS/Source/tasks.c **** 
4274:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4275:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4276:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 3221               	.LM379:
 3222 0d9e 8130      		cpi r24,lo8(1)
 3223 0da0 01F4      		brne .L218
4277:FreeRTOS/Source/tasks.c **** 			{
4278:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4279:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4280:FreeRTOS/Source/tasks.c **** 
4281:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3225               	.LM380:
 3226 0da2 8091 0000 		lds r24,uxSchedulerSuspended
 3227 0da6 8111      		cpse r24,__zero_reg__
 3228 0da8 00C0      		rjmp .L221
4282:FreeRTOS/Source/tasks.c **** 				{
4283:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3230               	.LM381:
 3231 0daa 7E01      		movw r14,r28
 3232 0dac 22E0      		ldi r18,2
 3233 0dae E20E      		add r14,r18
 3234 0db0 F11C      		adc r15,__zero_reg__
 3235 0db2 C701      		movw r24,r14
 3236 0db4 0E94 0000 		call uxListRemove
4284:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3238               	.LM382:
 3239 0db8 8E89      		ldd r24,Y+22
 3240 0dba 9091 0000 		lds r25,uxTopReadyPriority
 3241 0dbe 9817      		cp r25,r24
 3242 0dc0 00F4      		brsh .L222
 3244               	.LM383:
 3245 0dc2 8093 0000 		sts uxTopReadyPriority,r24
 3246               	.L222:
 3248               	.LM384:
 3249 0dc6 E9E0      		ldi r30,lo8(9)
 3250 0dc8 8E9F      		mul r24,r30
 3251 0dca C001      		movw r24,r0
 3252 0dcc 1124      		clr __zero_reg__
 3253 0dce B701      		movw r22,r14
 3254 0dd0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3255 0dd2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3256 0dd4 00C0      		rjmp .L228
 3257               	.L221:
4285:FreeRTOS/Source/tasks.c **** 				}
4286:FreeRTOS/Source/tasks.c **** 				else
4287:FreeRTOS/Source/tasks.c **** 				{
4288:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4289:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4290:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 3259               	.LM385:
 3260 0dd6 BE01      		movw r22,r28
 3261 0dd8 645F      		subi r22,-12
 3262 0dda 7F4F      		sbci r23,-1
 3263 0ddc 80E0      		ldi r24,lo8(xPendingReadyList)
 3264 0dde 90E0      		ldi r25,hi8(xPendingReadyList)
 3265               	.L228:
 3266 0de0 0E94 0000 		call vListInsertEnd
4291:FreeRTOS/Source/tasks.c **** 				}
4292:FreeRTOS/Source/tasks.c **** 
4293:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 3268               	.LM386:
 3269 0de4 E091 0000 		lds r30,pxCurrentTCB
 3270 0de8 F091 0000 		lds r31,pxCurrentTCB+1
 3271 0dec 9E89      		ldd r25,Y+22
 3272 0dee 8689      		ldd r24,Z+22
 3273 0df0 8917      		cp r24,r25
 3274 0df2 00F4      		brsh .L218
4294:FreeRTOS/Source/tasks.c **** 				{
4295:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4296:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4297:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 3276               	.LM387:
 3277 0df4 0115      		cp r16,__zero_reg__
 3278 0df6 1105      		cpc r17,__zero_reg__
 3279 0df8 01F0      		breq .L218
4298:FreeRTOS/Source/tasks.c **** 					{
4299:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 3281               	.LM388:
 3282 0dfa 81E0      		ldi r24,lo8(1)
 3283 0dfc F801      		movw r30,r16
 3284 0dfe 8083      		st Z,r24
 3285               	.L218:
 3286               	/* epilogue start */
4300:FreeRTOS/Source/tasks.c **** 					}
4301:FreeRTOS/Source/tasks.c **** 				}
4302:FreeRTOS/Source/tasks.c **** 				else
4303:FreeRTOS/Source/tasks.c **** 				{
4304:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4305:FreeRTOS/Source/tasks.c **** 				}
4306:FreeRTOS/Source/tasks.c **** 			}
4307:FreeRTOS/Source/tasks.c **** 		}
4308:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4309:FreeRTOS/Source/tasks.c **** 	}
 3288               	.LM389:
 3289 0e00 DF91      		pop r29
 3290 0e02 CF91      		pop r28
 3291 0e04 1F91      		pop r17
 3292 0e06 0F91      		pop r16
 3293 0e08 FF90      		pop r15
 3294 0e0a EF90      		pop r14
 3295 0e0c 0895      		ret
 3300               	.Lscope29:
 3302               		.stabd	78,0,0
 3303               		.local	uxSchedulerSuspended
 3304               		.comm	uxSchedulerSuspended,1,1
 3305               		.data
 3308               	xNextTaskUnblockTime:
 3309 0000 FFFF      		.word	-1
 3310               		.local	xNumOfOverflows
 3311               		.comm	xNumOfOverflows,1,1
 3312               		.local	xYieldPending
 3313               		.comm	xYieldPending,1,1
 3314               		.local	uxPendedTicks
 3315               		.comm	uxPendedTicks,1,1
 3316               		.local	xSchedulerRunning
 3317               		.comm	xSchedulerRunning,1,1
 3318               		.local	uxTopReadyPriority
 3319               		.comm	uxTopReadyPriority,1,1
 3320               		.local	xTickCount
 3321               		.comm	xTickCount,2,1
 3322               		.local	uxCurrentNumberOfTasks
 3323               		.comm	uxCurrentNumberOfTasks,1,1
 3324               		.local	uxTasksDeleted
 3325               		.comm	uxTasksDeleted,1,1
 3326               		.local	pxOverflowDelayedTaskList
 3327               		.comm	pxOverflowDelayedTaskList,2,1
 3328               		.local	pxDelayedTaskList
 3329               		.comm	pxDelayedTaskList,2,1
 3330               	.global	pxCurrentTCB
 3331               		.section .bss
 3334               	pxCurrentTCB:
 3335 0000 0000      		.zero	2
 3336               		.local	uxTaskNumber
 3337               		.comm	uxTaskNumber,1,1
 3338               		.local	pxReadyTasksLists
 3339               		.comm	pxReadyTasksLists,36,1
 3340               		.local	xDelayedTaskList1
 3341               		.comm	xDelayedTaskList1,9,1
 3342               		.local	xDelayedTaskList2
 3343               		.comm	xDelayedTaskList2,9,1
 3344               		.local	xPendingReadyList
 3345               		.comm	xPendingReadyList,9,1
 3346               		.local	xTasksWaitingTermination
 3347               		.comm	xTasksWaitingTermination,9,1
 3367               		.text
 3369               	.Letext0:
 3370               		.ident	"GCC: (GNU) 4.7.2"
 3371               	.global __do_copy_data
 3372               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/cc7ALgt7.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7ALgt7.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7ALgt7.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7ALgt7.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7ALgt7.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7ALgt7.s:139    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/cc7ALgt7.s:3327   .bss:000000000000000e pxDelayedTaskList
     /tmp/cc7ALgt7.s:3308   .data:0000000000000000 xNextTaskUnblockTime
     /tmp/cc7ALgt7.s:190    .text:0000000000000036 prvAddCurrentTaskToDelayedList
     /tmp/cc7ALgt7.s:3334   .bss:0000000000000000 pxCurrentTCB
     /tmp/cc7ALgt7.s:3319   .bss:0000000000000008 xTickCount
     /tmp/cc7ALgt7.s:3325   .bss:000000000000000c pxOverflowDelayedTaskList
     /tmp/cc7ALgt7.s:287    .text:000000000000009e xTaskGenericCreate
     /tmp/cc7ALgt7.s:3321   .bss:000000000000000a uxCurrentNumberOfTasks
     /tmp/cc7ALgt7.s:3337   .bss:0000000000000011 pxReadyTasksLists
     /tmp/cc7ALgt7.s:3339   .bss:0000000000000035 xDelayedTaskList1
     /tmp/cc7ALgt7.s:3341   .bss:000000000000003e xDelayedTaskList2
     /tmp/cc7ALgt7.s:3343   .bss:0000000000000047 xPendingReadyList
     /tmp/cc7ALgt7.s:3345   .bss:0000000000000050 xTasksWaitingTermination
     /tmp/cc7ALgt7.s:3315   .bss:0000000000000006 xSchedulerRunning
     /tmp/cc7ALgt7.s:3329   .bss:0000000000000010 uxTaskNumber
     /tmp/cc7ALgt7.s:3317   .bss:0000000000000007 uxTopReadyPriority
     /tmp/cc7ALgt7.s:686    .text:000000000000029c vTaskDelete
     /tmp/cc7ALgt7.s:3323   .bss:000000000000000b uxTasksDeleted
     /tmp/cc7ALgt7.s:837    .text:000000000000032c vTaskStartScheduler
     /tmp/cc7ALgt7.s:1507   .text:0000000000000616 prvIdleTask
     /tmp/cc7ALgt7.s:921    .text:0000000000000390 vTaskEndScheduler
     /tmp/cc7ALgt7.s:950    .text:000000000000039a vTaskSuspendAll
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/cc7ALgt7.s:972    .text:00000000000003a6 xTaskGetTickCount
     /tmp/cc7ALgt7.s:1022   .text:00000000000003bc xTaskGetTickCountFromISR
     /tmp/cc7ALgt7.s:1049   .text:00000000000003c8 uxTaskGetNumberOfTasks
     /tmp/cc7ALgt7.s:1071   .text:00000000000003ce xTaskIncrementTick
     /tmp/cc7ALgt7.s:3304   .bss:0000000000000003 xNumOfOverflows
     /tmp/cc7ALgt7.s:3313   .bss:0000000000000005 uxPendedTicks
     /tmp/cc7ALgt7.s:3311   .bss:0000000000000004 xYieldPending
     /tmp/cc7ALgt7.s:1314   .text:0000000000000532 xTaskResumeAll
     /tmp/cc7ALgt7.s:1628   .text:0000000000000682 vTaskDelay
     /tmp/cc7ALgt7.s:1699   .text:00000000000006cc vTaskDelayUntil
     /tmp/cc7ALgt7.s:1817   .text:0000000000000742 vTaskSwitchContext
     /tmp/cc7ALgt7.s:1917   .text:00000000000007c2 vTaskPlaceOnEventList
     /tmp/cc7ALgt7.s:1968   .text:00000000000007fa vTaskPlaceOnUnorderedEventList
     /tmp/cc7ALgt7.s:2024   .text:0000000000000840 xTaskRemoveFromEventList
     /tmp/cc7ALgt7.s:2132   .text:00000000000008c2 xTaskRemoveFromUnorderedEventList
     /tmp/cc7ALgt7.s:2223   .text:000000000000092a vTaskSetTimeOutState
     /tmp/cc7ALgt7.s:2253   .text:0000000000000940 xTaskCheckForTimeOut
     /tmp/cc7ALgt7.s:2356   .text:0000000000000998 vTaskMissedYield
     /tmp/cc7ALgt7.s:2377   .text:00000000000009a0 uxTaskResetEventItemValue
     /tmp/cc7ALgt7.s:2418   .text:00000000000009ce ulTaskNotifyTake
     /tmp/cc7ALgt7.s:2591   .text:0000000000000a94 xTaskNotifyWait
     /tmp/cc7ALgt7.s:2826   .text:0000000000000bda xTaskNotify
     /tmp/cc7ALgt7.s:3002   .text:0000000000000c98 xTaskNotifyFromISR
     /tmp/cc7ALgt7.s:3182   .text:0000000000000d70 vTaskNotifyGiveFromISR

UNDEFINED SYMBOLS
vListInsert
pvPortMalloc
vPortFree
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
vPortYield
uxListRemove
xPortStartScheduler
vPortEndScheduler
vApplicationIdleHook
__do_copy_data
__do_clear_bss
