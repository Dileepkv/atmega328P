
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800100  0000204a  000020de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000204a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000679  00800136  00800136  00002114  2**0
                  ALLOC
  3 .stab         000066e4  00000000  00000000  00002114  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000036ea  00000000  00000000  000087f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000022  00000000  00000000  0000bee2  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 7e 0f 	jmp	0x1efc	; 0x1efc <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ea e4       	ldi	r30, 0x4A	; 74
      7c:	f0 e2       	ldi	r31, 0x20	; 32
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 33       	cpi	r26, 0x36	; 54
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	17 e0       	ldi	r17, 0x07	; 7
      8c:	a6 e3       	ldi	r26, 0x36	; 54
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	af 3a       	cpi	r26, 0xAF	; 175
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <main>
      9e:	0c 94 23 10 	jmp	0x2046	; 0x2046 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vSerial(void* pvParameters)
{
    uart_init();
      a6:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <uart_init>
    stdout = &uart_output;
      aa:	8e e0       	ldi	r24, 0x0E	; 14
      ac:	91 e0       	ldi	r25, 0x01	; 1
      ae:	90 93 ac 07 	sts	0x07AC, r25
      b2:	80 93 ab 07 	sts	0x07AB, r24
    stdin = &uart_input;
      b6:	80 e0       	ldi	r24, 0x00	; 0
      b8:	91 e0       	ldi	r25, 0x01	; 1
      ba:	90 93 aa 07 	sts	0x07AA, r25
      be:	80 93 a9 07 	sts	0x07A9, r24

    char input;

    for ( ;; )
    {
        printf("hello\n");
      c2:	8e e1       	ldi	r24, 0x1E	; 30
      c4:	91 e0       	ldi	r25, 0x01	; 1
      c6:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <puts>
        //puts("Hello World");
        //input = getchar();
        //printf("You wrote %c\n", input); 
        vTaskDelay(1000);
      ca:	88 ee       	ldi	r24, 0xE8	; 232
      cc:	93 e0       	ldi	r25, 0x03	; 3
      ce:	0e 94 b6 03 	call	0x76c	; 0x76c <vTaskDelay>
      d2:	f7 cf       	rjmp	.-18     	; 0xc2 <vSerial+0x1c>

000000d4 <vBlinkLed>:
 *
 * \param[in]   pvParameters
 ******************************************************************************/
static void vBlinkLed(void* pvParameters)
{
    DDRB |= _BV(PB5);
      d4:	25 9a       	sbi	0x04, 5	; 4

    for ( ;; )
    {
        PORTB ^= _BV(PB5);
      d6:	c0 e2       	ldi	r28, 0x20	; 32
      d8:	85 b1       	in	r24, 0x05	; 5
      da:	8c 27       	eor	r24, r28
      dc:	85 b9       	out	0x05, r24	; 5
        vTaskDelay(500);
      de:	84 ef       	ldi	r24, 0xF4	; 244
      e0:	91 e0       	ldi	r25, 0x01	; 1
      e2:	0e 94 b6 03 	call	0x76c	; 0x76c <vTaskDelay>
      e6:	f8 cf       	rjmp	.-16     	; 0xd8 <vBlinkLed+0x4>

000000e8 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
      e8:	08 95       	ret

000000ea <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
      ea:	e0 91 44 01 	lds	r30, 0x0144
      ee:	f0 91 45 01 	lds	r31, 0x0145
      f2:	80 81       	ld	r24, Z
      f4:	81 11       	cpse	r24, r1
      f6:	03 c0       	rjmp	.+6      	; 0xfe <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
      f8:	8f ef       	ldi	r24, 0xFF	; 255
      fa:	9f ef       	ldi	r25, 0xFF	; 255
      fc:	0c c0       	rjmp	.+24     	; 0x116 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
      fe:	e0 91 44 01 	lds	r30, 0x0144
     102:	f0 91 45 01 	lds	r31, 0x0145
     106:	05 80       	ldd	r0, Z+5	; 0x05
     108:	f6 81       	ldd	r31, Z+6	; 0x06
     10a:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     10c:	06 80       	ldd	r0, Z+6	; 0x06
     10e:	f7 81       	ldd	r31, Z+7	; 0x07
     110:	e0 2d       	mov	r30, r0
     112:	82 81       	ldd	r24, Z+2	; 0x02
     114:	93 81       	ldd	r25, Z+3	; 0x03
     116:	90 93 1d 01 	sts	0x011D, r25
     11a:	80 93 1c 01 	sts	0x011C, r24
     11e:	08 95       	ret

00000120 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     120:	cf 93       	push	r28
     122:	df 93       	push	r29
     124:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     126:	e0 91 36 01 	lds	r30, 0x0136
     12a:	f0 91 37 01 	lds	r31, 0x0137
     12e:	93 83       	std	Z+3, r25	; 0x03
     130:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     132:	80 91 3e 01 	lds	r24, 0x013E
     136:	90 91 3f 01 	lds	r25, 0x013F
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     13a:	60 91 36 01 	lds	r22, 0x0136
     13e:	70 91 37 01 	lds	r23, 0x0137
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
     142:	c8 17       	cp	r28, r24
     144:	d9 07       	cpc	r29, r25
     146:	50 f4       	brcc	.+20     	; 0x15c <prvAddCurrentTaskToDelayedList+0x3c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     148:	80 91 42 01 	lds	r24, 0x0142
     14c:	90 91 43 01 	lds	r25, 0x0143
     150:	6e 5f       	subi	r22, 0xFE	; 254
     152:	7f 4f       	sbci	r23, 0xFF	; 255
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     158:	0c 94 9c 0b 	jmp	0x1738	; 0x1738 <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     15c:	80 91 44 01 	lds	r24, 0x0144
     160:	90 91 45 01 	lds	r25, 0x0145
     164:	6e 5f       	subi	r22, 0xFE	; 254
     166:	7f 4f       	sbci	r23, 0xFF	; 255
     168:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     16c:	80 91 1c 01 	lds	r24, 0x011C
     170:	90 91 1d 01 	lds	r25, 0x011D
     174:	c8 17       	cp	r28, r24
     176:	d9 07       	cpc	r29, r25
     178:	20 f4       	brcc	.+8      	; 0x182 <prvAddCurrentTaskToDelayedList+0x62>
		{
			xNextTaskUnblockTime = xTimeToWake;
     17a:	d0 93 1d 01 	sts	0x011D, r29
     17e:	c0 93 1c 01 	sts	0x011C, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     182:	df 91       	pop	r29
     184:	cf 91       	pop	r28
     186:	08 95       	ret

00000188 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     188:	5f 92       	push	r5
     18a:	6f 92       	push	r6
     18c:	7f 92       	push	r7
     18e:	8f 92       	push	r8
     190:	9f 92       	push	r9
     192:	af 92       	push	r10
     194:	bf 92       	push	r11
     196:	cf 92       	push	r12
     198:	df 92       	push	r13
     19a:	ef 92       	push	r14
     19c:	ff 92       	push	r15
     19e:	0f 93       	push	r16
     1a0:	1f 93       	push	r17
     1a2:	cf 93       	push	r28
     1a4:	df 93       	push	r29
     1a6:	4c 01       	movw	r8, r24
     1a8:	16 2f       	mov	r17, r22
     1aa:	57 2e       	mov	r5, r23
     1ac:	5a 01       	movw	r10, r20
     1ae:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     1b0:	c1 14       	cp	r12, r1
     1b2:	d1 04       	cpc	r13, r1
     1b4:	39 f4       	brne	.+14     	; 0x1c4 <xTaskGenericCreate+0x3c>
     1b6:	ca 01       	movw	r24, r20
     1b8:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <pvPortMalloc>
     1bc:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     1be:	00 97       	sbiw	r24, 0x00	; 0
     1c0:	09 f4       	brne	.+2      	; 0x1c4 <xTaskGenericCreate+0x3c>
     1c2:	d0 c0       	rjmp	.+416    	; 0x364 <xTaskGenericCreate+0x1dc>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     1c4:	86 e2       	ldi	r24, 0x26	; 38
     1c6:	90 e0       	ldi	r25, 0x00	; 0
     1c8:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <pvPortMalloc>
     1cc:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	61 f0       	breq	.+24     	; 0x1ea <xTaskGenericCreate+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     1d2:	d8 8e       	std	Y+24, r13	; 0x18
     1d4:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	a2 1a       	sub	r10, r18
     1da:	b1 08       	sbc	r11, r1
     1dc:	ac 0c       	add	r10, r12
     1de:	bd 1c       	adc	r11, r13
     1e0:	e1 2f       	mov	r30, r17
     1e2:	f5 2d       	mov	r31, r5
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <xTaskGenericCreate+0x6a>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     1ea:	c6 01       	movw	r24, r12
     1ec:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vPortFree>
     1f0:	b9 c0       	rjmp	.+370    	; 0x364 <xTaskGenericCreate+0x1dc>
	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
     1f2:	bf 01       	movw	r22, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     1f4:	41 91       	ld	r20, Z+
	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
     1f6:	9e 01       	movw	r18, r28
     1f8:	28 0f       	add	r18, r24
     1fa:	39 1f       	adc	r19, r25
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     1fc:	d9 01       	movw	r26, r18
     1fe:	59 96       	adiw	r26, 0x19	; 25
     200:	4c 93       	st	X, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     202:	db 01       	movw	r26, r22
     204:	2c 91       	ld	r18, X
     206:	22 23       	and	r18, r18
     208:	21 f0       	breq	.+8      	; 0x212 <xTaskGenericCreate+0x8a>
     20a:	01 96       	adiw	r24, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     20c:	88 30       	cpi	r24, 0x08	; 8
     20e:	91 05       	cpc	r25, r1
     210:	81 f7       	brne	.-32     	; 0x1f2 <xTaskGenericCreate+0x6a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     212:	18 a2       	std	Y+32, r1	; 0x20
     214:	10 2f       	mov	r17, r16
     216:	04 30       	cpi	r16, 0x04	; 4
     218:	08 f0       	brcs	.+2      	; 0x21c <xTaskGenericCreate+0x94>
     21a:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     21c:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     21e:	6e 01       	movw	r12, r28
     220:	b2 e0       	ldi	r27, 0x02	; 2
     222:	cb 0e       	add	r12, r27
     224:	d1 1c       	adc	r13, r1
     226:	c6 01       	movw	r24, r12
     228:	0e 94 77 0b 	call	0x16ee	; 0x16ee <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     22c:	ce 01       	movw	r24, r28
     22e:	0c 96       	adiw	r24, 0x0c	; 12
     230:	0e 94 77 0b 	call	0x16ee	; 0x16ee <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     234:	d9 87       	std	Y+9, r29	; 0x09
     236:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     238:	84 e0       	ldi	r24, 0x04	; 4
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	81 1b       	sub	r24, r17
     23e:	91 09       	sbc	r25, r1
     240:	9d 87       	std	Y+13, r25	; 0x0d
     242:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     244:	db 8b       	std	Y+19, r29	; 0x13
     246:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif /* portUSING_MPU_WRAPPERS */

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     248:	19 a2       	std	Y+33, r1	; 0x21
     24a:	1a a2       	std	Y+34, r1	; 0x22
     24c:	1b a2       	std	Y+35, r1	; 0x23
     24e:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     250:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     252:	a3 01       	movw	r20, r6
     254:	b4 01       	movw	r22, r8
     256:	c5 01       	movw	r24, r10
     258:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <pxPortInitialiseStack>
     25c:	99 83       	std	Y+1, r25	; 0x01
     25e:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     260:	e1 14       	cp	r14, r1
     262:	f1 04       	cpc	r15, r1
     264:	19 f0       	breq	.+6      	; 0x26c <xTaskGenericCreate+0xe4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     266:	f7 01       	movw	r30, r14
     268:	d1 83       	std	Z+1, r29	; 0x01
     26a:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     26c:	0f b6       	in	r0, 0x3f	; 63
     26e:	f8 94       	cli
     270:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     272:	80 91 40 01 	lds	r24, 0x0140
     276:	8f 5f       	subi	r24, 0xFF	; 255
     278:	80 93 40 01 	sts	0x0140, r24
			if( pxCurrentTCB == NULL )
     27c:	80 91 36 01 	lds	r24, 0x0136
     280:	90 91 37 01 	lds	r25, 0x0137
     284:	89 2b       	or	r24, r25
     286:	c9 f5       	brne	.+114    	; 0x2fa <xTaskGenericCreate+0x172>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     288:	d0 93 37 01 	sts	0x0137, r29
     28c:	c0 93 36 01 	sts	0x0136, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     290:	80 91 40 01 	lds	r24, 0x0140
     294:	81 30       	cpi	r24, 0x01	; 1
     296:	09 f0       	breq	.+2      	; 0x29a <xTaskGenericCreate+0x112>
     298:	3f c0       	rjmp	.+126    	; 0x318 <xTaskGenericCreate+0x190>
     29a:	e1 2c       	mov	r14, r1
     29c:	f1 2c       	mov	r15, r1
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     29e:	19 e0       	ldi	r17, 0x09	; 9
     2a0:	1e 9d       	mul	r17, r14
     2a2:	c0 01       	movw	r24, r0
     2a4:	1f 9d       	mul	r17, r15
     2a6:	90 0d       	add	r25, r0
     2a8:	11 24       	eor	r1, r1
     2aa:	89 5b       	subi	r24, 0xB9	; 185
     2ac:	9e 4f       	sbci	r25, 0xFE	; 254
     2ae:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
     2b2:	ff ef       	ldi	r31, 0xFF	; 255
     2b4:	ef 1a       	sub	r14, r31
     2b6:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     2b8:	24 e0       	ldi	r18, 0x04	; 4
     2ba:	e2 16       	cp	r14, r18
     2bc:	f1 04       	cpc	r15, r1
     2be:	81 f7       	brne	.-32     	; 0x2a0 <xTaskGenericCreate+0x118>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     2c0:	8b e6       	ldi	r24, 0x6B	; 107
     2c2:	91 e0       	ldi	r25, 0x01	; 1
     2c4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     2c8:	84 e7       	ldi	r24, 0x74	; 116
     2ca:	91 e0       	ldi	r25, 0x01	; 1
     2cc:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     2d0:	8d e7       	ldi	r24, 0x7D	; 125
     2d2:	91 e0       	ldi	r25, 0x01	; 1
     2d4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     2d8:	86 e8       	ldi	r24, 0x86	; 134
     2da:	91 e0       	ldi	r25, 0x01	; 1
     2dc:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     2e0:	8b e6       	ldi	r24, 0x6B	; 107
     2e2:	91 e0       	ldi	r25, 0x01	; 1
     2e4:	90 93 45 01 	sts	0x0145, r25
     2e8:	80 93 44 01 	sts	0x0144, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     2ec:	84 e7       	ldi	r24, 0x74	; 116
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 93 43 01 	sts	0x0143, r25
     2f4:	80 93 42 01 	sts	0x0142, r24
     2f8:	0f c0       	rjmp	.+30     	; 0x318 <xTaskGenericCreate+0x190>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     2fa:	80 91 3c 01 	lds	r24, 0x013C
     2fe:	81 11       	cpse	r24, r1
     300:	0b c0       	rjmp	.+22     	; 0x318 <xTaskGenericCreate+0x190>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     302:	e0 91 36 01 	lds	r30, 0x0136
     306:	f0 91 37 01 	lds	r31, 0x0137
     30a:	86 89       	ldd	r24, Z+22	; 0x16
     30c:	08 17       	cp	r16, r24
     30e:	20 f0       	brcs	.+8      	; 0x318 <xTaskGenericCreate+0x190>
					{
						pxCurrentTCB = pxNewTCB;
     310:	d0 93 37 01 	sts	0x0137, r29
     314:	c0 93 36 01 	sts	0x0136, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     318:	80 91 46 01 	lds	r24, 0x0146
     31c:	8f 5f       	subi	r24, 0xFF	; 255
     31e:	80 93 46 01 	sts	0x0146, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     322:	8e 89       	ldd	r24, Y+22	; 0x16
     324:	90 91 3d 01 	lds	r25, 0x013D
     328:	98 17       	cp	r25, r24
     32a:	10 f4       	brcc	.+4      	; 0x330 <xTaskGenericCreate+0x1a8>
     32c:	80 93 3d 01 	sts	0x013D, r24
     330:	a9 e0       	ldi	r26, 0x09	; 9
     332:	8a 9f       	mul	r24, r26
     334:	c0 01       	movw	r24, r0
     336:	11 24       	eor	r1, r1
     338:	b6 01       	movw	r22, r12
     33a:	89 5b       	subi	r24, 0xB9	; 185
     33c:	9e 4f       	sbci	r25, 0xFE	; 254
     33e:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     342:	0f 90       	pop	r0
     344:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     346:	80 91 3c 01 	lds	r24, 0x013C
     34a:	88 23       	and	r24, r24
     34c:	49 f0       	breq	.+18     	; 0x360 <xTaskGenericCreate+0x1d8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     34e:	e0 91 36 01 	lds	r30, 0x0136
     352:	f0 91 37 01 	lds	r31, 0x0137
     356:	86 89       	ldd	r24, Z+22	; 0x16
     358:	80 17       	cp	r24, r16
     35a:	10 f4       	brcc	.+4      	; 0x360 <xTaskGenericCreate+0x1d8>
			{
				taskYIELD_IF_USING_PREEMPTION();
     35c:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     360:	81 e0       	ldi	r24, 0x01	; 1
     362:	01 c0       	rjmp	.+2      	; 0x366 <xTaskGenericCreate+0x1de>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     364:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	ff 90       	pop	r15
     370:	ef 90       	pop	r14
     372:	df 90       	pop	r13
     374:	cf 90       	pop	r12
     376:	bf 90       	pop	r11
     378:	af 90       	pop	r10
     37a:	9f 90       	pop	r9
     37c:	8f 90       	pop	r8
     37e:	7f 90       	pop	r7
     380:	6f 90       	pop	r6
     382:	5f 90       	pop	r5
     384:	08 95       	ret

00000386 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     386:	0f 93       	push	r16
     388:	1f 93       	push	r17
     38a:	cf 93       	push	r28
     38c:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     38e:	0f b6       	in	r0, 0x3f	; 63
     390:	f8 94       	cli
     392:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     394:	00 97       	sbiw	r24, 0x00	; 0
     396:	29 f4       	brne	.+10     	; 0x3a2 <vTaskDelete+0x1c>
     398:	c0 91 36 01 	lds	r28, 0x0136
     39c:	d0 91 37 01 	lds	r29, 0x0137
     3a0:	01 c0       	rjmp	.+2      	; 0x3a4 <vTaskDelete+0x1e>
     3a2:	ec 01       	movw	r28, r24

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     3a4:	8e 01       	movw	r16, r28
     3a6:	0e 5f       	subi	r16, 0xFE	; 254
     3a8:	1f 4f       	sbci	r17, 0xFF	; 255
     3aa:	c8 01       	movw	r24, r16
     3ac:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     3b0:	8c 89       	ldd	r24, Y+20	; 0x14
     3b2:	9d 89       	ldd	r25, Y+21	; 0x15
     3b4:	89 2b       	or	r24, r25
     3b6:	21 f0       	breq	.+8      	; 0x3c0 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     3b8:	ce 01       	movw	r24, r28
     3ba:	0c 96       	adiw	r24, 0x0c	; 12
     3bc:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
     3c0:	b8 01       	movw	r22, r16
     3c2:	86 e8       	ldi	r24, 0x86	; 134
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
     3ca:	80 91 41 01 	lds	r24, 0x0141
     3ce:	8f 5f       	subi	r24, 0xFF	; 255
     3d0:	80 93 41 01 	sts	0x0141, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
     3d4:	80 91 46 01 	lds	r24, 0x0146
     3d8:	8f 5f       	subi	r24, 0xFF	; 255
     3da:	80 93 46 01 	sts	0x0146, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     3de:	0f 90       	pop	r0
     3e0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     3e2:	80 91 3c 01 	lds	r24, 0x013C
     3e6:	88 23       	and	r24, r24
     3e8:	89 f0       	breq	.+34     	; 0x40c <vTaskDelete+0x86>
		{
			if( pxTCB == pxCurrentTCB )
     3ea:	80 91 36 01 	lds	r24, 0x0136
     3ee:	90 91 37 01 	lds	r25, 0x0137
     3f2:	c8 17       	cp	r28, r24
     3f4:	d9 07       	cpc	r29, r25
     3f6:	19 f4       	brne	.+6      	; 0x3fe <vTaskDelete+0x78>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
     3f8:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
     3fc:	07 c0       	rjmp	.+14     	; 0x40c <vTaskDelete+0x86>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
     3fe:	0f b6       	in	r0, 0x3f	; 63
     400:	f8 94       	cli
     402:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
     404:	0e 94 75 00 	call	0xea	; 0xea <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
     408:	0f 90       	pop	r0
     40a:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
     40c:	df 91       	pop	r29
     40e:	cf 91       	pop	r28
     410:	1f 91       	pop	r17
     412:	0f 91       	pop	r16
     414:	08 95       	ret

00000416 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     416:	af 92       	push	r10
     418:	bf 92       	push	r11
     41a:	cf 92       	push	r12
     41c:	df 92       	push	r13
     41e:	ef 92       	push	r14
     420:	ff 92       	push	r15
     422:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     424:	a1 2c       	mov	r10, r1
     426:	b1 2c       	mov	r11, r1
     428:	c1 2c       	mov	r12, r1
     42a:	d1 2c       	mov	r13, r1
     42c:	e1 2c       	mov	r14, r1
     42e:	f1 2c       	mov	r15, r1
     430:	00 e0       	ldi	r16, 0x00	; 0
     432:	20 e0       	ldi	r18, 0x00	; 0
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	45 e5       	ldi	r20, 0x55	; 85
     438:	50 e0       	ldi	r21, 0x00	; 0
     43a:	61 e3       	ldi	r22, 0x31	; 49
     43c:	71 e0       	ldi	r23, 0x01	; 1
     43e:	80 e8       	ldi	r24, 0x80	; 128
     440:	93 e0       	ldi	r25, 0x03	; 3
     442:	0e 94 c4 00 	call	0x188	; 0x188 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     446:	81 30       	cpi	r24, 0x01	; 1
     448:	81 f4       	brne	.+32     	; 0x46a <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     44a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     44c:	80 93 3c 01 	sts	0x013C, r24
		xTickCount = ( TickType_t ) 0U;
     450:	10 92 3f 01 	sts	0x013F, r1
     454:	10 92 3e 01 	sts	0x013E, r1
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     458:	0f 91       	pop	r16
     45a:	ff 90       	pop	r15
     45c:	ef 90       	pop	r14
     45e:	df 90       	pop	r13
     460:	cf 90       	pop	r12
     462:	bf 90       	pop	r11
     464:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     466:	0c 94 88 0e 	jmp	0x1d10	; 0x1d10 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     46a:	0f 91       	pop	r16
     46c:	ff 90       	pop	r15
     46e:	ef 90       	pop	r14
     470:	df 90       	pop	r13
     472:	cf 90       	pop	r12
     474:	bf 90       	pop	r11
     476:	af 90       	pop	r10
     478:	08 95       	ret

0000047a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     47a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     47c:	10 92 3c 01 	sts	0x013C, r1
	vPortEndScheduler();
     480:	0c 94 c8 0e 	jmp	0x1d90	; 0x1d90 <vPortEndScheduler>

00000484 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     484:	80 91 38 01 	lds	r24, 0x0138
     488:	8f 5f       	subi	r24, 0xFF	; 255
     48a:	80 93 38 01 	sts	0x0138, r24
     48e:	08 95       	ret

00000490 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     490:	0f b6       	in	r0, 0x3f	; 63
     492:	f8 94       	cli
     494:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     496:	20 91 3e 01 	lds	r18, 0x013E
     49a:	30 91 3f 01 	lds	r19, 0x013F
	}
	portTICK_TYPE_EXIT_CRITICAL();
     49e:	0f 90       	pop	r0
     4a0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     4a2:	c9 01       	movw	r24, r18
     4a4:	08 95       	ret

000004a6 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     4a6:	20 91 3e 01 	lds	r18, 0x013E
     4aa:	30 91 3f 01 	lds	r19, 0x013F
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     4ae:	c9 01       	movw	r24, r18
     4b0:	08 95       	ret

000004b2 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     4b2:	80 91 40 01 	lds	r24, 0x0140
}
     4b6:	08 95       	ret

000004b8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     4b8:	cf 92       	push	r12
     4ba:	df 92       	push	r13
     4bc:	ef 92       	push	r14
     4be:	ff 92       	push	r15
     4c0:	0f 93       	push	r16
     4c2:	1f 93       	push	r17
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     4c8:	80 91 38 01 	lds	r24, 0x0138
     4cc:	81 11       	cpse	r24, r1
     4ce:	8d c0       	rjmp	.+282    	; 0x5ea <xTaskIncrementTick+0x132>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     4d0:	80 91 3e 01 	lds	r24, 0x013E
     4d4:	90 91 3f 01 	lds	r25, 0x013F
     4d8:	01 96       	adiw	r24, 0x01	; 1
     4da:	90 93 3f 01 	sts	0x013F, r25
     4de:	80 93 3e 01 	sts	0x013E, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     4e2:	00 91 3e 01 	lds	r16, 0x013E
     4e6:	10 91 3f 01 	lds	r17, 0x013F

			if( xConstTickCount == ( TickType_t ) 0U )
     4ea:	01 15       	cp	r16, r1
     4ec:	11 05       	cpc	r17, r1
     4ee:	b9 f4       	brne	.+46     	; 0x51e <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     4f0:	80 91 44 01 	lds	r24, 0x0144
     4f4:	90 91 45 01 	lds	r25, 0x0145
     4f8:	20 91 42 01 	lds	r18, 0x0142
     4fc:	30 91 43 01 	lds	r19, 0x0143
     500:	30 93 45 01 	sts	0x0145, r19
     504:	20 93 44 01 	sts	0x0144, r18
     508:	90 93 43 01 	sts	0x0143, r25
     50c:	80 93 42 01 	sts	0x0142, r24
     510:	80 91 39 01 	lds	r24, 0x0139
     514:	8f 5f       	subi	r24, 0xFF	; 255
     516:	80 93 39 01 	sts	0x0139, r24
     51a:	0e 94 75 00 	call	0xea	; 0xea <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     51e:	80 91 1c 01 	lds	r24, 0x011C
     522:	90 91 1d 01 	lds	r25, 0x011D
     526:	d1 2c       	mov	r13, r1
     528:	08 17       	cp	r16, r24
     52a:	19 07       	cpc	r17, r25
     52c:	20 f4       	brcc	.+8      	; 0x536 <xTaskIncrementTick+0x7e>
     52e:	4e c0       	rjmp	.+156    	; 0x5cc <xTaskIncrementTick+0x114>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     530:	dd 24       	eor	r13, r13
     532:	d3 94       	inc	r13
     534:	02 c0       	rjmp	.+4      	; 0x53a <xTaskIncrementTick+0x82>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     536:	89 e0       	ldi	r24, 0x09	; 9
     538:	c8 2e       	mov	r12, r24
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     53a:	e0 91 44 01 	lds	r30, 0x0144
     53e:	f0 91 45 01 	lds	r31, 0x0145
     542:	80 81       	ld	r24, Z
     544:	81 11       	cpse	r24, r1
     546:	07 c0       	rjmp	.+14     	; 0x556 <xTaskIncrementTick+0x9e>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     548:	8f ef       	ldi	r24, 0xFF	; 255
     54a:	9f ef       	ldi	r25, 0xFF	; 255
     54c:	90 93 1d 01 	sts	0x011D, r25
     550:	80 93 1c 01 	sts	0x011C, r24
						break;
     554:	3b c0       	rjmp	.+118    	; 0x5cc <xTaskIncrementTick+0x114>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     556:	e0 91 44 01 	lds	r30, 0x0144
     55a:	f0 91 45 01 	lds	r31, 0x0145
     55e:	05 80       	ldd	r0, Z+5	; 0x05
     560:	f6 81       	ldd	r31, Z+6	; 0x06
     562:	e0 2d       	mov	r30, r0
     564:	c6 81       	ldd	r28, Z+6	; 0x06
     566:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     568:	2a 81       	ldd	r18, Y+2	; 0x02
     56a:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     56c:	02 17       	cp	r16, r18
     56e:	13 07       	cpc	r17, r19
     570:	28 f4       	brcc	.+10     	; 0x57c <xTaskIncrementTick+0xc4>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     572:	30 93 1d 01 	sts	0x011D, r19
     576:	20 93 1c 01 	sts	0x011C, r18
							break;
     57a:	28 c0       	rjmp	.+80     	; 0x5cc <xTaskIncrementTick+0x114>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     57c:	7e 01       	movw	r14, r28
     57e:	82 e0       	ldi	r24, 0x02	; 2
     580:	e8 0e       	add	r14, r24
     582:	f1 1c       	adc	r15, r1
     584:	c7 01       	movw	r24, r14
     586:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     58a:	2c 89       	ldd	r18, Y+20	; 0x14
     58c:	3d 89       	ldd	r19, Y+21	; 0x15
     58e:	23 2b       	or	r18, r19
     590:	21 f0       	breq	.+8      	; 0x59a <xTaskIncrementTick+0xe2>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     592:	ce 01       	movw	r24, r28
     594:	0c 96       	adiw	r24, 0x0c	; 12
     596:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     59a:	2e 89       	ldd	r18, Y+22	; 0x16
     59c:	80 91 3d 01 	lds	r24, 0x013D
     5a0:	82 17       	cp	r24, r18
     5a2:	10 f4       	brcc	.+4      	; 0x5a8 <xTaskIncrementTick+0xf0>
     5a4:	20 93 3d 01 	sts	0x013D, r18
     5a8:	c2 9e       	mul	r12, r18
     5aa:	c0 01       	movw	r24, r0
     5ac:	11 24       	eor	r1, r1
     5ae:	b7 01       	movw	r22, r14
     5b0:	89 5b       	subi	r24, 0xB9	; 185
     5b2:	9e 4f       	sbci	r25, 0xFE	; 254
     5b4:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     5b8:	e0 91 36 01 	lds	r30, 0x0136
     5bc:	f0 91 37 01 	lds	r31, 0x0137
     5c0:	9e 89       	ldd	r25, Y+22	; 0x16
     5c2:	86 89       	ldd	r24, Z+22	; 0x16
     5c4:	98 17       	cp	r25, r24
     5c6:	08 f0       	brcs	.+2      	; 0x5ca <xTaskIncrementTick+0x112>
     5c8:	b3 cf       	rjmp	.-154    	; 0x530 <xTaskIncrementTick+0x78>
     5ca:	b7 cf       	rjmp	.-146    	; 0x53a <xTaskIncrementTick+0x82>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     5cc:	e0 91 36 01 	lds	r30, 0x0136
     5d0:	f0 91 37 01 	lds	r31, 0x0137
     5d4:	e6 89       	ldd	r30, Z+22	; 0x16
     5d6:	89 e0       	ldi	r24, 0x09	; 9
     5d8:	e8 9f       	mul	r30, r24
     5da:	f0 01       	movw	r30, r0
     5dc:	11 24       	eor	r1, r1
     5de:	e9 5b       	subi	r30, 0xB9	; 185
     5e0:	fe 4f       	sbci	r31, 0xFE	; 254
     5e2:	80 81       	ld	r24, Z
     5e4:	82 30       	cpi	r24, 0x02	; 2
     5e6:	40 f4       	brcc	.+16     	; 0x5f8 <xTaskIncrementTick+0x140>
     5e8:	09 c0       	rjmp	.+18     	; 0x5fc <xTaskIncrementTick+0x144>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     5ea:	80 91 3b 01 	lds	r24, 0x013B
     5ee:	8f 5f       	subi	r24, 0xFF	; 255
     5f0:	80 93 3b 01 	sts	0x013B, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     5f4:	d1 2c       	mov	r13, r1
     5f6:	02 c0       	rjmp	.+4      	; 0x5fc <xTaskIncrementTick+0x144>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     5f8:	dd 24       	eor	r13, r13
     5fa:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     5fc:	80 91 3a 01 	lds	r24, 0x013A
     600:	88 23       	and	r24, r24
     602:	11 f0       	breq	.+4      	; 0x608 <xTaskIncrementTick+0x150>
		{
			xSwitchRequired = pdTRUE;
     604:	dd 24       	eor	r13, r13
     606:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     608:	8d 2d       	mov	r24, r13
     60a:	df 91       	pop	r29
     60c:	cf 91       	pop	r28
     60e:	1f 91       	pop	r17
     610:	0f 91       	pop	r16
     612:	ff 90       	pop	r15
     614:	ef 90       	pop	r14
     616:	df 90       	pop	r13
     618:	cf 90       	pop	r12
     61a:	08 95       	ret

0000061c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     61c:	ef 92       	push	r14
     61e:	ff 92       	push	r15
     620:	0f 93       	push	r16
     622:	1f 93       	push	r17
     624:	cf 93       	push	r28
     626:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     628:	0f b6       	in	r0, 0x3f	; 63
     62a:	f8 94       	cli
     62c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     62e:	80 91 38 01 	lds	r24, 0x0138
     632:	81 50       	subi	r24, 0x01	; 1
     634:	80 93 38 01 	sts	0x0138, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     638:	80 91 38 01 	lds	r24, 0x0138
     63c:	88 23       	and	r24, r24
     63e:	11 f0       	breq	.+4      	; 0x644 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     640:	80 e0       	ldi	r24, 0x00	; 0
     642:	55 c0       	rjmp	.+170    	; 0x6ee <xTaskResumeAll+0xd2>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     644:	80 91 40 01 	lds	r24, 0x0140
     648:	81 11       	cpse	r24, r1
     64a:	2b c0       	rjmp	.+86     	; 0x6a2 <xTaskResumeAll+0x86>
     64c:	f9 cf       	rjmp	.-14     	; 0x640 <xTaskResumeAll+0x24>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     64e:	e0 91 82 01 	lds	r30, 0x0182
     652:	f0 91 83 01 	lds	r31, 0x0183
     656:	c6 81       	ldd	r28, Z+6	; 0x06
     658:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     65a:	ce 01       	movw	r24, r28
     65c:	0c 96       	adiw	r24, 0x0c	; 12
     65e:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     662:	8e 01       	movw	r16, r28
     664:	0e 5f       	subi	r16, 0xFE	; 254
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	c8 01       	movw	r24, r16
     66a:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     66e:	8e 89       	ldd	r24, Y+22	; 0x16
     670:	90 91 3d 01 	lds	r25, 0x013D
     674:	98 17       	cp	r25, r24
     676:	10 f4       	brcc	.+4      	; 0x67c <xTaskResumeAll+0x60>
     678:	80 93 3d 01 	sts	0x013D, r24
     67c:	f8 9e       	mul	r15, r24
     67e:	c0 01       	movw	r24, r0
     680:	11 24       	eor	r1, r1
     682:	b8 01       	movw	r22, r16
     684:	89 5b       	subi	r24, 0xB9	; 185
     686:	9e 4f       	sbci	r25, 0xFE	; 254
     688:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     68c:	e0 91 36 01 	lds	r30, 0x0136
     690:	f0 91 37 01 	lds	r31, 0x0137
     694:	9e 89       	ldd	r25, Y+22	; 0x16
     696:	86 89       	ldd	r24, Z+22	; 0x16
     698:	98 17       	cp	r25, r24
     69a:	38 f0       	brcs	.+14     	; 0x6aa <xTaskResumeAll+0x8e>
					{
						xYieldPending = pdTRUE;
     69c:	e0 92 3a 01 	sts	0x013A, r14
     6a0:	04 c0       	rjmp	.+8      	; 0x6aa <xTaskResumeAll+0x8e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
     6a2:	99 e0       	ldi	r25, 0x09	; 9
     6a4:	f9 2e       	mov	r15, r25

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     6a6:	ee 24       	eor	r14, r14
     6a8:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     6aa:	80 91 7d 01 	lds	r24, 0x017D
     6ae:	81 11       	cpse	r24, r1
     6b0:	ce cf       	rjmp	.-100    	; 0x64e <xTaskResumeAll+0x32>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     6b2:	80 91 3b 01 	lds	r24, 0x013B
     6b6:	81 11       	cpse	r24, r1
     6b8:	11 c0       	rjmp	.+34     	; 0x6dc <xTaskResumeAll+0xc0>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     6ba:	80 91 3a 01 	lds	r24, 0x013A
     6be:	81 30       	cpi	r24, 0x01	; 1
     6c0:	09 f0       	breq	.+2      	; 0x6c4 <xTaskResumeAll+0xa8>
     6c2:	be cf       	rjmp	.-132    	; 0x640 <xTaskResumeAll+0x24>
     6c4:	11 c0       	rjmp	.+34     	; 0x6e8 <xTaskResumeAll+0xcc>
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     6c6:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <xTaskIncrementTick>
     6ca:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     6cc:	c0 93 3a 01 	sts	0x013A, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     6d0:	80 91 3b 01 	lds	r24, 0x013B
     6d4:	81 50       	subi	r24, 0x01	; 1
     6d6:	80 93 3b 01 	sts	0x013B, r24
     6da:	01 c0       	rjmp	.+2      	; 0x6de <xTaskResumeAll+0xc2>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     6dc:	c1 e0       	ldi	r28, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     6de:	80 91 3b 01 	lds	r24, 0x013B
     6e2:	81 11       	cpse	r24, r1
     6e4:	f0 cf       	rjmp	.-32     	; 0x6c6 <xTaskResumeAll+0xaa>
     6e6:	e9 cf       	rjmp	.-46     	; 0x6ba <xTaskResumeAll+0x9e>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     6e8:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     6ec:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     6ee:	0f 90       	pop	r0
     6f0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	1f 91       	pop	r17
     6f8:	0f 91       	pop	r16
     6fa:	ff 90       	pop	r15
     6fc:	ef 90       	pop	r14
     6fe:	08 95       	ret

00000700 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     700:	28 c0       	rjmp	.+80     	; 0x752 <prvIdleTask+0x52>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     702:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     706:	c0 91 86 01 	lds	r28, 0x0186
			}
			( void ) xTaskResumeAll();
     70a:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     70e:	cc 23       	and	r28, r28
     710:	01 f1       	breq	.+64     	; 0x752 <prvIdleTask+0x52>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     718:	e0 91 8b 01 	lds	r30, 0x018B
     71c:	f0 91 8c 01 	lds	r31, 0x018C
     720:	c6 81       	ldd	r28, Z+6	; 0x06
     722:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     724:	ce 01       	movw	r24, r28
     726:	02 96       	adiw	r24, 0x02	; 2
     728:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					--uxCurrentNumberOfTasks;
     72c:	80 91 40 01 	lds	r24, 0x0140
     730:	81 50       	subi	r24, 0x01	; 1
     732:	80 93 40 01 	sts	0x0140, r24
					--uxTasksDeleted;
     736:	80 91 41 01 	lds	r24, 0x0141
     73a:	81 50       	subi	r24, 0x01	; 1
     73c:	80 93 41 01 	sts	0x0141, r24
				}
				taskEXIT_CRITICAL();
     740:	0f 90       	pop	r0
     742:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
     744:	8f 89       	ldd	r24, Y+23	; 0x17
     746:	98 8d       	ldd	r25, Y+24	; 0x18
     748:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
     74c:	ce 01       	movw	r24, r28
     74e:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     752:	80 91 41 01 	lds	r24, 0x0141
     756:	81 11       	cpse	r24, r1
     758:	d4 cf       	rjmp	.-88     	; 0x702 <prvIdleTask+0x2>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     75a:	80 91 47 01 	lds	r24, 0x0147
     75e:	82 30       	cpi	r24, 0x02	; 2
     760:	10 f0       	brcs	.+4      	; 0x766 <prvIdleTask+0x66>
			{
				taskYIELD();
     762:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     766:	0e 94 74 00 	call	0xe8	; 0xe8 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     76a:	f3 cf       	rjmp	.-26     	; 0x752 <prvIdleTask+0x52>

0000076c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	8c 01       	movw	r16, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     776:	00 97       	sbiw	r24, 0x00	; 0
     778:	19 f4       	brne	.+6      	; 0x780 <vTaskDelay+0x14>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     77a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
     77e:	16 c0       	rjmp	.+44     	; 0x7ac <vTaskDelay+0x40>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     780:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     784:	c0 91 3e 01 	lds	r28, 0x013E
     788:	d0 91 3f 01 	lds	r29, 0x013F
     78c:	c0 0f       	add	r28, r16
     78e:	d1 1f       	adc	r29, r17

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     790:	80 91 36 01 	lds	r24, 0x0136
     794:	90 91 37 01 	lds	r25, 0x0137
     798:	02 96       	adiw	r24, 0x02	; 2
     79a:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     79e:	ce 01       	movw	r24, r28
     7a0:	0e 94 90 00 	call	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     7a4:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     7a8:	88 23       	and	r24, r24
     7aa:	39 f3       	breq	.-50     	; 0x77a <vTaskDelay+0xe>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	1f 91       	pop	r17
     7b2:	0f 91       	pop	r16
     7b4:	08 95       	ret

000007b6 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     7b6:	0f 93       	push	r16
     7b8:	1f 93       	push	r17
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	8c 01       	movw	r16, r24
     7c0:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     7c2:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     7c6:	40 91 3e 01 	lds	r20, 0x013E
     7ca:	50 91 3f 01 	lds	r21, 0x013F

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     7ce:	f8 01       	movw	r30, r16
     7d0:	20 81       	ld	r18, Z
     7d2:	31 81       	ldd	r19, Z+1	; 0x01
     7d4:	c2 0f       	add	r28, r18
     7d6:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
     7d8:	42 17       	cp	r20, r18
     7da:	53 07       	cpc	r21, r19
     7dc:	28 f4       	brcc	.+10     	; 0x7e8 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     7de:	c2 17       	cp	r28, r18
     7e0:	d3 07       	cpc	r29, r19
     7e2:	48 f4       	brcc	.+18     	; 0x7f6 <vTaskDelayUntil+0x40>
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	04 c0       	rjmp	.+8      	; 0x7f0 <vTaskDelayUntil+0x3a>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     7e8:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     7ea:	c2 17       	cp	r28, r18
     7ec:	d3 07       	cpc	r29, r19
     7ee:	20 f0       	brcs	.+8      	; 0x7f8 <vTaskDelayUntil+0x42>
     7f0:	4c 17       	cp	r20, r28
     7f2:	5d 07       	cpc	r21, r29
     7f4:	08 f0       	brcs	.+2      	; 0x7f8 <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     7f6:	80 e0       	ldi	r24, 0x00	; 0
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     7f8:	f8 01       	movw	r30, r16
     7fa:	d1 83       	std	Z+1, r29	; 0x01
     7fc:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     7fe:	88 23       	and	r24, r24
     800:	51 f0       	breq	.+20     	; 0x816 <vTaskDelayUntil+0x60>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     802:	80 91 36 01 	lds	r24, 0x0136
     806:	90 91 37 01 	lds	r25, 0x0137
     80a:	02 96       	adiw	r24, 0x02	; 2
     80c:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     810:	ce 01       	movw	r24, r28
     812:	0e 94 90 00 	call	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     816:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     81a:	81 11       	cpse	r24, r1
     81c:	02 c0       	rjmp	.+4      	; 0x822 <vTaskDelayUntil+0x6c>
		{
			portYIELD_WITHIN_API();
     81e:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	1f 91       	pop	r17
     828:	0f 91       	pop	r16
     82a:	08 95       	ret

0000082c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     82c:	80 91 38 01 	lds	r24, 0x0138
     830:	88 23       	and	r24, r24
     832:	21 f0       	breq	.+8      	; 0x83c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	80 93 3a 01 	sts	0x013A, r24
     83a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     83c:	10 92 3a 01 	sts	0x013A, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     840:	99 e0       	ldi	r25, 0x09	; 9
     842:	05 c0       	rjmp	.+10     	; 0x84e <vTaskSwitchContext+0x22>
     844:	80 91 3d 01 	lds	r24, 0x013D
     848:	81 50       	subi	r24, 0x01	; 1
     84a:	80 93 3d 01 	sts	0x013D, r24
     84e:	e0 91 3d 01 	lds	r30, 0x013D
     852:	9e 9f       	mul	r25, r30
     854:	f0 01       	movw	r30, r0
     856:	11 24       	eor	r1, r1
     858:	e9 5b       	subi	r30, 0xB9	; 185
     85a:	fe 4f       	sbci	r31, 0xFE	; 254
     85c:	80 81       	ld	r24, Z
     85e:	88 23       	and	r24, r24
     860:	89 f3       	breq	.-30     	; 0x844 <vTaskSwitchContext+0x18>
     862:	e0 91 3d 01 	lds	r30, 0x013D
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 9f       	mul	r30, r24
     86a:	f0 01       	movw	r30, r0
     86c:	11 24       	eor	r1, r1
     86e:	e9 5b       	subi	r30, 0xB9	; 185
     870:	fe 4f       	sbci	r31, 0xFE	; 254
     872:	a1 81       	ldd	r26, Z+1	; 0x01
     874:	b2 81       	ldd	r27, Z+2	; 0x02
     876:	12 96       	adiw	r26, 0x02	; 2
     878:	0d 90       	ld	r0, X+
     87a:	bc 91       	ld	r27, X
     87c:	a0 2d       	mov	r26, r0
     87e:	b2 83       	std	Z+2, r27	; 0x02
     880:	a1 83       	std	Z+1, r26	; 0x01
     882:	cf 01       	movw	r24, r30
     884:	03 96       	adiw	r24, 0x03	; 3
     886:	a8 17       	cp	r26, r24
     888:	b9 07       	cpc	r27, r25
     88a:	31 f4       	brne	.+12     	; 0x898 <vTaskSwitchContext+0x6c>
     88c:	12 96       	adiw	r26, 0x02	; 2
     88e:	8d 91       	ld	r24, X+
     890:	9c 91       	ld	r25, X
     892:	13 97       	sbiw	r26, 0x03	; 3
     894:	92 83       	std	Z+2, r25	; 0x02
     896:	81 83       	std	Z+1, r24	; 0x01
     898:	01 80       	ldd	r0, Z+1	; 0x01
     89a:	f2 81       	ldd	r31, Z+2	; 0x02
     89c:	e0 2d       	mov	r30, r0
     89e:	86 81       	ldd	r24, Z+6	; 0x06
     8a0:	97 81       	ldd	r25, Z+7	; 0x07
     8a2:	90 93 37 01 	sts	0x0137, r25
     8a6:	80 93 36 01 	sts	0x0136, r24
     8aa:	08 95       	ret

000008ac <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     8b2:	60 91 36 01 	lds	r22, 0x0136
     8b6:	70 91 37 01 	lds	r23, 0x0137
     8ba:	64 5f       	subi	r22, 0xF4	; 244
     8bc:	7f 4f       	sbci	r23, 0xFF	; 255
     8be:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     8c2:	80 91 36 01 	lds	r24, 0x0136
     8c6:	90 91 37 01 	lds	r25, 0x0137
     8ca:	02 96       	adiw	r24, 0x02	; 2
     8cc:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
     8d0:	80 91 3e 01 	lds	r24, 0x013E
     8d4:	90 91 3f 01 	lds	r25, 0x013F
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     8d8:	8c 0f       	add	r24, r28
     8da:	9d 1f       	adc	r25, r29
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     8e0:	0c 94 90 00 	jmp	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>

000008e4 <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     8e4:	cf 93       	push	r28
     8e6:	df 93       	push	r29
     8e8:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     8ea:	e0 91 36 01 	lds	r30, 0x0136
     8ee:	f0 91 37 01 	lds	r31, 0x0137
     8f2:	70 68       	ori	r23, 0x80	; 128
     8f4:	75 87       	std	Z+13, r23	; 0x0d
     8f6:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     8f8:	60 91 36 01 	lds	r22, 0x0136
     8fc:	70 91 37 01 	lds	r23, 0x0137
     900:	64 5f       	subi	r22, 0xF4	; 244
     902:	7f 4f       	sbci	r23, 0xFF	; 255
     904:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     908:	80 91 36 01 	lds	r24, 0x0136
     90c:	90 91 37 01 	lds	r25, 0x0137
     910:	02 96       	adiw	r24, 0x02	; 2
     912:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
     916:	80 91 3e 01 	lds	r24, 0x013E
     91a:	90 91 3f 01 	lds	r25, 0x013F
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     91e:	8c 0f       	add	r24, r28
     920:	9d 1f       	adc	r25, r29
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     922:	df 91       	pop	r29
     924:	cf 91       	pop	r28
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     926:	0c 94 90 00 	jmp	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>

0000092a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     92a:	0f 93       	push	r16
     92c:	1f 93       	push	r17
     92e:	cf 93       	push	r28
     930:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     932:	dc 01       	movw	r26, r24
     934:	15 96       	adiw	r26, 0x05	; 5
     936:	ed 91       	ld	r30, X+
     938:	fc 91       	ld	r31, X
     93a:	16 97       	sbiw	r26, 0x06	; 6
     93c:	c6 81       	ldd	r28, Z+6	; 0x06
     93e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     940:	8e 01       	movw	r16, r28
     942:	04 5f       	subi	r16, 0xF4	; 244
     944:	1f 4f       	sbci	r17, 0xFF	; 255
     946:	c8 01       	movw	r24, r16
     948:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     94c:	80 91 38 01 	lds	r24, 0x0138
     950:	81 11       	cpse	r24, r1
     952:	15 c0       	rjmp	.+42     	; 0x97e <xTaskRemoveFromEventList+0x54>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     954:	8e 01       	movw	r16, r28
     956:	0e 5f       	subi	r16, 0xFE	; 254
     958:	1f 4f       	sbci	r17, 0xFF	; 255
     95a:	c8 01       	movw	r24, r16
     95c:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     960:	8e 89       	ldd	r24, Y+22	; 0x16
     962:	90 91 3d 01 	lds	r25, 0x013D
     966:	98 17       	cp	r25, r24
     968:	10 f4       	brcc	.+4      	; 0x96e <xTaskRemoveFromEventList+0x44>
     96a:	80 93 3d 01 	sts	0x013D, r24
     96e:	b9 e0       	ldi	r27, 0x09	; 9
     970:	8b 9f       	mul	r24, r27
     972:	c0 01       	movw	r24, r0
     974:	11 24       	eor	r1, r1
     976:	b8 01       	movw	r22, r16
     978:	89 5b       	subi	r24, 0xB9	; 185
     97a:	9e 4f       	sbci	r25, 0xFE	; 254
     97c:	03 c0       	rjmp	.+6      	; 0x984 <xTaskRemoveFromEventList+0x5a>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     97e:	b8 01       	movw	r22, r16
     980:	8d e7       	ldi	r24, 0x7D	; 125
     982:	91 e0       	ldi	r25, 0x01	; 1
     984:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     988:	e0 91 36 01 	lds	r30, 0x0136
     98c:	f0 91 37 01 	lds	r31, 0x0137
     990:	9e 89       	ldd	r25, Y+22	; 0x16
     992:	86 89       	ldd	r24, Z+22	; 0x16
     994:	89 17       	cp	r24, r25
     996:	20 f4       	brcc	.+8      	; 0x9a0 <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	80 93 3a 01 	sts	0x013A, r24
     99e:	01 c0       	rjmp	.+2      	; 0x9a2 <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		xReturn = pdFALSE;
     9a0:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     9a2:	df 91       	pop	r29
     9a4:	cf 91       	pop	r28
     9a6:	1f 91       	pop	r17
     9a8:	0f 91       	pop	r16
     9aa:	08 95       	ret

000009ac <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     9b4:	70 68       	ori	r23, 0x80	; 128
     9b6:	fc 01       	movw	r30, r24
     9b8:	71 83       	std	Z+1, r23	; 0x01
     9ba:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
     9bc:	c6 81       	ldd	r28, Z+6	; 0x06
     9be:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     9c0:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     9c4:	8e 01       	movw	r16, r28
     9c6:	0e 5f       	subi	r16, 0xFE	; 254
     9c8:	1f 4f       	sbci	r17, 0xFF	; 255
     9ca:	c8 01       	movw	r24, r16
     9cc:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     9d0:	8e 89       	ldd	r24, Y+22	; 0x16
     9d2:	90 91 3d 01 	lds	r25, 0x013D
     9d6:	98 17       	cp	r25, r24
     9d8:	10 f4       	brcc	.+4      	; 0x9de <xTaskRemoveFromUnorderedEventList+0x32>
     9da:	80 93 3d 01 	sts	0x013D, r24
     9de:	f9 e0       	ldi	r31, 0x09	; 9
     9e0:	8f 9f       	mul	r24, r31
     9e2:	c0 01       	movw	r24, r0
     9e4:	11 24       	eor	r1, r1
     9e6:	b8 01       	movw	r22, r16
     9e8:	89 5b       	subi	r24, 0xB9	; 185
     9ea:	9e 4f       	sbci	r25, 0xFE	; 254
     9ec:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     9f0:	e0 91 36 01 	lds	r30, 0x0136
     9f4:	f0 91 37 01 	lds	r31, 0x0137
     9f8:	9e 89       	ldd	r25, Y+22	; 0x16
     9fa:	86 89       	ldd	r24, Z+22	; 0x16
     9fc:	89 17       	cp	r24, r25
     9fe:	20 f4       	brcc	.+8      	; 0xa08 <xTaskRemoveFromUnorderedEventList+0x5c>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	80 93 3a 01 	sts	0x013A, r24
     a06:	01 c0       	rjmp	.+2      	; 0xa0a <xTaskRemoveFromUnorderedEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     a08:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	08 95       	ret

00000a14 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     a14:	20 91 39 01 	lds	r18, 0x0139
     a18:	fc 01       	movw	r30, r24
     a1a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     a1c:	20 91 3e 01 	lds	r18, 0x013E
     a20:	30 91 3f 01 	lds	r19, 0x013F
     a24:	32 83       	std	Z+2, r19	; 0x02
     a26:	21 83       	std	Z+1, r18	; 0x01
     a28:	08 95       	ret

00000a2a <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     a2a:	0f b6       	in	r0, 0x3f	; 63
     a2c:	f8 94       	cli
     a2e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     a30:	40 91 3e 01 	lds	r20, 0x013E
     a34:	50 91 3f 01 	lds	r21, 0x013F
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     a38:	f0 91 39 01 	lds	r31, 0x0139
     a3c:	dc 01       	movw	r26, r24
     a3e:	ec 91       	ld	r30, X
     a40:	11 96       	adiw	r26, 0x01	; 1
     a42:	2d 91       	ld	r18, X+
     a44:	3c 91       	ld	r19, X
     a46:	12 97       	sbiw	r26, 0x02	; 2
     a48:	fe 17       	cp	r31, r30
     a4a:	19 f0       	breq	.+6      	; 0xa52 <xTaskCheckForTimeOut+0x28>
     a4c:	42 17       	cp	r20, r18
     a4e:	53 07       	cpc	r21, r19
     a50:	a0 f4       	brcc	.+40     	; 0xa7a <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
     a52:	db 01       	movw	r26, r22
     a54:	ed 91       	ld	r30, X+
     a56:	fc 91       	ld	r31, X
     a58:	da 01       	movw	r26, r20
     a5a:	a2 1b       	sub	r26, r18
     a5c:	b3 0b       	sbc	r27, r19
     a5e:	ae 17       	cp	r26, r30
     a60:	bf 07       	cpc	r27, r31
     a62:	58 f4       	brcc	.+22     	; 0xa7a <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
     a64:	24 1b       	sub	r18, r20
     a66:	35 0b       	sbc	r19, r21
     a68:	2e 0f       	add	r18, r30
     a6a:	3f 1f       	adc	r19, r31
     a6c:	fb 01       	movw	r30, r22
     a6e:	31 83       	std	Z+1, r19	; 0x01
     a70:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
     a72:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
     a76:	80 e0       	ldi	r24, 0x00	; 0
     a78:	01 c0       	rjmp	.+2      	; 0xa7c <xTaskCheckForTimeOut+0x52>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
     a7a:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     a7c:	0f 90       	pop	r0
     a7e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     a80:	08 95       	ret

00000a82 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	80 93 3a 01 	sts	0x013A, r24
     a88:	08 95       	ret

00000a8a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     a8a:	e0 91 36 01 	lds	r30, 0x0136
     a8e:	f0 91 37 01 	lds	r31, 0x0137
     a92:	84 85       	ldd	r24, Z+12	; 0x0c
     a94:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a96:	e0 91 36 01 	lds	r30, 0x0136
     a9a:	f0 91 37 01 	lds	r31, 0x0137
     a9e:	a0 91 36 01 	lds	r26, 0x0136
     aa2:	b0 91 37 01 	lds	r27, 0x0137
     aa6:	56 96       	adiw	r26, 0x16	; 22
     aa8:	4c 91       	ld	r20, X
     aaa:	24 e0       	ldi	r18, 0x04	; 4
     aac:	30 e0       	ldi	r19, 0x00	; 0
     aae:	24 1b       	sub	r18, r20
     ab0:	31 09       	sbc	r19, r1
     ab2:	35 87       	std	Z+13, r19	; 0x0d
     ab4:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     ab6:	08 95       	ret

00000ab8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     ab8:	0f 93       	push	r16
     aba:	1f 93       	push	r17
     abc:	cf 93       	push	r28
     abe:	c8 2f       	mov	r28, r24
     ac0:	8b 01       	movw	r16, r22
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     ac2:	0f b6       	in	r0, 0x3f	; 63
     ac4:	f8 94       	cli
     ac6:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     ac8:	e0 91 36 01 	lds	r30, 0x0136
     acc:	f0 91 37 01 	lds	r31, 0x0137
     ad0:	41 a1       	ldd	r20, Z+33	; 0x21
     ad2:	52 a1       	ldd	r21, Z+34	; 0x22
     ad4:	63 a1       	ldd	r22, Z+35	; 0x23
     ad6:	74 a1       	ldd	r23, Z+36	; 0x24
     ad8:	45 2b       	or	r20, r21
     ada:	46 2b       	or	r20, r22
     adc:	47 2b       	or	r20, r23
     ade:	d1 f4       	brne	.+52     	; 0xb14 <ulTaskNotifyTake+0x5c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
     ae0:	e0 91 36 01 	lds	r30, 0x0136
     ae4:	f0 91 37 01 	lds	r31, 0x0137
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     aec:	01 15       	cp	r16, r1
     aee:	11 05       	cpc	r17, r1
     af0:	89 f0       	breq	.+34     	; 0xb14 <ulTaskNotifyTake+0x5c>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     af2:	80 91 36 01 	lds	r24, 0x0136
     af6:	90 91 37 01 	lds	r25, 0x0137
     afa:	02 96       	adiw	r24, 0x02	; 2
     afc:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
     b00:	80 91 3e 01 	lds	r24, 0x013E
     b04:	90 91 3f 01 	lds	r25, 0x013F
							prvAddCurrentTaskToDelayedList( xTimeToWake );
     b08:	80 0f       	add	r24, r16
     b0a:	91 1f       	adc	r25, r17
     b0c:	0e 94 90 00 	call	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     b10:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     b14:	0f 90       	pop	r0
     b16:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     b18:	0f b6       	in	r0, 0x3f	; 63
     b1a:	f8 94       	cli
     b1c:	0f 92       	push	r0
		{
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     b1e:	e0 91 36 01 	lds	r30, 0x0136
     b22:	f0 91 37 01 	lds	r31, 0x0137
     b26:	01 a1       	ldd	r16, Z+33	; 0x21
     b28:	12 a1       	ldd	r17, Z+34	; 0x22
     b2a:	23 a1       	ldd	r18, Z+35	; 0x23
     b2c:	34 a1       	ldd	r19, Z+36	; 0x24

			if( ulReturn != 0UL )
     b2e:	01 15       	cp	r16, r1
     b30:	11 05       	cpc	r17, r1
     b32:	21 05       	cpc	r18, r1
     b34:	31 05       	cpc	r19, r1
     b36:	b1 f0       	breq	.+44     	; 0xb64 <ulTaskNotifyTake+0xac>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     b38:	e0 91 36 01 	lds	r30, 0x0136
     b3c:	f0 91 37 01 	lds	r31, 0x0137
		{
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     b40:	cc 23       	and	r28, r28
     b42:	29 f0       	breq	.+10     	; 0xb4e <ulTaskNotifyTake+0x96>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     b44:	11 a2       	std	Z+33, r1	; 0x21
     b46:	12 a2       	std	Z+34, r1	; 0x22
     b48:	13 a2       	std	Z+35, r1	; 0x23
     b4a:	14 a2       	std	Z+36, r1	; 0x24
     b4c:	0b c0       	rjmp	.+22     	; 0xb64 <ulTaskNotifyTake+0xac>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
     b4e:	81 a1       	ldd	r24, Z+33	; 0x21
     b50:	92 a1       	ldd	r25, Z+34	; 0x22
     b52:	a3 a1       	ldd	r26, Z+35	; 0x23
     b54:	b4 a1       	ldd	r27, Z+36	; 0x24
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	a1 09       	sbc	r26, r1
     b5a:	b1 09       	sbc	r27, r1
     b5c:	81 a3       	std	Z+33, r24	; 0x21
     b5e:	92 a3       	std	Z+34, r25	; 0x22
     b60:	a3 a3       	std	Z+35, r26	; 0x23
     b62:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
     b64:	e0 91 36 01 	lds	r30, 0x0136
     b68:	f0 91 37 01 	lds	r31, 0x0137
     b6c:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     b6e:	0f 90       	pop	r0
     b70:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     b72:	b8 01       	movw	r22, r16
     b74:	c9 01       	movw	r24, r18
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	08 95       	ret

00000b7e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     b7e:	4f 92       	push	r4
     b80:	5f 92       	push	r5
     b82:	6f 92       	push	r6
     b84:	7f 92       	push	r7
     b86:	8f 92       	push	r8
     b88:	9f 92       	push	r9
     b8a:	af 92       	push	r10
     b8c:	bf 92       	push	r11
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	00 d0       	rcall	.+0      	; 0xb9c <xTaskNotifyWait+0x1e>
     b9c:	00 d0       	rcall	.+0      	; 0xb9e <xTaskNotifyWait+0x20>
     b9e:	cd b7       	in	r28, 0x3d	; 61
     ba0:	de b7       	in	r29, 0x3e	; 62
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
     ba8:	e0 91 36 01 	lds	r30, 0x0136
     bac:	f0 91 37 01 	lds	r31, 0x0137
     bb0:	e5 a1       	ldd	r30, Z+37	; 0x25
     bb2:	e2 30       	cpi	r30, 0x02	; 2
     bb4:	c1 f1       	breq	.+112    	; 0xc26 <xTaskNotifyWait+0xa8>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     bb6:	e0 91 36 01 	lds	r30, 0x0136
     bba:	f0 91 37 01 	lds	r31, 0x0137
     bbe:	41 a0       	ldd	r4, Z+33	; 0x21
     bc0:	52 a0       	ldd	r5, Z+34	; 0x22
     bc2:	63 a0       	ldd	r6, Z+35	; 0x23
     bc4:	74 a0       	ldd	r7, Z+36	; 0x24
     bc6:	dc 01       	movw	r26, r24
     bc8:	cb 01       	movw	r24, r22
     bca:	80 95       	com	r24
     bcc:	90 95       	com	r25
     bce:	a0 95       	com	r26
     bd0:	b0 95       	com	r27
     bd2:	84 21       	and	r24, r4
     bd4:	95 21       	and	r25, r5
     bd6:	a6 21       	and	r26, r6
     bd8:	b7 21       	and	r27, r7
     bda:	81 a3       	std	Z+33, r24	; 0x21
     bdc:	92 a3       	std	Z+34, r25	; 0x22
     bde:	a3 a3       	std	Z+35, r26	; 0x23
     be0:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
     be2:	e0 91 36 01 	lds	r30, 0x0136
     be6:	f0 91 37 01 	lds	r31, 0x0137
     bea:	81 e0       	ldi	r24, 0x01	; 1
     bec:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     bee:	e1 14       	cp	r14, r1
     bf0:	f1 04       	cpc	r15, r1
     bf2:	c9 f0       	breq	.+50     	; 0xc26 <xTaskNotifyWait+0xa8>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     bf4:	80 91 36 01 	lds	r24, 0x0136
     bf8:	90 91 37 01 	lds	r25, 0x0137
     bfc:	02 96       	adiw	r24, 0x02	; 2
     bfe:	29 83       	std	Y+1, r18	; 0x01
     c00:	3a 83       	std	Y+2, r19	; 0x02
     c02:	4b 83       	std	Y+3, r20	; 0x03
     c04:	5c 83       	std	Y+4, r21	; 0x04
     c06:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
     c0a:	80 91 3e 01 	lds	r24, 0x013E
     c0e:	90 91 3f 01 	lds	r25, 0x013F
							prvAddCurrentTaskToDelayedList( xTimeToWake );
     c12:	8e 0d       	add	r24, r14
     c14:	9f 1d       	adc	r25, r15
     c16:	0e 94 90 00 	call	0x120	; 0x120 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     c1a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
     c1e:	5c 81       	ldd	r21, Y+4	; 0x04
     c20:	4b 81       	ldd	r20, Y+3	; 0x03
     c22:	3a 81       	ldd	r19, Y+2	; 0x02
     c24:	29 81       	ldd	r18, Y+1	; 0x01
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     c26:	0f 90       	pop	r0
     c28:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     c2a:	0f b6       	in	r0, 0x3f	; 63
     c2c:	f8 94       	cli
     c2e:	0f 92       	push	r0
		{
			if( pulNotificationValue != NULL )
     c30:	01 15       	cp	r16, r1
     c32:	11 05       	cpc	r17, r1
     c34:	69 f0       	breq	.+26     	; 0xc50 <xTaskNotifyWait+0xd2>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     c36:	e0 91 36 01 	lds	r30, 0x0136
     c3a:	f0 91 37 01 	lds	r31, 0x0137
     c3e:	81 a1       	ldd	r24, Z+33	; 0x21
     c40:	92 a1       	ldd	r25, Z+34	; 0x22
     c42:	a3 a1       	ldd	r26, Z+35	; 0x23
     c44:	b4 a1       	ldd	r27, Z+36	; 0x24
     c46:	f8 01       	movw	r30, r16
     c48:	80 83       	st	Z, r24
     c4a:	91 83       	std	Z+1, r25	; 0x01
     c4c:	a2 83       	std	Z+2, r26	; 0x02
     c4e:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
     c50:	e0 91 36 01 	lds	r30, 0x0136
     c54:	f0 91 37 01 	lds	r31, 0x0137
     c58:	85 a1       	ldd	r24, Z+37	; 0x25
     c5a:	81 30       	cpi	r24, 0x01	; 1
     c5c:	c1 f0       	breq	.+48     	; 0xc8e <xTaskNotifyWait+0x110>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     c5e:	e0 91 36 01 	lds	r30, 0x0136
     c62:	f0 91 37 01 	lds	r31, 0x0137
     c66:	81 a0       	ldd	r8, Z+33	; 0x21
     c68:	92 a0       	ldd	r9, Z+34	; 0x22
     c6a:	a3 a0       	ldd	r10, Z+35	; 0x23
     c6c:	b4 a0       	ldd	r11, Z+36	; 0x24
     c6e:	da 01       	movw	r26, r20
     c70:	c9 01       	movw	r24, r18
     c72:	80 95       	com	r24
     c74:	90 95       	com	r25
     c76:	a0 95       	com	r26
     c78:	b0 95       	com	r27
     c7a:	88 21       	and	r24, r8
     c7c:	99 21       	and	r25, r9
     c7e:	aa 21       	and	r26, r10
     c80:	bb 21       	and	r27, r11
     c82:	81 a3       	std	Z+33, r24	; 0x21
     c84:	92 a3       	std	Z+34, r25	; 0x22
     c86:	a3 a3       	std	Z+35, r26	; 0x23
     c88:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	01 c0       	rjmp	.+2      	; 0xc90 <xTaskNotifyWait+0x112>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
     c90:	e0 91 36 01 	lds	r30, 0x0136
     c94:	f0 91 37 01 	lds	r31, 0x0137
     c98:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     c9a:	0f 90       	pop	r0
     c9c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     c9e:	0f 90       	pop	r0
     ca0:	0f 90       	pop	r0
     ca2:	0f 90       	pop	r0
     ca4:	0f 90       	pop	r0
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
     cb2:	bf 90       	pop	r11
     cb4:	af 90       	pop	r10
     cb6:	9f 90       	pop	r9
     cb8:	8f 90       	pop	r8
     cba:	7f 90       	pop	r7
     cbc:	6f 90       	pop	r6
     cbe:	5f 90       	pop	r5
     cc0:	4f 90       	pop	r4
     cc2:	08 95       	ret

00000cc4 <xTaskNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction )
	{
     cc4:	0f 93       	push	r16
     cc6:	1f 93       	push	r17
     cc8:	cf 93       	push	r28
     cca:	df 93       	push	r29
     ccc:	ec 01       	movw	r28, r24
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
     cce:	0f b6       	in	r0, 0x3f	; 63
     cd0:	f8 94       	cli
     cd2:	0f 92       	push	r0
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
     cd4:	3d a1       	ldd	r19, Y+37	; 0x25

			pxTCB->eNotifyState = eNotified;
     cd6:	82 e0       	ldi	r24, 0x02	; 2
     cd8:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     cda:	22 30       	cpi	r18, 0x02	; 2
     cdc:	b1 f0       	breq	.+44     	; 0xd0a <xTaskNotify+0x46>
     cde:	18 f4       	brcc	.+6      	; 0xce6 <xTaskNotify+0x22>
     ce0:	21 30       	cpi	r18, 0x01	; 1
     ce2:	11 f5       	brne	.+68     	; 0xd28 <xTaskNotify+0x64>
     ce4:	05 c0       	rjmp	.+10     	; 0xcf0 <xTaskNotify+0x2c>
     ce6:	23 30       	cpi	r18, 0x03	; 3
     ce8:	d9 f0       	breq	.+54     	; 0xd20 <xTaskNotify+0x5c>
     cea:	24 30       	cpi	r18, 0x04	; 4
     cec:	e9 f4       	brne	.+58     	; 0xd28 <xTaskNotify+0x64>
     cee:	16 c0       	rjmp	.+44     	; 0xd1c <xTaskNotify+0x58>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     cf0:	89 a1       	ldd	r24, Y+33	; 0x21
     cf2:	9a a1       	ldd	r25, Y+34	; 0x22
     cf4:	ab a1       	ldd	r26, Y+35	; 0x23
     cf6:	bc a1       	ldd	r27, Y+36	; 0x24
     cf8:	84 2b       	or	r24, r20
     cfa:	95 2b       	or	r25, r21
     cfc:	a6 2b       	or	r26, r22
     cfe:	b7 2b       	or	r27, r23
     d00:	89 a3       	std	Y+33, r24	; 0x21
     d02:	9a a3       	std	Y+34, r25	; 0x22
     d04:	ab a3       	std	Y+35, r26	; 0x23
     d06:	bc a3       	std	Y+36, r27	; 0x24
					break;
     d08:	0f c0       	rjmp	.+30     	; 0xd28 <xTaskNotify+0x64>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     d0a:	49 a1       	ldd	r20, Y+33	; 0x21
     d0c:	5a a1       	ldd	r21, Y+34	; 0x22
     d0e:	6b a1       	ldd	r22, Y+35	; 0x23
     d10:	7c a1       	ldd	r23, Y+36	; 0x24
     d12:	4f 5f       	subi	r20, 0xFF	; 255
     d14:	5f 4f       	sbci	r21, 0xFF	; 255
     d16:	6f 4f       	sbci	r22, 0xFF	; 255
     d18:	7f 4f       	sbci	r23, 0xFF	; 255
     d1a:	02 c0       	rjmp	.+4      	; 0xd20 <xTaskNotify+0x5c>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
     d1c:	32 30       	cpi	r19, 0x02	; 2
     d1e:	49 f1       	breq	.+82     	; 0xd72 <xTaskNotify+0xae>
					{
						pxTCB->ulNotifiedValue = ulValue;
     d20:	49 a3       	std	Y+33, r20	; 0x21
     d22:	5a a3       	std	Y+34, r21	; 0x22
     d24:	6b a3       	std	Y+35, r22	; 0x23
     d26:	7c a3       	std	Y+36, r23	; 0x24
			}


			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
     d28:	31 30       	cpi	r19, 0x01	; 1
     d2a:	09 f0       	breq	.+2      	; 0xd2e <xTaskNotify+0x6a>
     d2c:	20 c0       	rjmp	.+64     	; 0xd6e <xTaskNotify+0xaa>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     d2e:	8e 01       	movw	r16, r28
     d30:	0e 5f       	subi	r16, 0xFE	; 254
     d32:	1f 4f       	sbci	r17, 0xFF	; 255
     d34:	c8 01       	movw	r24, r16
     d36:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     d3a:	8e 89       	ldd	r24, Y+22	; 0x16
     d3c:	90 91 3d 01 	lds	r25, 0x013D
     d40:	98 17       	cp	r25, r24
     d42:	10 f4       	brcc	.+4      	; 0xd48 <xTaskNotify+0x84>
     d44:	80 93 3d 01 	sts	0x013D, r24
     d48:	29 e0       	ldi	r18, 0x09	; 9
     d4a:	82 9f       	mul	r24, r18
     d4c:	c0 01       	movw	r24, r0
     d4e:	11 24       	eor	r1, r1
     d50:	b8 01       	movw	r22, r16
     d52:	89 5b       	subi	r24, 0xB9	; 185
     d54:	9e 4f       	sbci	r25, 0xFE	; 254
     d56:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     d5a:	e0 91 36 01 	lds	r30, 0x0136
     d5e:	f0 91 37 01 	lds	r31, 0x0137
     d62:	9e 89       	ldd	r25, Y+22	; 0x16
     d64:	86 89       	ldd	r24, Z+22	; 0x16
     d66:	89 17       	cp	r24, r25
     d68:	10 f4       	brcc	.+4      	; 0xd6e <xTaskNotify+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					portYIELD_WITHIN_API();
     d6a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	01 c0       	rjmp	.+2      	; 0xd74 <xTaskNotify+0xb0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     d72:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     d74:	0f 90       	pop	r0
     d76:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	1f 91       	pop	r17
     d7e:	0f 91       	pop	r16
     d80:	08 95       	ret

00000d82 <xTaskNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
	{
     d82:	ef 92       	push	r14
     d84:	ff 92       	push	r15
     d86:	0f 93       	push	r16
     d88:	1f 93       	push	r17
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29
     d8e:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
     d90:	3d a1       	ldd	r19, Y+37	; 0x25

			pxTCB->eNotifyState = eNotified;
     d92:	82 e0       	ldi	r24, 0x02	; 2
     d94:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
     d96:	22 30       	cpi	r18, 0x02	; 2
     d98:	91 f0       	breq	.+36     	; 0xdbe <xTaskNotifyFromISR+0x3c>
     d9a:	18 f4       	brcc	.+6      	; 0xda2 <xTaskNotifyFromISR+0x20>
     d9c:	21 30       	cpi	r18, 0x01	; 1
     d9e:	09 f5       	brne	.+66     	; 0xde2 <xTaskNotifyFromISR+0x60>
     da0:	05 c0       	rjmp	.+10     	; 0xdac <xTaskNotifyFromISR+0x2a>
     da2:	23 30       	cpi	r18, 0x03	; 3
     da4:	d1 f0       	breq	.+52     	; 0xdda <xTaskNotifyFromISR+0x58>
     da6:	24 30       	cpi	r18, 0x04	; 4
     da8:	e1 f4       	brne	.+56     	; 0xde2 <xTaskNotifyFromISR+0x60>
     daa:	15 c0       	rjmp	.+42     	; 0xdd6 <xTaskNotifyFromISR+0x54>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     dac:	89 a1       	ldd	r24, Y+33	; 0x21
     dae:	9a a1       	ldd	r25, Y+34	; 0x22
     db0:	ab a1       	ldd	r26, Y+35	; 0x23
     db2:	bc a1       	ldd	r27, Y+36	; 0x24
     db4:	84 2b       	or	r24, r20
     db6:	95 2b       	or	r25, r21
     db8:	a6 2b       	or	r26, r22
     dba:	b7 2b       	or	r27, r23
     dbc:	07 c0       	rjmp	.+14     	; 0xdcc <xTaskNotifyFromISR+0x4a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     dbe:	89 a1       	ldd	r24, Y+33	; 0x21
     dc0:	9a a1       	ldd	r25, Y+34	; 0x22
     dc2:	ab a1       	ldd	r26, Y+35	; 0x23
     dc4:	bc a1       	ldd	r27, Y+36	; 0x24
     dc6:	01 96       	adiw	r24, 0x01	; 1
     dc8:	a1 1d       	adc	r26, r1
     dca:	b1 1d       	adc	r27, r1
     dcc:	89 a3       	std	Y+33, r24	; 0x21
     dce:	9a a3       	std	Y+34, r25	; 0x22
     dd0:	ab a3       	std	Y+35, r26	; 0x23
     dd2:	bc a3       	std	Y+36, r27	; 0x24
					break;
     dd4:	06 c0       	rjmp	.+12     	; 0xde2 <xTaskNotifyFromISR+0x60>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
     dd6:	32 30       	cpi	r19, 0x02	; 2
     dd8:	c1 f1       	breq	.+112    	; 0xe4a <xTaskNotifyFromISR+0xc8>
					{
						pxTCB->ulNotifiedValue = ulValue;
     dda:	49 a3       	std	Y+33, r20	; 0x21
     ddc:	5a a3       	std	Y+34, r21	; 0x22
     dde:	6b a3       	std	Y+35, r22	; 0x23
     de0:	7c a3       	std	Y+36, r23	; 0x24
			}


			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
     de2:	31 30       	cpi	r19, 0x01	; 1
     de4:	11 f0       	breq	.+4      	; 0xdea <xTaskNotifyFromISR+0x68>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
	{
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	31 c0       	rjmp	.+98     	; 0xe4c <xTaskNotifyFromISR+0xca>
			if( eOriginalNotifyState == eWaitingNotification )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     dea:	80 91 38 01 	lds	r24, 0x0138
     dee:	81 11       	cpse	r24, r1
     df0:	16 c0       	rjmp	.+44     	; 0xe1e <xTaskNotifyFromISR+0x9c>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     df2:	7e 01       	movw	r14, r28
     df4:	22 e0       	ldi	r18, 0x02	; 2
     df6:	e2 0e       	add	r14, r18
     df8:	f1 1c       	adc	r15, r1
     dfa:	c7 01       	movw	r24, r14
     dfc:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     e00:	8e 89       	ldd	r24, Y+22	; 0x16
     e02:	90 91 3d 01 	lds	r25, 0x013D
     e06:	98 17       	cp	r25, r24
     e08:	10 f4       	brcc	.+4      	; 0xe0e <xTaskNotifyFromISR+0x8c>
     e0a:	80 93 3d 01 	sts	0x013D, r24
     e0e:	e9 e0       	ldi	r30, 0x09	; 9
     e10:	8e 9f       	mul	r24, r30
     e12:	c0 01       	movw	r24, r0
     e14:	11 24       	eor	r1, r1
     e16:	b7 01       	movw	r22, r14
     e18:	89 5b       	subi	r24, 0xB9	; 185
     e1a:	9e 4f       	sbci	r25, 0xFE	; 254
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <xTaskNotifyFromISR+0xa6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     e1e:	be 01       	movw	r22, r28
     e20:	64 5f       	subi	r22, 0xF4	; 244
     e22:	7f 4f       	sbci	r23, 0xFF	; 255
     e24:	8d e7       	ldi	r24, 0x7D	; 125
     e26:	91 e0       	ldi	r25, 0x01	; 1
     e28:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     e2c:	e0 91 36 01 	lds	r30, 0x0136
     e30:	f0 91 37 01 	lds	r31, 0x0137
     e34:	9e 89       	ldd	r25, Y+22	; 0x16
     e36:	86 89       	ldd	r24, Z+22	; 0x16
     e38:	89 17       	cp	r24, r25
     e3a:	a8 f6       	brcc	.-86     	; 0xde6 <xTaskNotifyFromISR+0x64>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     e3c:	01 15       	cp	r16, r1
     e3e:	11 05       	cpc	r17, r1
     e40:	91 f2       	breq	.-92     	; 0xde6 <xTaskNotifyFromISR+0x64>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	f8 01       	movw	r30, r16
     e46:	80 83       	st	Z, r24
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <xTaskNotifyFromISR+0xca>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     e4a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
     e4c:	df 91       	pop	r29
     e4e:	cf 91       	pop	r28
     e50:	1f 91       	pop	r17
     e52:	0f 91       	pop	r16
     e54:	ff 90       	pop	r15
     e56:	ef 90       	pop	r14
     e58:	08 95       	ret

00000e5a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
     e5a:	ef 92       	push	r14
     e5c:	ff 92       	push	r15
     e5e:	0f 93       	push	r16
     e60:	1f 93       	push	r17
     e62:	cf 93       	push	r28
     e64:	df 93       	push	r29
     e66:	ec 01       	movw	r28, r24
     e68:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
     e6a:	8d a1       	ldd	r24, Y+37	; 0x25
			pxTCB->eNotifyState = eNotified;
     e6c:	92 e0       	ldi	r25, 0x02	; 2
     e6e:	9d a3       	std	Y+37, r25	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
     e70:	49 a1       	ldd	r20, Y+33	; 0x21
     e72:	5a a1       	ldd	r21, Y+34	; 0x22
     e74:	6b a1       	ldd	r22, Y+35	; 0x23
     e76:	7c a1       	ldd	r23, Y+36	; 0x24
     e78:	4f 5f       	subi	r20, 0xFF	; 255
     e7a:	5f 4f       	sbci	r21, 0xFF	; 255
     e7c:	6f 4f       	sbci	r22, 0xFF	; 255
     e7e:	7f 4f       	sbci	r23, 0xFF	; 255
     e80:	49 a3       	std	Y+33, r20	; 0x21
     e82:	5a a3       	std	Y+34, r21	; 0x22
     e84:	6b a3       	std	Y+35, r22	; 0x23
     e86:	7c a3       	std	Y+36, r23	; 0x24

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
     e88:	81 30       	cpi	r24, 0x01	; 1
     e8a:	79 f5       	brne	.+94     	; 0xeea <vTaskNotifyGiveFromISR+0x90>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e8c:	80 91 38 01 	lds	r24, 0x0138
     e90:	81 11       	cpse	r24, r1
     e92:	16 c0       	rjmp	.+44     	; 0xec0 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     e94:	7e 01       	movw	r14, r28
     e96:	22 e0       	ldi	r18, 0x02	; 2
     e98:	e2 0e       	add	r14, r18
     e9a:	f1 1c       	adc	r15, r1
     e9c:	c7 01       	movw	r24, r14
     e9e:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ea2:	8e 89       	ldd	r24, Y+22	; 0x16
     ea4:	90 91 3d 01 	lds	r25, 0x013D
     ea8:	98 17       	cp	r25, r24
     eaa:	10 f4       	brcc	.+4      	; 0xeb0 <vTaskNotifyGiveFromISR+0x56>
     eac:	80 93 3d 01 	sts	0x013D, r24
     eb0:	e9 e0       	ldi	r30, 0x09	; 9
     eb2:	8e 9f       	mul	r24, r30
     eb4:	c0 01       	movw	r24, r0
     eb6:	11 24       	eor	r1, r1
     eb8:	b7 01       	movw	r22, r14
     eba:	89 5b       	subi	r24, 0xB9	; 185
     ebc:	9e 4f       	sbci	r25, 0xFE	; 254
     ebe:	05 c0       	rjmp	.+10     	; 0xeca <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     ec0:	be 01       	movw	r22, r28
     ec2:	64 5f       	subi	r22, 0xF4	; 244
     ec4:	7f 4f       	sbci	r23, 0xFF	; 255
     ec6:	8d e7       	ldi	r24, 0x7D	; 125
     ec8:	91 e0       	ldi	r25, 0x01	; 1
     eca:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     ece:	e0 91 36 01 	lds	r30, 0x0136
     ed2:	f0 91 37 01 	lds	r31, 0x0137
     ed6:	9e 89       	ldd	r25, Y+22	; 0x16
     ed8:	86 89       	ldd	r24, Z+22	; 0x16
     eda:	89 17       	cp	r24, r25
     edc:	30 f4       	brcc	.+12     	; 0xeea <vTaskNotifyGiveFromISR+0x90>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
     ede:	01 15       	cp	r16, r1
     ee0:	11 05       	cpc	r17, r1
     ee2:	19 f0       	breq	.+6      	; 0xeea <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	f8 01       	movw	r30, r16
     ee8:	80 83       	st	Z, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     eea:	df 91       	pop	r29
     eec:	cf 91       	pop	r28
     eee:	1f 91       	pop	r17
     ef0:	0f 91       	pop	r16
     ef2:	ff 90       	pop	r15
     ef4:	ef 90       	pop	r14
     ef6:	08 95       	ret

00000ef8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     ef8:	1f 93       	push	r17
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	ec 01       	movw	r28, r24
     f00:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f02:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f04:	44 23       	and	r20, r20
     f06:	d1 f1       	breq	.+116    	; 0xf7c <prvCopyDataToQueue+0x84>
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f08:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f0a:	11 11       	cpse	r17, r1
     f0c:	15 c0       	rjmp	.+42     	; 0xf38 <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f0e:	8c 81       	ldd	r24, Y+4	; 0x04
     f10:	9d 81       	ldd	r25, Y+5	; 0x05
     f12:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f16:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f18:	8c 81       	ldd	r24, Y+4	; 0x04
     f1a:	9d 81       	ldd	r25, Y+5	; 0x05
     f1c:	82 0f       	add	r24, r18
     f1e:	91 1d       	adc	r25, r1
     f20:	9d 83       	std	Y+5, r25	; 0x05
     f22:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f24:	2a 81       	ldd	r18, Y+2	; 0x02
     f26:	3b 81       	ldd	r19, Y+3	; 0x03
     f28:	82 17       	cp	r24, r18
     f2a:	93 07       	cpc	r25, r19
     f2c:	38 f1       	brcs	.+78     	; 0xf7c <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f2e:	88 81       	ld	r24, Y
     f30:	99 81       	ldd	r25, Y+1	; 0x01
     f32:	9d 83       	std	Y+5, r25	; 0x05
     f34:	8c 83       	std	Y+4, r24	; 0x04
     f36:	22 c0       	rjmp	.+68     	; 0xf7c <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f38:	8e 81       	ldd	r24, Y+6	; 0x06
     f3a:	9f 81       	ldd	r25, Y+7	; 0x07
     f3c:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f40:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f42:	30 e0       	ldi	r19, 0x00	; 0
     f44:	31 95       	neg	r19
     f46:	21 95       	neg	r18
     f48:	31 09       	sbc	r19, r1
     f4a:	8e 81       	ldd	r24, Y+6	; 0x06
     f4c:	9f 81       	ldd	r25, Y+7	; 0x07
     f4e:	82 0f       	add	r24, r18
     f50:	93 1f       	adc	r25, r19
     f52:	9f 83       	std	Y+7, r25	; 0x07
     f54:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f56:	68 81       	ld	r22, Y
     f58:	79 81       	ldd	r23, Y+1	; 0x01
     f5a:	86 17       	cp	r24, r22
     f5c:	97 07       	cpc	r25, r23
     f5e:	30 f4       	brcc	.+12     	; 0xf6c <prvCopyDataToQueue+0x74>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f60:	8a 81       	ldd	r24, Y+2	; 0x02
     f62:	9b 81       	ldd	r25, Y+3	; 0x03
     f64:	82 0f       	add	r24, r18
     f66:	93 1f       	adc	r25, r19
     f68:	9f 83       	std	Y+7, r25	; 0x07
     f6a:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     f6c:	12 30       	cpi	r17, 0x02	; 2
     f6e:	31 f4       	brne	.+12     	; 0xf7c <prvCopyDataToQueue+0x84>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     f70:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f72:	88 23       	and	r24, r24
     f74:	19 f0       	breq	.+6      	; 0xf7c <prvCopyDataToQueue+0x84>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     f76:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f78:	81 50       	subi	r24, 0x01	; 1
     f7a:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     f7c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f7e:	8f 5f       	subi	r24, 0xFF	; 255
     f80:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	08 95       	ret

00000f8c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     f8c:	fc 01       	movw	r30, r24
     f8e:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     f90:	44 8d       	ldd	r20, Z+28	; 0x1c
     f92:	44 23       	and	r20, r20
     f94:	a1 f0       	breq	.+40     	; 0xfbe <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     f96:	26 81       	ldd	r18, Z+6	; 0x06
     f98:	37 81       	ldd	r19, Z+7	; 0x07
     f9a:	24 0f       	add	r18, r20
     f9c:	31 1d       	adc	r19, r1
     f9e:	37 83       	std	Z+7, r19	; 0x07
     fa0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     fa2:	a2 81       	ldd	r26, Z+2	; 0x02
     fa4:	b3 81       	ldd	r27, Z+3	; 0x03
     fa6:	2a 17       	cp	r18, r26
     fa8:	3b 07       	cpc	r19, r27
     faa:	20 f0       	brcs	.+8      	; 0xfb4 <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     fac:	20 81       	ld	r18, Z
     fae:	31 81       	ldd	r19, Z+1	; 0x01
     fb0:	37 83       	std	Z+7, r19	; 0x07
     fb2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     fb4:	66 81       	ldd	r22, Z+6	; 0x06
     fb6:	77 81       	ldd	r23, Z+7	; 0x07
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	0c 94 eb 0f 	jmp	0x1fd6	; 0x1fd6 <memcpy>
     fbe:	08 95       	ret

00000fc0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     fc0:	0f 93       	push	r16
     fc2:	1f 93       	push	r17
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     fca:	0f b6       	in	r0, 0x3f	; 63
     fcc:	f8 94       	cli
     fce:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fd0:	8c 01       	movw	r16, r24
     fd2:	0f 5e       	subi	r16, 0xEF	; 239
     fd4:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     fd6:	0c c0       	rjmp	.+24     	; 0xff0 <prvUnlockQueue+0x30>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fd8:	89 89       	ldd	r24, Y+17	; 0x11
     fda:	88 23       	and	r24, r24
     fdc:	61 f0       	breq	.+24     	; 0xff6 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fde:	c8 01       	movw	r24, r16
     fe0:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
     fe4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     fe6:	0e 94 41 05 	call	0xa82	; 0xa82 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     fea:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fec:	81 50       	subi	r24, 0x01	; 1
     fee:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     ff0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ff2:	18 16       	cp	r1, r24
     ff4:	8c f3       	brlt	.-30     	; 0xfd8 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     ff6:	8f ef       	ldi	r24, 0xFF	; 255
     ff8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     ffa:	0f 90       	pop	r0
     ffc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     ffe:	0f b6       	in	r0, 0x3f	; 63
    1000:	f8 94       	cli
    1002:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1004:	8e 01       	movw	r16, r28
    1006:	08 5f       	subi	r16, 0xF8	; 248
    1008:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    100a:	0c c0       	rjmp	.+24     	; 0x1024 <prvUnlockQueue+0x64>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    100c:	88 85       	ldd	r24, Y+8	; 0x08
    100e:	88 23       	and	r24, r24
    1010:	61 f0       	breq	.+24     	; 0x102a <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1012:	c8 01       	movw	r24, r16
    1014:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    1018:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    101a:	0e 94 41 05 	call	0xa82	; 0xa82 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    101e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1020:	81 50       	subi	r24, 0x01	; 1
    1022:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1024:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1026:	18 16       	cp	r1, r24
    1028:	8c f3       	brlt	.-30     	; 0x100c <prvUnlockQueue+0x4c>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    102a:	8f ef       	ldi	r24, 0xFF	; 255
    102c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    102e:	0f 90       	pop	r0
    1030:	0f be       	out	0x3f, r0	; 63
}
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	08 95       	ret

0000103c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1042:	0f b6       	in	r0, 0x3f	; 63
    1044:	f8 94       	cli
    1046:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1048:	28 81       	ld	r18, Y
    104a:	39 81       	ldd	r19, Y+1	; 0x01
    104c:	4b 8d       	ldd	r20, Y+27	; 0x1b
    104e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1050:	c9 01       	movw	r24, r18
    1052:	47 9f       	mul	r20, r23
    1054:	80 0d       	add	r24, r0
    1056:	91 1d       	adc	r25, r1
    1058:	11 24       	eor	r1, r1
    105a:	9b 83       	std	Y+3, r25	; 0x03
    105c:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    105e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1060:	3d 83       	std	Y+5, r19	; 0x05
    1062:	2c 83       	std	Y+4, r18	; 0x04

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1064:	50 e0       	ldi	r21, 0x00	; 0
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1066:	41 50       	subi	r20, 0x01	; 1
    1068:	51 09       	sbc	r21, r1
    106a:	74 9f       	mul	r23, r20
    106c:	c0 01       	movw	r24, r0
    106e:	75 9f       	mul	r23, r21
    1070:	90 0d       	add	r25, r0
    1072:	11 24       	eor	r1, r1
    1074:	82 0f       	add	r24, r18
    1076:	93 1f       	adc	r25, r19
    1078:	9f 83       	std	Y+7, r25	; 0x07
    107a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    107c:	8f ef       	ldi	r24, 0xFF	; 255
    107e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1080:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1082:	61 11       	cpse	r22, r1
    1084:	0c c0       	rjmp	.+24     	; 0x109e <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1086:	88 85       	ldd	r24, Y+8	; 0x08
    1088:	88 23       	and	r24, r24
    108a:	89 f0       	breq	.+34     	; 0x10ae <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    108c:	ce 01       	movw	r24, r28
    108e:	08 96       	adiw	r24, 0x08	; 8
    1090:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	59 f4       	brne	.+22     	; 0x10ae <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1098:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
    109c:	08 c0       	rjmp	.+16     	; 0x10ae <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    109e:	ce 01       	movw	r24, r28
    10a0:	08 96       	adiw	r24, 0x08	; 8
    10a2:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    10a6:	ce 01       	movw	r24, r28
    10a8:	41 96       	adiw	r24, 0x11	; 17
    10aa:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    10ae:	0f 90       	pop	r0
    10b0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	df 91       	pop	r29
    10b6:	cf 91       	pop	r28
    10b8:	08 95       	ret

000010ba <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    10ba:	ef 92       	push	r14
    10bc:	ff 92       	push	r15
    10be:	1f 93       	push	r17
    10c0:	cf 93       	push	r28
    10c2:	df 93       	push	r29
    10c4:	1f 92       	push	r1
    10c6:	cd b7       	in	r28, 0x3d	; 61
    10c8:	de b7       	in	r29, 0x3e	; 62
    10ca:	18 2f       	mov	r17, r24
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    10cc:	66 23       	and	r22, r22
    10ce:	29 f0       	breq	.+10     	; 0x10da <xQueueGenericCreate+0x20>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10d0:	86 9f       	mul	r24, r22
    10d2:	c0 01       	movw	r24, r0
    10d4:	11 24       	eor	r1, r1
    10d6:	01 96       	adiw	r24, 0x01	; 1
    10d8:	02 c0       	rjmp	.+4      	; 0x10de <xQueueGenericCreate+0x24>
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	90 e0       	ldi	r25, 0x00	; 0
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    10de:	4f 96       	adiw	r24, 0x1f	; 31
    10e0:	69 83       	std	Y+1, r22	; 0x01
    10e2:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <pvPortMalloc>
    10e6:	7c 01       	movw	r14, r24

	if( pcAllocatedBuffer != NULL )
    10e8:	69 81       	ldd	r22, Y+1	; 0x01
    10ea:	00 97       	sbiw	r24, 0x00	; 0
    10ec:	a9 f0       	breq	.+42     	; 0x1118 <xQueueGenericCreate+0x5e>
	{
		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be to small because it was dimensioned by sizeof( Queue_t ) + xQueueSizeInBytes. */

		if( uxItemSize == ( UBaseType_t ) 0 )
    10ee:	61 11       	cpse	r22, r1
    10f0:	04 c0       	rjmp	.+8      	; 0x10fa <xQueueGenericCreate+0x40>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    10f2:	fc 01       	movw	r30, r24
    10f4:	91 83       	std	Z+1, r25	; 0x01
    10f6:	80 83       	st	Z, r24
    10f8:	06 c0       	rjmp	.+12     	; 0x1106 <xQueueGenericCreate+0x4c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
    10fa:	9c 01       	movw	r18, r24
    10fc:	21 5e       	subi	r18, 0xE1	; 225
    10fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1100:	fc 01       	movw	r30, r24
    1102:	31 83       	std	Z+1, r19	; 0x01
    1104:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    1106:	f7 01       	movw	r30, r14
    1108:	13 8f       	std	Z+27, r17	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    110a:	64 8f       	std	Z+28, r22	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    110c:	61 e0       	ldi	r22, 0x01	; 1
    110e:	c7 01       	movw	r24, r14
    1110:	0e 94 1e 08 	call	0x103c	; 0x103c <xQueueGenericReset>
    1114:	c7 01       	movw	r24, r14
    1116:	02 c0       	rjmp	.+4      	; 0x111c <xQueueGenericCreate+0x62>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    111c:	0f 90       	pop	r0
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	ff 90       	pop	r15
    1126:	ef 90       	pop	r14
    1128:	08 95       	ret

0000112a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    112a:	bf 92       	push	r11
    112c:	cf 92       	push	r12
    112e:	df 92       	push	r13
    1130:	ef 92       	push	r14
    1132:	ff 92       	push	r15
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
    113c:	00 d0       	rcall	.+0      	; 0x113e <xQueueGenericSend+0x14>
    113e:	00 d0       	rcall	.+0      	; 0x1140 <xQueueGenericSend+0x16>
    1140:	1f 92       	push	r1
    1142:	cd b7       	in	r28, 0x3d	; 61
    1144:	de b7       	in	r29, 0x3e	; 62
    1146:	8c 01       	movw	r16, r24
    1148:	6b 01       	movw	r12, r22
    114a:	5d 83       	std	Y+5, r21	; 0x05
    114c:	4c 83       	std	Y+4, r20	; 0x04
    114e:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1150:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1152:	7c 01       	movw	r14, r24
    1154:	88 e0       	ldi	r24, 0x08	; 8
    1156:	e8 0e       	add	r14, r24
    1158:	f1 1c       	adc	r15, r1
    115a:	01 c0       	rjmp	.+2      	; 0x115e <xQueueGenericSend+0x34>
    115c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    115e:	0f b6       	in	r0, 0x3f	; 63
    1160:	f8 94       	cli
    1162:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1164:	f8 01       	movw	r30, r16
    1166:	92 8d       	ldd	r25, Z+26	; 0x1a
    1168:	83 8d       	ldd	r24, Z+27	; 0x1b
    116a:	98 17       	cp	r25, r24
    116c:	18 f0       	brcs	.+6      	; 0x1174 <xQueueGenericSend+0x4a>
    116e:	f2 e0       	ldi	r31, 0x02	; 2
    1170:	bf 12       	cpse	r11, r31
    1172:	18 c0       	rjmp	.+48     	; 0x11a4 <xQueueGenericSend+0x7a>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1174:	4b 2d       	mov	r20, r11
    1176:	b6 01       	movw	r22, r12
    1178:	c8 01       	movw	r24, r16
    117a:	0e 94 7c 07 	call	0xef8	; 0xef8 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    117e:	f8 01       	movw	r30, r16
    1180:	91 89       	ldd	r25, Z+17	; 0x11
    1182:	99 23       	and	r25, r25
    1184:	49 f0       	breq	.+18     	; 0x1198 <xQueueGenericSend+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1186:	c8 01       	movw	r24, r16
    1188:	41 96       	adiw	r24, 0x11	; 17
    118a:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    118e:	81 30       	cpi	r24, 0x01	; 1
    1190:	29 f4       	brne	.+10     	; 0x119c <xQueueGenericSend+0x72>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1192:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
    1196:	02 c0       	rjmp	.+4      	; 0x119c <xQueueGenericSend+0x72>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1198:	81 11       	cpse	r24, r1
    119a:	fb cf       	rjmp	.-10     	; 0x1192 <xQueueGenericSend+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    119c:	0f 90       	pop	r0
    119e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	4f c0       	rjmp	.+158    	; 0x1242 <xQueueGenericSend+0x118>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11a4:	8c 81       	ldd	r24, Y+4	; 0x04
    11a6:	9d 81       	ldd	r25, Y+5	; 0x05
    11a8:	89 2b       	or	r24, r25
    11aa:	19 f4       	brne	.+6      	; 0x11b2 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11ac:	0f 90       	pop	r0
    11ae:	0f be       	out	0x3f, r0	; 63
    11b0:	47 c0       	rjmp	.+142    	; 0x1240 <xQueueGenericSend+0x116>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    11b2:	21 11       	cpse	r18, r1
    11b4:	04 c0       	rjmp	.+8      	; 0x11be <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11b6:	ce 01       	movw	r24, r28
    11b8:	01 96       	adiw	r24, 0x01	; 1
    11ba:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11be:	0f 90       	pop	r0
    11c0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11c2:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11c6:	0f b6       	in	r0, 0x3f	; 63
    11c8:	f8 94       	cli
    11ca:	0f 92       	push	r0
    11cc:	f8 01       	movw	r30, r16
    11ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    11d0:	8f 3f       	cpi	r24, 0xFF	; 255
    11d2:	09 f4       	brne	.+2      	; 0x11d6 <xQueueGenericSend+0xac>
    11d4:	15 8e       	std	Z+29, r1	; 0x1d
    11d6:	f8 01       	movw	r30, r16
    11d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    11da:	8f 3f       	cpi	r24, 0xFF	; 255
    11dc:	09 f4       	brne	.+2      	; 0x11e0 <xQueueGenericSend+0xb6>
    11de:	16 8e       	std	Z+30, r1	; 0x1e
    11e0:	0f 90       	pop	r0
    11e2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11e4:	be 01       	movw	r22, r28
    11e6:	6c 5f       	subi	r22, 0xFC	; 252
    11e8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ea:	ce 01       	movw	r24, r28
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskCheckForTimeOut>
    11f2:	81 11       	cpse	r24, r1
    11f4:	20 c0       	rjmp	.+64     	; 0x1236 <xQueueGenericSend+0x10c>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11f6:	0f b6       	in	r0, 0x3f	; 63
    11f8:	f8 94       	cli
    11fa:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    11fc:	f8 01       	movw	r30, r16
    11fe:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1200:	0f 90       	pop	r0
    1202:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1204:	f8 01       	movw	r30, r16
    1206:	83 8d       	ldd	r24, Z+27	; 0x1b
    1208:	98 13       	cpse	r25, r24
    120a:	0f c0       	rjmp	.+30     	; 0x122a <xQueueGenericSend+0x100>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    120c:	6c 81       	ldd	r22, Y+4	; 0x04
    120e:	7d 81       	ldd	r23, Y+5	; 0x05
    1210:	c7 01       	movw	r24, r14
    1212:	0e 94 56 04 	call	0x8ac	; 0x8ac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1216:	c8 01       	movw	r24, r16
    1218:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    121c:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
    1220:	81 11       	cpse	r24, r1
    1222:	9c cf       	rjmp	.-200    	; 0x115c <xQueueGenericSend+0x32>
				{
					portYIELD_WITHIN_API();
    1224:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
    1228:	99 cf       	rjmp	.-206    	; 0x115c <xQueueGenericSend+0x32>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    122a:	c8 01       	movw	r24, r16
    122c:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1230:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
    1234:	93 cf       	rjmp	.-218    	; 0x115c <xQueueGenericSend+0x32>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    123c:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1240:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	0f 90       	pop	r0
    124a:	0f 90       	pop	r0
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	1f 91       	pop	r17
    1252:	0f 91       	pop	r16
    1254:	ff 90       	pop	r15
    1256:	ef 90       	pop	r14
    1258:	df 90       	pop	r13
    125a:	cf 90       	pop	r12
    125c:	bf 90       	pop	r11
    125e:	08 95       	ret

00001260 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1260:	0f 93       	push	r16
    1262:	1f 93       	push	r17
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ec 01       	movw	r28, r24
    126a:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    126c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    126e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1270:	98 17       	cp	r25, r24
    1272:	10 f0       	brcs	.+4      	; 0x1278 <xQueueGenericSendFromISR+0x18>
    1274:	22 30       	cpi	r18, 0x02	; 2
    1276:	e9 f4       	brne	.+58     	; 0x12b2 <xQueueGenericSendFromISR+0x52>
			/* A task can only have an inherited priority if it is a mutex
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  Therefore, unlike the xQueueGenericGive()
			function, there is no need to determine the need for priority
			disinheritance here or to clear the mutex holder TCB member. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1278:	42 2f       	mov	r20, r18
    127a:	ce 01       	movw	r24, r28
    127c:	0e 94 7c 07 	call	0xef8	; 0xef8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1280:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1282:	8f 3f       	cpi	r24, 0xFF	; 255
    1284:	89 f4       	brne	.+34     	; 0x12a8 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1286:	89 89       	ldd	r24, Y+17	; 0x11
    1288:	81 11       	cpse	r24, r1
    128a:	01 c0       	rjmp	.+2      	; 0x128e <xQueueGenericSendFromISR+0x2e>
    128c:	10 c0       	rjmp	.+32     	; 0x12ae <xQueueGenericSendFromISR+0x4e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    128e:	ce 01       	movw	r24, r28
    1290:	41 96       	adiw	r24, 0x11	; 17
    1292:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    1296:	88 23       	and	r24, r24
    1298:	51 f0       	breq	.+20     	; 0x12ae <xQueueGenericSendFromISR+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    129a:	01 15       	cp	r16, r1
    129c:	11 05       	cpc	r17, r1
    129e:	39 f0       	breq	.+14     	; 0x12ae <xQueueGenericSendFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	f8 01       	movw	r30, r16
    12a4:	80 83       	st	Z, r24
    12a6:	06 c0       	rjmp	.+12     	; 0x12b4 <xQueueGenericSendFromISR+0x54>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    12a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12aa:	8f 5f       	subi	r24, 0xFF	; 255
    12ac:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	01 c0       	rjmp	.+2      	; 0x12b4 <xQueueGenericSendFromISR+0x54>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12b2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	08 95       	ret

000012be <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	fc 01       	movw	r30, r24
    12c4:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    12c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    12c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    12ca:	98 17       	cp	r25, r24
    12cc:	d0 f4       	brcc	.+52     	; 0x1302 <xQueueGiveFromISR+0x44>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  Therefore, unlike the xQueueGenericGive()
			function, there is no need to determine the need for priority
			disinheritance here or to clear the mutex holder TCB member. */

			++( pxQueue->uxMessagesWaiting );
    12ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    12d6:	8f 3f       	cpi	r24, 0xFF	; 255
    12d8:	79 f4       	brne	.+30     	; 0x12f8 <xQueueGiveFromISR+0x3a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12da:	81 89       	ldd	r24, Z+17	; 0x11
    12dc:	81 11       	cpse	r24, r1
    12de:	01 c0       	rjmp	.+2      	; 0x12e2 <xQueueGiveFromISR+0x24>
    12e0:	0e c0       	rjmp	.+28     	; 0x12fe <xQueueGiveFromISR+0x40>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12e2:	cf 01       	movw	r24, r30
    12e4:	41 96       	adiw	r24, 0x11	; 17
    12e6:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    12ea:	88 23       	and	r24, r24
    12ec:	41 f0       	breq	.+16     	; 0x12fe <xQueueGiveFromISR+0x40>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    12ee:	20 97       	sbiw	r28, 0x00	; 0
    12f0:	31 f0       	breq	.+12     	; 0x12fe <xQueueGiveFromISR+0x40>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	88 83       	st	Y, r24
    12f6:	06 c0       	rjmp	.+12     	; 0x1304 <xQueueGiveFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    12f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    12fa:	8f 5f       	subi	r24, 0xFF	; 255
    12fc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	01 c0       	rjmp	.+2      	; 0x1304 <xQueueGiveFromISR+0x46>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1302:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	08 95       	ret

0000130a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    130a:	bf 92       	push	r11
    130c:	cf 92       	push	r12
    130e:	df 92       	push	r13
    1310:	ef 92       	push	r14
    1312:	ff 92       	push	r15
    1314:	0f 93       	push	r16
    1316:	1f 93       	push	r17
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	00 d0       	rcall	.+0      	; 0x131e <xQueueGenericReceive+0x14>
    131e:	00 d0       	rcall	.+0      	; 0x1320 <xQueueGenericReceive+0x16>
    1320:	1f 92       	push	r1
    1322:	cd b7       	in	r28, 0x3d	; 61
    1324:	de b7       	in	r29, 0x3e	; 62
    1326:	8c 01       	movw	r16, r24
    1328:	6b 01       	movw	r12, r22
    132a:	5d 83       	std	Y+5, r21	; 0x05
    132c:	4c 83       	std	Y+4, r20	; 0x04
    132e:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1330:	30 e0       	ldi	r19, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1332:	7c 01       	movw	r14, r24
    1334:	81 e1       	ldi	r24, 0x11	; 17
    1336:	e8 0e       	add	r14, r24
    1338:	f1 1c       	adc	r15, r1
    133a:	01 c0       	rjmp	.+2      	; 0x133e <xQueueGenericReceive+0x34>
    133c:	31 e0       	ldi	r19, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    133e:	0f b6       	in	r0, 0x3f	; 63
    1340:	f8 94       	cli
    1342:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1344:	f8 01       	movw	r30, r16
    1346:	82 8d       	ldd	r24, Z+26	; 0x1a
    1348:	88 23       	and	r24, r24
    134a:	39 f1       	breq	.+78     	; 0x139a <xQueueGenericReceive+0x90>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    134c:	e6 80       	ldd	r14, Z+6	; 0x06
    134e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1350:	b6 01       	movw	r22, r12
    1352:	c8 01       	movw	r24, r16
    1354:	0e 94 c6 07 	call	0xf8c	; 0xf8c <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1358:	f8 01       	movw	r30, r16
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    135a:	b1 10       	cpse	r11, r1
    135c:	0f c0       	rjmp	.+30     	; 0x137c <xQueueGenericReceive+0x72>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    135e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1360:	81 50       	subi	r24, 0x01	; 1
    1362:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1364:	80 85       	ldd	r24, Z+8	; 0x08
    1366:	88 23       	and	r24, r24
    1368:	a1 f0       	breq	.+40     	; 0x1392 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    136a:	c8 01       	movw	r24, r16
    136c:	08 96       	adiw	r24, 0x08	; 8
    136e:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    1372:	81 30       	cpi	r24, 0x01	; 1
    1374:	71 f4       	brne	.+28     	; 0x1392 <xQueueGenericReceive+0x88>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1376:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
    137a:	0b c0       	rjmp	.+22     	; 0x1392 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    137c:	f7 82       	std	Z+7, r15	; 0x07
    137e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1380:	81 89       	ldd	r24, Z+17	; 0x11
    1382:	88 23       	and	r24, r24
    1384:	31 f0       	breq	.+12     	; 0x1392 <xQueueGenericReceive+0x88>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1386:	c8 01       	movw	r24, r16
    1388:	41 96       	adiw	r24, 0x11	; 17
    138a:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    138e:	81 11       	cpse	r24, r1
    1390:	f2 cf       	rjmp	.-28     	; 0x1376 <xQueueGenericReceive+0x6c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	4d c0       	rjmp	.+154    	; 0x1434 <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    139a:	8c 81       	ldd	r24, Y+4	; 0x04
    139c:	9d 81       	ldd	r25, Y+5	; 0x05
    139e:	89 2b       	or	r24, r25
    13a0:	19 f4       	brne	.+6      	; 0x13a8 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13a2:	0f 90       	pop	r0
    13a4:	0f be       	out	0x3f, r0	; 63
    13a6:	45 c0       	rjmp	.+138    	; 0x1432 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    13a8:	31 11       	cpse	r19, r1
    13aa:	04 c0       	rjmp	.+8      	; 0x13b4 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13ac:	ce 01       	movw	r24, r28
    13ae:	01 96       	adiw	r24, 0x01	; 1
    13b0:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    13b4:	0f 90       	pop	r0
    13b6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    13b8:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    13bc:	0f b6       	in	r0, 0x3f	; 63
    13be:	f8 94       	cli
    13c0:	0f 92       	push	r0
    13c2:	f8 01       	movw	r30, r16
    13c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    13c6:	8f 3f       	cpi	r24, 0xFF	; 255
    13c8:	09 f4       	brne	.+2      	; 0x13cc <xQueueGenericReceive+0xc2>
    13ca:	15 8e       	std	Z+29, r1	; 0x1d
    13cc:	f8 01       	movw	r30, r16
    13ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    13d0:	8f 3f       	cpi	r24, 0xFF	; 255
    13d2:	09 f4       	brne	.+2      	; 0x13d6 <xQueueGenericReceive+0xcc>
    13d4:	16 8e       	std	Z+30, r1	; 0x1e
    13d6:	0f 90       	pop	r0
    13d8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13da:	be 01       	movw	r22, r28
    13dc:	6c 5f       	subi	r22, 0xFC	; 252
    13de:	7f 4f       	sbci	r23, 0xFF	; 255
    13e0:	ce 01       	movw	r24, r28
    13e2:	01 96       	adiw	r24, 0x01	; 1
    13e4:	0e 94 15 05 	call	0xa2a	; 0xa2a <xTaskCheckForTimeOut>
    13e8:	81 11       	cpse	r24, r1
    13ea:	1e c0       	rjmp	.+60     	; 0x1428 <xQueueGenericReceive+0x11e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    13ec:	0f b6       	in	r0, 0x3f	; 63
    13ee:	f8 94       	cli
    13f0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    13f2:	f8 01       	movw	r30, r16
    13f4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    13f6:	0f 90       	pop	r0
    13f8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13fa:	81 11       	cpse	r24, r1
    13fc:	0f c0       	rjmp	.+30     	; 0x141c <xQueueGenericReceive+0x112>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13fe:	6c 81       	ldd	r22, Y+4	; 0x04
    1400:	7d 81       	ldd	r23, Y+5	; 0x05
    1402:	c7 01       	movw	r24, r14
    1404:	0e 94 56 04 	call	0x8ac	; 0x8ac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1408:	c8 01       	movw	r24, r16
    140a:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    140e:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
    1412:	81 11       	cpse	r24, r1
    1414:	93 cf       	rjmp	.-218    	; 0x133c <xQueueGenericReceive+0x32>
				{
					portYIELD_WITHIN_API();
    1416:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vPortYield>
    141a:	90 cf       	rjmp	.-224    	; 0x133c <xQueueGenericReceive+0x32>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    141c:	c8 01       	movw	r24, r16
    141e:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1422:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
    1426:	8a cf       	rjmp	.-236    	; 0x133c <xQueueGenericReceive+0x32>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1428:	c8 01       	movw	r24, r16
    142a:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    142e:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1432:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1434:	0f 90       	pop	r0
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	df 91       	pop	r29
    1440:	cf 91       	pop	r28
    1442:	1f 91       	pop	r17
    1444:	0f 91       	pop	r16
    1446:	ff 90       	pop	r15
    1448:	ef 90       	pop	r14
    144a:	df 90       	pop	r13
    144c:	cf 90       	pop	r12
    144e:	bf 90       	pop	r11
    1450:	08 95       	ret

00001452 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1452:	0f 93       	push	r16
    1454:	1f 93       	push	r17
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	ec 01       	movw	r28, r24
    145c:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    145e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1460:	88 23       	and	r24, r24
    1462:	f9 f0       	breq	.+62     	; 0x14a2 <xQueueReceiveFromISR+0x50>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1464:	ce 01       	movw	r24, r28
    1466:	0e 94 c6 07 	call	0xf8c	; 0xf8c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    146a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    146c:	81 50       	subi	r24, 0x01	; 1
    146e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1470:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1472:	8f 3f       	cpi	r24, 0xFF	; 255
    1474:	89 f4       	brne	.+34     	; 0x1498 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1476:	88 85       	ldd	r24, Y+8	; 0x08
    1478:	81 11       	cpse	r24, r1
    147a:	01 c0       	rjmp	.+2      	; 0x147e <xQueueReceiveFromISR+0x2c>
    147c:	10 c0       	rjmp	.+32     	; 0x149e <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    147e:	ce 01       	movw	r24, r28
    1480:	08 96       	adiw	r24, 0x08	; 8
    1482:	0e 94 95 04 	call	0x92a	; 0x92a <xTaskRemoveFromEventList>
    1486:	88 23       	and	r24, r24
    1488:	51 f0       	breq	.+20     	; 0x149e <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    148a:	01 15       	cp	r16, r1
    148c:	11 05       	cpc	r17, r1
    148e:	39 f0       	breq	.+14     	; 0x149e <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1490:	81 e0       	ldi	r24, 0x01	; 1
    1492:	f8 01       	movw	r30, r16
    1494:	80 83       	st	Z, r24
    1496:	06 c0       	rjmp	.+12     	; 0x14a4 <xQueueReceiveFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1498:	8d 8d       	ldd	r24, Y+29	; 0x1d
    149a:	8f 5f       	subi	r24, 0xFF	; 255
    149c:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	01 c0       	rjmp	.+2      	; 0x14a4 <xQueueReceiveFromISR+0x52>
		}
		else
		{
			xReturn = pdFAIL;
    14a2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14a4:	df 91       	pop	r29
    14a6:	cf 91       	pop	r28
    14a8:	1f 91       	pop	r17
    14aa:	0f 91       	pop	r16
    14ac:	08 95       	ret

000014ae <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    14ae:	0f 93       	push	r16
    14b0:	1f 93       	push	r17
    14b2:	cf 93       	push	r28
    14b4:	df 93       	push	r29
    14b6:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14ba:	88 23       	and	r24, r24
    14bc:	49 f0       	breq	.+18     	; 0x14d0 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14be:	0e 81       	ldd	r16, Y+6	; 0x06
    14c0:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14c2:	ce 01       	movw	r24, r28
    14c4:	0e 94 c6 07 	call	0xf8c	; 0xf8c <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    14c8:	1f 83       	std	Y+7, r17	; 0x07
    14ca:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	01 c0       	rjmp	.+2      	; 0x14d2 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    14d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	1f 91       	pop	r17
    14d8:	0f 91       	pop	r16
    14da:	08 95       	ret

000014dc <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    14dc:	0f b6       	in	r0, 0x3f	; 63
    14de:	f8 94       	cli
    14e0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    14e2:	fc 01       	movw	r30, r24
    14e4:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    14e6:	0f 90       	pop	r0
    14e8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    14ea:	08 95       	ret

000014ec <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    14f2:	fc 01       	movw	r30, r24
    14f4:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    14f6:	0f 90       	pop	r0
    14f8:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    14fa:	fc 01       	movw	r30, r24
    14fc:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    14fe:	82 1b       	sub	r24, r18
    1500:	08 95       	ret

00001502 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1502:	fc 01       	movw	r30, r24
    1504:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1506:	08 95       	ret

00001508 <vQueueDelete>:
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    1508:	0c 94 e5 0d 	jmp	0x1bca	; 0x1bca <vPortFree>

0000150c <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    150c:	fc 01       	movw	r30, r24
    150e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1510:	81 e0       	ldi	r24, 0x01	; 1
    1512:	91 11       	cpse	r25, r1
    1514:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1516:	08 95       	ret

00001518 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1518:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    151a:	22 8d       	ldd	r18, Z+26	; 0x1a
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1520:	29 13       	cpse	r18, r25
    1522:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1524:	08 95       	ret

00001526 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1526:	cf 93       	push	r28
    1528:	df 93       	push	r29
    152a:	ec 01       	movw	r28, r24
    152c:	ca 01       	movw	r24, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    152e:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1530:	0f b6       	in	r0, 0x3f	; 63
    1532:	f8 94       	cli
    1534:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1536:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1538:	2b 8d       	ldd	r18, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    153e:	32 13       	cpse	r19, r18
    1540:	0d c0       	rjmp	.+26     	; 0x155c <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1542:	00 97       	sbiw	r24, 0x00	; 0
    1544:	41 f0       	breq	.+16     	; 0x1556 <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1546:	be 01       	movw	r22, r28
    1548:	68 5f       	subi	r22, 0xF8	; 248
    154a:	7f 4f       	sbci	r23, 0xFF	; 255
    154c:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1550:	78 94       	sei
					return errQUEUE_BLOCKED;
    1552:	8c ef       	ldi	r24, 0xFC	; 252
    1554:	1b c0       	rjmp	.+54     	; 0x158c <xQueueCRSend+0x66>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1556:	78 94       	sei
					return errQUEUE_FULL;
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	18 c0       	rjmp	.+48     	; 0x158c <xQueueCRSend+0x66>
				}
			}
		}
		portENABLE_INTERRUPTS();
    155c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    155e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1560:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1562:	82 17       	cp	r24, r18
    1564:	88 f4       	brcc	.+34     	; 0x1588 <xQueueCRSend+0x62>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1566:	40 e0       	ldi	r20, 0x00	; 0
    1568:	ce 01       	movw	r24, r28
    156a:	0e 94 7c 07 	call	0xef8	; 0xef8 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    156e:	89 89       	ldd	r24, Y+17	; 0x11
    1570:	81 11       	cpse	r24, r1
    1572:	02 c0       	rjmp	.+4      	; 0x1578 <xQueueCRSend+0x52>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	09 c0       	rjmp	.+18     	; 0x158a <xQueueCRSend+0x64>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1578:	ce 01       	movw	r24, r28
    157a:	41 96       	adiw	r24, 0x11	; 17
    157c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xCoRoutineRemoveFromEventList>
    1580:	88 23       	and	r24, r24
    1582:	c1 f3       	breq	.-16     	; 0x1574 <xQueueCRSend+0x4e>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1584:	8b ef       	ldi	r24, 0xFB	; 251
    1586:	01 c0       	rjmp	.+2      	; 0x158a <xQueueCRSend+0x64>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1588:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    158a:	78 94       	sei

		return xReturn;
	}
    158c:	df 91       	pop	r29
    158e:	cf 91       	pop	r28
    1590:	08 95       	ret

00001592 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1592:	cf 93       	push	r28
    1594:	df 93       	push	r29
    1596:	ec 01       	movw	r28, r24
    1598:	cb 01       	movw	r24, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    159a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    159c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    159e:	21 11       	cpse	r18, r1
    15a0:	0f c0       	rjmp	.+30     	; 0x15c0 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    15a2:	41 15       	cp	r20, r1
    15a4:	51 05       	cpc	r21, r1
    15a6:	49 f0       	breq	.+18     	; 0x15ba <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    15a8:	be 01       	movw	r22, r28
    15aa:	6f 5e       	subi	r22, 0xEF	; 239
    15ac:	7f 4f       	sbci	r23, 0xFF	; 255
    15ae:	ca 01       	movw	r24, r20
    15b0:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    15b4:	78 94       	sei
					return errQUEUE_BLOCKED;
    15b6:	8c ef       	ldi	r24, 0xFC	; 252
    15b8:	2f c0       	rjmp	.+94     	; 0x1618 <xQueueCRReceive+0x86>
				}
				else
				{
					portENABLE_INTERRUPTS();
    15ba:	78 94       	sei
					return errQUEUE_FULL;
    15bc:	80 e0       	ldi	r24, 0x00	; 0
    15be:	2c c0       	rjmp	.+88     	; 0x1618 <xQueueCRReceive+0x86>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    15c0:	78 94       	sei

		portDISABLE_INTERRUPTS();
    15c2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    15c4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    15c6:	22 23       	and	r18, r18
    15c8:	29 f1       	breq	.+74     	; 0x1614 <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    15ca:	4c 8d       	ldd	r20, Y+28	; 0x1c
    15cc:	2e 81       	ldd	r18, Y+6	; 0x06
    15ce:	3f 81       	ldd	r19, Y+7	; 0x07
    15d0:	24 0f       	add	r18, r20
    15d2:	31 1d       	adc	r19, r1
    15d4:	3f 83       	std	Y+7, r19	; 0x07
    15d6:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    15d8:	ea 81       	ldd	r30, Y+2	; 0x02
    15da:	fb 81       	ldd	r31, Y+3	; 0x03
    15dc:	2e 17       	cp	r18, r30
    15de:	3f 07       	cpc	r19, r31
    15e0:	20 f0       	brcs	.+8      	; 0x15ea <xQueueCRReceive+0x58>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    15e2:	28 81       	ld	r18, Y
    15e4:	39 81       	ldd	r19, Y+1	; 0x01
    15e6:	3f 83       	std	Y+7, r19	; 0x07
    15e8:	2e 83       	std	Y+6, r18	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    15ea:	2a 8d       	ldd	r18, Y+26	; 0x1a
    15ec:	21 50       	subi	r18, 0x01	; 1
    15ee:	2a 8f       	std	Y+26, r18	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    15f0:	6e 81       	ldd	r22, Y+6	; 0x06
    15f2:	7f 81       	ldd	r23, Y+7	; 0x07
    15f4:	50 e0       	ldi	r21, 0x00	; 0
    15f6:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15fa:	88 85       	ldd	r24, Y+8	; 0x08
    15fc:	81 11       	cpse	r24, r1
    15fe:	02 c0       	rjmp	.+4      	; 0x1604 <xQueueCRReceive+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	09 c0       	rjmp	.+18     	; 0x1616 <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1604:	ce 01       	movw	r24, r28
    1606:	08 96       	adiw	r24, 0x08	; 8
    1608:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xCoRoutineRemoveFromEventList>
    160c:	88 23       	and	r24, r24
    160e:	c1 f3       	breq	.-16     	; 0x1600 <xQueueCRReceive+0x6e>
					{
						xReturn = errQUEUE_YIELD;
    1610:	8b ef       	ldi	r24, 0xFB	; 251
    1612:	01 c0       	rjmp	.+2      	; 0x1616 <xQueueCRReceive+0x84>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1614:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1616:	78 94       	sei

		return xReturn;
	}
    1618:	df 91       	pop	r29
    161a:	cf 91       	pop	r28
    161c:	08 95       	ret

0000161e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	ec 01       	movw	r28, r24
    1626:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1628:	9a 8d       	ldd	r25, Y+26	; 0x1a
    162a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    162c:	98 17       	cp	r25, r24
    162e:	88 f4       	brcc	.+34     	; 0x1652 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1630:	40 e0       	ldi	r20, 0x00	; 0
    1632:	ce 01       	movw	r24, r28
    1634:	0e 94 7c 07 	call	0xef8	; 0xef8 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1638:	11 11       	cpse	r17, r1
    163a:	0b c0       	rjmp	.+22     	; 0x1652 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    163c:	89 89       	ldd	r24, Y+17	; 0x11
    163e:	88 23       	and	r24, r24
    1640:	41 f0       	breq	.+16     	; 0x1652 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1642:	ce 01       	movw	r24, r28
    1644:	41 96       	adiw	r24, 0x11	; 17
    1646:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xCoRoutineRemoveFromEventList>
    164a:	11 e0       	ldi	r17, 0x01	; 1
    164c:	81 11       	cpse	r24, r1
    164e:	01 c0       	rjmp	.+2      	; 0x1652 <xQueueCRSendFromISR+0x34>
    1650:	10 e0       	ldi	r17, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1652:	81 2f       	mov	r24, r17
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	1f 91       	pop	r17
    165a:	08 95       	ret

0000165c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    165c:	0f 93       	push	r16
    165e:	1f 93       	push	r17
    1660:	cf 93       	push	r28
    1662:	df 93       	push	r29
    1664:	ec 01       	movw	r28, r24
    1666:	cb 01       	movw	r24, r22
    1668:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    166a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    166c:	22 23       	and	r18, r18
    166e:	59 f1       	breq	.+86     	; 0x16c6 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1670:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1672:	2e 81       	ldd	r18, Y+6	; 0x06
    1674:	3f 81       	ldd	r19, Y+7	; 0x07
    1676:	24 0f       	add	r18, r20
    1678:	31 1d       	adc	r19, r1
    167a:	3f 83       	std	Y+7, r19	; 0x07
    167c:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    167e:	ea 81       	ldd	r30, Y+2	; 0x02
    1680:	fb 81       	ldd	r31, Y+3	; 0x03
    1682:	2e 17       	cp	r18, r30
    1684:	3f 07       	cpc	r19, r31
    1686:	20 f0       	brcs	.+8      	; 0x1690 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1688:	28 81       	ld	r18, Y
    168a:	39 81       	ldd	r19, Y+1	; 0x01
    168c:	3f 83       	std	Y+7, r19	; 0x07
    168e:	2e 83       	std	Y+6, r18	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1690:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1692:	21 50       	subi	r18, 0x01	; 1
    1694:	2a 8f       	std	Y+26, r18	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1696:	6e 81       	ldd	r22, Y+6	; 0x06
    1698:	7f 81       	ldd	r23, Y+7	; 0x07
    169a:	50 e0       	ldi	r21, 0x00	; 0
    169c:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    16a0:	f8 01       	movw	r30, r16
    16a2:	80 81       	ld	r24, Z
    16a4:	88 23       	and	r24, r24
    16a6:	11 f0       	breq	.+4      	; 0x16ac <xQueueCRReceiveFromISR+0x50>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	0e c0       	rjmp	.+28     	; 0x16c8 <xQueueCRReceiveFromISR+0x6c>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16ac:	88 85       	ldd	r24, Y+8	; 0x08
    16ae:	88 23       	and	r24, r24
    16b0:	d9 f3       	breq	.-10     	; 0x16a8 <xQueueCRReceiveFromISR+0x4c>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16b2:	ce 01       	movw	r24, r28
    16b4:	08 96       	adiw	r24, 0x08	; 8
    16b6:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xCoRoutineRemoveFromEventList>
    16ba:	88 23       	and	r24, r24
    16bc:	a9 f3       	breq	.-22     	; 0x16a8 <xQueueCRReceiveFromISR+0x4c>
					{
						*pxCoRoutineWoken = pdTRUE;
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	f8 01       	movw	r30, r16
    16c2:	80 83       	st	Z, r24
    16c4:	01 c0       	rjmp	.+2      	; 0x16c8 <xQueueCRReceiveFromISR+0x6c>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    16c6:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	1f 91       	pop	r17
    16ce:	0f 91       	pop	r16
    16d0:	08 95       	ret

000016d2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    16d2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16d4:	03 96       	adiw	r24, 0x03	; 3
    16d6:	92 83       	std	Z+2, r25	; 0x02
    16d8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    16da:	2f ef       	ldi	r18, 0xFF	; 255
    16dc:	3f ef       	ldi	r19, 0xFF	; 255
    16de:	34 83       	std	Z+4, r19	; 0x04
    16e0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16e2:	96 83       	std	Z+6, r25	; 0x06
    16e4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16e6:	90 87       	std	Z+8, r25	; 0x08
    16e8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    16ea:	10 82       	st	Z, r1
    16ec:	08 95       	ret

000016ee <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    16ee:	fc 01       	movw	r30, r24
    16f0:	11 86       	std	Z+9, r1	; 0x09
    16f2:	10 86       	std	Z+8, r1	; 0x08
    16f4:	08 95       	ret

000016f6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16f6:	cf 93       	push	r28
    16f8:	df 93       	push	r29
    16fa:	9c 01       	movw	r18, r24
    16fc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    16fe:	dc 01       	movw	r26, r24
    1700:	11 96       	adiw	r26, 0x01	; 1
    1702:	cd 91       	ld	r28, X+
    1704:	dc 91       	ld	r29, X
    1706:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1708:	d3 83       	std	Z+3, r29	; 0x03
    170a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    170c:	8c 81       	ldd	r24, Y+4	; 0x04
    170e:	9d 81       	ldd	r25, Y+5	; 0x05
    1710:	95 83       	std	Z+5, r25	; 0x05
    1712:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1714:	8c 81       	ldd	r24, Y+4	; 0x04
    1716:	9d 81       	ldd	r25, Y+5	; 0x05
    1718:	dc 01       	movw	r26, r24
    171a:	13 96       	adiw	r26, 0x03	; 3
    171c:	7c 93       	st	X, r23
    171e:	6e 93       	st	-X, r22
    1720:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1722:	7d 83       	std	Y+5, r23	; 0x05
    1724:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1726:	31 87       	std	Z+9, r19	; 0x09
    1728:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    172a:	f9 01       	movw	r30, r18
    172c:	80 81       	ld	r24, Z
    172e:	8f 5f       	subi	r24, 0xFF	; 255
    1730:	80 83       	st	Z, r24
}
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	08 95       	ret

00001738 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1738:	0f 93       	push	r16
    173a:	1f 93       	push	r17
    173c:	cf 93       	push	r28
    173e:	df 93       	push	r29
    1740:	8c 01       	movw	r16, r24
    1742:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1744:	80 81       	ld	r24, Z
    1746:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1748:	8f 3f       	cpi	r24, 0xFF	; 255
    174a:	2f ef       	ldi	r18, 0xFF	; 255
    174c:	92 07       	cpc	r25, r18
    174e:	21 f4       	brne	.+8      	; 0x1758 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1750:	e8 01       	movw	r28, r16
    1752:	af 81       	ldd	r26, Y+7	; 0x07
    1754:	b8 85       	ldd	r27, Y+8	; 0x08
    1756:	0e c0       	rjmp	.+28     	; 0x1774 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1758:	d8 01       	movw	r26, r16
    175a:	13 96       	adiw	r26, 0x03	; 3
    175c:	01 c0       	rjmp	.+2      	; 0x1760 <vListInsert+0x28>
    175e:	d9 01       	movw	r26, r18
    1760:	12 96       	adiw	r26, 0x02	; 2
    1762:	2d 91       	ld	r18, X+
    1764:	3c 91       	ld	r19, X
    1766:	13 97       	sbiw	r26, 0x03	; 3
    1768:	e9 01       	movw	r28, r18
    176a:	48 81       	ld	r20, Y
    176c:	59 81       	ldd	r21, Y+1	; 0x01
    176e:	84 17       	cp	r24, r20
    1770:	95 07       	cpc	r25, r21
    1772:	a8 f7       	brcc	.-22     	; 0x175e <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1774:	12 96       	adiw	r26, 0x02	; 2
    1776:	8d 91       	ld	r24, X+
    1778:	9c 91       	ld	r25, X
    177a:	13 97       	sbiw	r26, 0x03	; 3
    177c:	93 83       	std	Z+3, r25	; 0x03
    177e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1780:	ec 01       	movw	r28, r24
    1782:	fd 83       	std	Y+5, r31	; 0x05
    1784:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1786:	b5 83       	std	Z+5, r27	; 0x05
    1788:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    178a:	13 96       	adiw	r26, 0x03	; 3
    178c:	fc 93       	st	X, r31
    178e:	ee 93       	st	-X, r30
    1790:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1792:	11 87       	std	Z+9, r17	; 0x09
    1794:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1796:	f8 01       	movw	r30, r16
    1798:	80 81       	ld	r24, Z
    179a:	8f 5f       	subi	r24, 0xFF	; 255
    179c:	80 83       	st	Z, r24
}
    179e:	df 91       	pop	r29
    17a0:	cf 91       	pop	r28
    17a2:	1f 91       	pop	r17
    17a4:	0f 91       	pop	r16
    17a6:	08 95       	ret

000017a8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    17a8:	cf 93       	push	r28
    17aa:	df 93       	push	r29
    17ac:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    17ae:	a0 85       	ldd	r26, Z+8	; 0x08
    17b0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    17b2:	82 81       	ldd	r24, Z+2	; 0x02
    17b4:	93 81       	ldd	r25, Z+3	; 0x03
    17b6:	24 81       	ldd	r18, Z+4	; 0x04
    17b8:	35 81       	ldd	r19, Z+5	; 0x05
    17ba:	ec 01       	movw	r28, r24
    17bc:	3d 83       	std	Y+5, r19	; 0x05
    17be:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    17c0:	c4 81       	ldd	r28, Z+4	; 0x04
    17c2:	d5 81       	ldd	r29, Z+5	; 0x05
    17c4:	9b 83       	std	Y+3, r25	; 0x03
    17c6:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    17c8:	11 96       	adiw	r26, 0x01	; 1
    17ca:	8d 91       	ld	r24, X+
    17cc:	9c 91       	ld	r25, X
    17ce:	12 97       	sbiw	r26, 0x02	; 2
    17d0:	8e 17       	cp	r24, r30
    17d2:	9f 07       	cpc	r25, r31
    17d4:	21 f4       	brne	.+8      	; 0x17de <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    17d6:	12 96       	adiw	r26, 0x02	; 2
    17d8:	dc 93       	st	X, r29
    17da:	ce 93       	st	-X, r28
    17dc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    17de:	11 86       	std	Z+9, r1	; 0x09
    17e0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17e2:	8c 91       	ld	r24, X
    17e4:	81 50       	subi	r24, 0x01	; 1
    17e6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    17e8:	df 91       	pop	r29
    17ea:	cf 91       	pop	r28
    17ec:	08 95       	ret

000017ee <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    17ee:	df 92       	push	r13
    17f0:	ef 92       	push	r14
    17f2:	ff 92       	push	r15
    17f4:	0f 93       	push	r16
    17f6:	1f 93       	push	r17
    17f8:	cf 93       	push	r28
    17fa:	df 93       	push	r29
    17fc:	7c 01       	movw	r14, r24
    17fe:	d6 2e       	mov	r13, r22
    1800:	14 2f       	mov	r17, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1802:	8a e1       	ldi	r24, 0x1A	; 26
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <pvPortMalloc>
    180a:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    180c:	00 97       	sbiw	r24, 0x00	; 0
    180e:	09 f4       	brne	.+2      	; 0x1812 <xCoRoutineCreate+0x24>
    1810:	59 c0       	rjmp	.+178    	; 0x18c4 <xCoRoutineCreate+0xd6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1812:	80 91 8f 01 	lds	r24, 0x018F
    1816:	90 91 90 01 	lds	r25, 0x0190
    181a:	89 2b       	or	r24, r25
    181c:	21 f5       	brne	.+72     	; 0x1866 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    181e:	d0 93 90 01 	sts	0x0190, r29
    1822:	c0 93 8f 01 	sts	0x018F, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1826:	82 e9       	ldi	r24, 0x92	; 146
    1828:	91 e0       	ldi	r25, 0x01	; 1
    182a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
    182e:	8b e9       	ldi	r24, 0x9B	; 155
    1830:	91 e0       	ldi	r25, 0x01	; 1
    1832:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1836:	84 ea       	ldi	r24, 0xA4	; 164
    1838:	91 e0       	ldi	r25, 0x01	; 1
    183a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    183e:	8d ea       	ldi	r24, 0xAD	; 173
    1840:	91 e0       	ldi	r25, 0x01	; 1
    1842:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1846:	86 eb       	ldi	r24, 0xB6	; 182
    1848:	91 e0       	ldi	r25, 0x01	; 1
    184a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    184e:	84 ea       	ldi	r24, 0xA4	; 164
    1850:	91 e0       	ldi	r25, 0x01	; 1
    1852:	90 93 c0 01 	sts	0x01C0, r25
    1856:	80 93 bf 01 	sts	0x01BF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    185a:	8d ea       	ldi	r24, 0xAD	; 173
    185c:	91 e0       	ldi	r25, 0x01	; 1
    185e:	90 93 c2 01 	sts	0x01C2, r25
    1862:	80 93 c1 01 	sts	0x01C1, r24
    1866:	dd 20       	and	r13, r13
    1868:	11 f0       	breq	.+4      	; 0x186e <xCoRoutineCreate+0x80>
    186a:	dd 24       	eor	r13, r13
    186c:	d3 94       	inc	r13
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    186e:	19 8e       	std	Y+25, r1	; 0x19
    1870:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1872:	de 8a       	std	Y+22, r13	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1874:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1876:	fe 01       	movw	r30, r28
    1878:	e1 92       	st	Z+, r14
    187a:	f1 92       	st	Z+, r15
    187c:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    187e:	cf 01       	movw	r24, r30
    1880:	0e 94 77 0b 	call	0x16ee	; 0x16ee <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1884:	ce 01       	movw	r24, r28
    1886:	0c 96       	adiw	r24, 0x0c	; 12
    1888:	0e 94 77 0b 	call	0x16ee	; 0x16ee <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    188c:	d9 87       	std	Y+9, r29	; 0x09
    188e:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1890:	db 8b       	std	Y+19, r29	; 0x13
    1892:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1894:	82 e0       	ldi	r24, 0x02	; 2
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	8d 19       	sub	r24, r13
    189a:	91 09       	sbc	r25, r1
    189c:	9d 87       	std	Y+13, r25	; 0x0d
    189e:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    18a0:	8e 89       	ldd	r24, Y+22	; 0x16
    18a2:	90 91 91 01 	lds	r25, 0x0191
    18a6:	98 17       	cp	r25, r24
    18a8:	10 f4       	brcc	.+4      	; 0x18ae <xCoRoutineCreate+0xc0>
    18aa:	80 93 91 01 	sts	0x0191, r24
    18ae:	f9 e0       	ldi	r31, 0x09	; 9
    18b0:	8f 9f       	mul	r24, r31
    18b2:	c0 01       	movw	r24, r0
    18b4:	11 24       	eor	r1, r1
    18b6:	b8 01       	movw	r22, r16
    18b8:	8e 56       	subi	r24, 0x6E	; 110
    18ba:	9e 4f       	sbci	r25, 0xFE	; 254
    18bc:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

		xReturn = pdPASS;
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	01 c0       	rjmp	.+2      	; 0x18c6 <xCoRoutineCreate+0xd8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    18c4:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    18c6:	df 91       	pop	r29
    18c8:	cf 91       	pop	r28
    18ca:	1f 91       	pop	r17
    18cc:	0f 91       	pop	r16
    18ce:	ff 90       	pop	r15
    18d0:	ef 90       	pop	r14
    18d2:	df 90       	pop	r13
    18d4:	08 95       	ret

000018d6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    18d6:	0f 93       	push	r16
    18d8:	1f 93       	push	r17
    18da:	cf 93       	push	r28
    18dc:	df 93       	push	r29
    18de:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    18e0:	c0 91 c3 01 	lds	r28, 0x01C3
    18e4:	d0 91 c4 01 	lds	r29, 0x01C4
    18e8:	c8 0f       	add	r28, r24
    18ea:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    18ec:	80 91 8f 01 	lds	r24, 0x018F
    18f0:	90 91 90 01 	lds	r25, 0x0190
    18f4:	02 96       	adiw	r24, 0x02	; 2
    18f6:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    18fa:	e0 91 8f 01 	lds	r30, 0x018F
    18fe:	f0 91 90 01 	lds	r31, 0x0190
    1902:	d3 83       	std	Z+3, r29	; 0x03
    1904:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1906:	80 91 c3 01 	lds	r24, 0x01C3
    190a:	90 91 c4 01 	lds	r25, 0x01C4
    190e:	bf 01       	movw	r22, r30
    1910:	6e 5f       	subi	r22, 0xFE	; 254
    1912:	7f 4f       	sbci	r23, 0xFF	; 255
    1914:	c8 17       	cp	r28, r24
    1916:	d9 07       	cpc	r29, r25
    1918:	28 f4       	brcc	.+10     	; 0x1924 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    191a:	80 91 c1 01 	lds	r24, 0x01C1
    191e:	90 91 c2 01 	lds	r25, 0x01C2
    1922:	04 c0       	rjmp	.+8      	; 0x192c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1924:	80 91 bf 01 	lds	r24, 0x01BF
    1928:	90 91 c0 01 	lds	r25, 0x01C0
    192c:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vListInsert>
	}

	if( pxEventList )
    1930:	01 15       	cp	r16, r1
    1932:	11 05       	cpc	r17, r1
    1934:	69 f0       	breq	.+26     	; 0x1950 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1936:	60 91 8f 01 	lds	r22, 0x018F
    193a:	70 91 90 01 	lds	r23, 0x0190
    193e:	64 5f       	subi	r22, 0xF4	; 244
    1940:	7f 4f       	sbci	r23, 0xFF	; 255
    1942:	c8 01       	movw	r24, r16
	}
}
    1944:	df 91       	pop	r29
    1946:	cf 91       	pop	r28
    1948:	1f 91       	pop	r17
    194a:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    194c:	0c 94 9c 0b 	jmp	0x1738	; 0x1738 <vListInsert>
	}
}
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	08 95       	ret

0000195a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    195a:	ff 92       	push	r15
    195c:	0f 93       	push	r16
    195e:	1f 93       	push	r17
    1960:	cf 93       	push	r28
    1962:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1964:	99 e0       	ldi	r25, 0x09	; 9
    1966:	f9 2e       	mov	r15, r25
    1968:	21 c0       	rjmp	.+66     	; 0x19ac <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    196a:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    196c:	e0 91 bb 01 	lds	r30, 0x01BB
    1970:	f0 91 bc 01 	lds	r31, 0x01BC
    1974:	c6 81       	ldd	r28, Z+6	; 0x06
    1976:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1978:	ce 01       	movw	r24, r28
    197a:	0c 96       	adiw	r24, 0x0c	; 12
    197c:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1980:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1982:	8e 01       	movw	r16, r28
    1984:	0e 5f       	subi	r16, 0xFE	; 254
    1986:	1f 4f       	sbci	r17, 0xFF	; 255
    1988:	c8 01       	movw	r24, r16
    198a:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    198e:	8e 89       	ldd	r24, Y+22	; 0x16
    1990:	90 91 91 01 	lds	r25, 0x0191
    1994:	98 17       	cp	r25, r24
    1996:	10 f4       	brcc	.+4      	; 0x199c <vCoRoutineSchedule+0x42>
    1998:	80 93 91 01 	sts	0x0191, r24
    199c:	f8 9e       	mul	r15, r24
    199e:	c0 01       	movw	r24, r0
    19a0:	11 24       	eor	r1, r1
    19a2:	b8 01       	movw	r22, r16
    19a4:	8e 56       	subi	r24, 0x6E	; 110
    19a6:	9e 4f       	sbci	r25, 0xFE	; 254
    19a8:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    19ac:	80 91 b6 01 	lds	r24, 0x01B6
    19b0:	81 11       	cpse	r24, r1
    19b2:	db cf       	rjmp	.-74     	; 0x196a <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    19b4:	0e 94 48 02 	call	0x490	; 0x490 <xTaskGetTickCount>
    19b8:	20 91 c5 01 	lds	r18, 0x01C5
    19bc:	30 91 c6 01 	lds	r19, 0x01C6
    19c0:	82 1b       	sub	r24, r18
    19c2:	93 0b       	sbc	r25, r19
    19c4:	90 93 c8 01 	sts	0x01C8, r25
    19c8:	80 93 c7 01 	sts	0x01C7, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    19cc:	89 e0       	ldi	r24, 0x09	; 9
    19ce:	f8 2e       	mov	r15, r24
    19d0:	53 c0       	rjmp	.+166    	; 0x1a78 <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    19d2:	01 96       	adiw	r24, 0x01	; 1
    19d4:	90 93 c4 01 	sts	0x01C4, r25
    19d8:	80 93 c3 01 	sts	0x01C3, r24
		xPassedTicks--;
    19dc:	21 50       	subi	r18, 0x01	; 1
    19de:	31 09       	sbc	r19, r1
    19e0:	30 93 c8 01 	sts	0x01C8, r19
    19e4:	20 93 c7 01 	sts	0x01C7, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    19e8:	89 2b       	or	r24, r25
    19ea:	09 f0       	breq	.+2      	; 0x19ee <vCoRoutineSchedule+0x94>
    19ec:	3e c0       	rjmp	.+124    	; 0x1a6a <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    19ee:	80 91 bf 01 	lds	r24, 0x01BF
    19f2:	90 91 c0 01 	lds	r25, 0x01C0
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    19f6:	20 91 c1 01 	lds	r18, 0x01C1
    19fa:	30 91 c2 01 	lds	r19, 0x01C2
    19fe:	30 93 c0 01 	sts	0x01C0, r19
    1a02:	20 93 bf 01 	sts	0x01BF, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    1a06:	90 93 c2 01 	sts	0x01C2, r25
    1a0a:	80 93 c1 01 	sts	0x01C1, r24
    1a0e:	2d c0       	rjmp	.+90     	; 0x1a6a <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1a10:	05 80       	ldd	r0, Z+5	; 0x05
    1a12:	f6 81       	ldd	r31, Z+6	; 0x06
    1a14:	e0 2d       	mov	r30, r0
    1a16:	c6 81       	ldd	r28, Z+6	; 0x06
    1a18:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1a1a:	20 91 c3 01 	lds	r18, 0x01C3
    1a1e:	30 91 c4 01 	lds	r19, 0x01C4
    1a22:	8a 81       	ldd	r24, Y+2	; 0x02
    1a24:	9b 81       	ldd	r25, Y+3	; 0x03
    1a26:	28 17       	cp	r18, r24
    1a28:	39 07       	cpc	r19, r25
    1a2a:	30 f1       	brcs	.+76     	; 0x1a78 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1a2c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1a2e:	8e 01       	movw	r16, r28
    1a30:	0e 5f       	subi	r16, 0xFE	; 254
    1a32:	1f 4f       	sbci	r17, 0xFF	; 255
    1a34:	c8 01       	movw	r24, r16
    1a36:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1a3a:	8c 89       	ldd	r24, Y+20	; 0x14
    1a3c:	9d 89       	ldd	r25, Y+21	; 0x15
    1a3e:	89 2b       	or	r24, r25
    1a40:	21 f0       	breq	.+8      	; 0x1a4a <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1a42:	ce 01       	movw	r24, r28
    1a44:	0c 96       	adiw	r24, 0x0c	; 12
    1a46:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1a4a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1a4c:	8e 89       	ldd	r24, Y+22	; 0x16
    1a4e:	90 91 91 01 	lds	r25, 0x0191
    1a52:	98 17       	cp	r25, r24
    1a54:	10 f4       	brcc	.+4      	; 0x1a5a <vCoRoutineSchedule+0x100>
    1a56:	80 93 91 01 	sts	0x0191, r24
    1a5a:	f8 9e       	mul	r15, r24
    1a5c:	c0 01       	movw	r24, r0
    1a5e:	11 24       	eor	r1, r1
    1a60:	b8 01       	movw	r22, r16
    1a62:	8e 56       	subi	r24, 0x6E	; 110
    1a64:	9e 4f       	sbci	r25, 0xFE	; 254
    1a66:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1a6a:	e0 91 bf 01 	lds	r30, 0x01BF
    1a6e:	f0 91 c0 01 	lds	r31, 0x01C0
    1a72:	80 81       	ld	r24, Z
    1a74:	81 11       	cpse	r24, r1
    1a76:	cc cf       	rjmp	.-104    	; 0x1a10 <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1a78:	20 91 c7 01 	lds	r18, 0x01C7
    1a7c:	30 91 c8 01 	lds	r19, 0x01C8
    1a80:	80 91 c3 01 	lds	r24, 0x01C3
    1a84:	90 91 c4 01 	lds	r25, 0x01C4
    1a88:	21 15       	cp	r18, r1
    1a8a:	31 05       	cpc	r19, r1
    1a8c:	09 f0       	breq	.+2      	; 0x1a90 <vCoRoutineSchedule+0x136>
    1a8e:	a1 cf       	rjmp	.-190    	; 0x19d2 <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1a90:	90 93 c6 01 	sts	0x01C6, r25
    1a94:	80 93 c5 01 	sts	0x01C5, r24
    1a98:	80 91 91 01 	lds	r24, 0x0191

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1a9c:	29 e0       	ldi	r18, 0x09	; 9
    1a9e:	06 c0       	rjmp	.+12     	; 0x1aac <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1aa0:	81 11       	cpse	r24, r1
    1aa2:	03 c0       	rjmp	.+6      	; 0x1aaa <vCoRoutineSchedule+0x150>
    1aa4:	10 92 91 01 	sts	0x0191, r1
    1aa8:	33 c0       	rjmp	.+102    	; 0x1b10 <vCoRoutineSchedule+0x1b6>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1aaa:	81 50       	subi	r24, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1aac:	28 9f       	mul	r18, r24
    1aae:	f0 01       	movw	r30, r0
    1ab0:	11 24       	eor	r1, r1
    1ab2:	ee 56       	subi	r30, 0x6E	; 110
    1ab4:	fe 4f       	sbci	r31, 0xFE	; 254
    1ab6:	90 81       	ld	r25, Z
    1ab8:	99 23       	and	r25, r25
    1aba:	91 f3       	breq	.-28     	; 0x1aa0 <vCoRoutineSchedule+0x146>
    1abc:	80 93 91 01 	sts	0x0191, r24
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1ac0:	a1 81       	ldd	r26, Z+1	; 0x01
    1ac2:	b2 81       	ldd	r27, Z+2	; 0x02
    1ac4:	12 96       	adiw	r26, 0x02	; 2
    1ac6:	0d 90       	ld	r0, X+
    1ac8:	bc 91       	ld	r27, X
    1aca:	a0 2d       	mov	r26, r0
    1acc:	b2 83       	std	Z+2, r27	; 0x02
    1ace:	a1 83       	std	Z+1, r26	; 0x01
    1ad0:	cf 01       	movw	r24, r30
    1ad2:	03 96       	adiw	r24, 0x03	; 3
    1ad4:	a8 17       	cp	r26, r24
    1ad6:	b9 07       	cpc	r27, r25
    1ad8:	31 f4       	brne	.+12     	; 0x1ae6 <vCoRoutineSchedule+0x18c>
    1ada:	12 96       	adiw	r26, 0x02	; 2
    1adc:	8d 91       	ld	r24, X+
    1ade:	9c 91       	ld	r25, X
    1ae0:	13 97       	sbiw	r26, 0x03	; 3
    1ae2:	92 83       	std	Z+2, r25	; 0x02
    1ae4:	81 83       	std	Z+1, r24	; 0x01
    1ae6:	01 80       	ldd	r0, Z+1	; 0x01
    1ae8:	f2 81       	ldd	r31, Z+2	; 0x02
    1aea:	e0 2d       	mov	r30, r0
    1aec:	86 81       	ldd	r24, Z+6	; 0x06
    1aee:	97 81       	ldd	r25, Z+7	; 0x07
    1af0:	90 93 90 01 	sts	0x0190, r25
    1af4:	80 93 8f 01 	sts	0x018F, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1af8:	dc 01       	movw	r26, r24
    1afa:	ed 91       	ld	r30, X+
    1afc:	fc 91       	ld	r31, X
    1afe:	11 97       	sbiw	r26, 0x01	; 1
    1b00:	57 96       	adiw	r26, 0x17	; 23
    1b02:	6c 91       	ld	r22, X

	return;
}
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1b0e:	09 94       	ijmp

	return;
}
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	1f 91       	pop	r17
    1b16:	0f 91       	pop	r16
    1b18:	ff 90       	pop	r15
    1b1a:	08 95       	ret

00001b1c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1b24:	dc 01       	movw	r26, r24
    1b26:	15 96       	adiw	r26, 0x05	; 5
    1b28:	ed 91       	ld	r30, X+
    1b2a:	fc 91       	ld	r31, X
    1b2c:	16 97       	sbiw	r26, 0x06	; 6
    1b2e:	c6 81       	ldd	r28, Z+6	; 0x06
    1b30:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1b32:	8e 01       	movw	r16, r28
    1b34:	04 5f       	subi	r16, 0xF4	; 244
    1b36:	1f 4f       	sbci	r17, 0xFF	; 255
    1b38:	c8 01       	movw	r24, r16
    1b3a:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1b3e:	b8 01       	movw	r22, r16
    1b40:	86 eb       	ldi	r24, 0xB6	; 182
    1b42:	91 e0       	ldi	r25, 0x01	; 1
    1b44:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1b48:	e0 91 8f 01 	lds	r30, 0x018F
    1b4c:	f0 91 90 01 	lds	r31, 0x0190
    1b50:	81 e0       	ldi	r24, 0x01	; 1
    1b52:	2e 89       	ldd	r18, Y+22	; 0x16
    1b54:	96 89       	ldd	r25, Z+22	; 0x16
    1b56:	29 17       	cp	r18, r25
    1b58:	08 f4       	brcc	.+2      	; 0x1b5c <xCoRoutineRemoveFromEventList+0x40>
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1b5c:	df 91       	pop	r29
    1b5e:	cf 91       	pop	r28
    1b60:	1f 91       	pop	r17
    1b62:	0f 91       	pop	r16
    1b64:	08 95       	ret

00001b66 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1b66:	cf 93       	push	r28
    1b68:	df 93       	push	r29
    1b6a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1b6c:	0e 94 42 02 	call	0x484	; 0x484 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1b70:	80 91 c9 01 	lds	r24, 0x01C9
    1b74:	90 91 ca 01 	lds	r25, 0x01CA
    1b78:	89 2b       	or	r24, r25
    1b7a:	31 f4       	brne	.+12     	; 0x1b88 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1b7c:	8c ec       	ldi	r24, 0xCC	; 204
    1b7e:	91 e0       	ldi	r25, 0x01	; 1
    1b80:	90 93 ca 01 	sts	0x01CA, r25
    1b84:	80 93 c9 01 	sts	0x01C9, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1b88:	20 91 a7 07 	lds	r18, 0x07A7
    1b8c:	30 91 a8 07 	lds	r19, 0x07A8
    1b90:	ce 01       	movw	r24, r28
    1b92:	82 0f       	add	r24, r18
    1b94:	93 1f       	adc	r25, r19
    1b96:	8b 3d       	cpi	r24, 0xDB	; 219
    1b98:	45 e0       	ldi	r20, 0x05	; 5
    1b9a:	94 07       	cpc	r25, r20
    1b9c:	70 f4       	brcc	.+28     	; 0x1bba <pvPortMalloc+0x54>
    1b9e:	28 17       	cp	r18, r24
    1ba0:	39 07       	cpc	r19, r25
    1ba2:	58 f4       	brcc	.+22     	; 0x1bba <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1ba4:	c0 91 c9 01 	lds	r28, 0x01C9
    1ba8:	d0 91 ca 01 	lds	r29, 0x01CA
    1bac:	c2 0f       	add	r28, r18
    1bae:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1bb0:	90 93 a8 07 	sts	0x07A8, r25
    1bb4:	80 93 a7 07 	sts	0x07A7, r24
    1bb8:	02 c0       	rjmp	.+4      	; 0x1bbe <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1bba:	c0 e0       	ldi	r28, 0x00	; 0
    1bbc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1bbe:	0e 94 0e 03 	call	0x61c	; 0x61c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1bc2:	ce 01       	movw	r24, r28
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	08 95       	ret

00001bca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1bca:	08 95       	ret

00001bcc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1bcc:	10 92 a8 07 	sts	0x07A8, r1
    1bd0:	10 92 a7 07 	sts	0x07A7, r1
    1bd4:	08 95       	ret

00001bd6 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1bd6:	2b ed       	ldi	r18, 0xDB	; 219
    1bd8:	35 e0       	ldi	r19, 0x05	; 5
    1bda:	80 91 a7 07 	lds	r24, 0x07A7
    1bde:	90 91 a8 07 	lds	r25, 0x07A8
    1be2:	28 1b       	sub	r18, r24
    1be4:	39 0b       	sbc	r19, r25
}
    1be6:	c9 01       	movw	r24, r18
    1be8:	08 95       	ret

00001bea <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1bea:	31 e1       	ldi	r19, 0x11	; 17
    1bec:	fc 01       	movw	r30, r24
    1bee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1bf0:	31 97       	sbiw	r30, 0x01	; 1
    1bf2:	22 e2       	ldi	r18, 0x22	; 34
    1bf4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	32 97       	sbiw	r30, 0x02	; 2
    1bfa:	a3 e3       	ldi	r26, 0x33	; 51
    1bfc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1bfe:	fc 01       	movw	r30, r24
    1c00:	33 97       	sbiw	r30, 0x03	; 3
    1c02:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c04:	fc 01       	movw	r30, r24
    1c06:	34 97       	sbiw	r30, 0x04	; 4
    1c08:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1c0a:	fc 01       	movw	r30, r24
    1c0c:	35 97       	sbiw	r30, 0x05	; 5
    1c0e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1c10:	fc 01       	movw	r30, r24
    1c12:	36 97       	sbiw	r30, 0x06	; 6
    1c14:	60 e8       	ldi	r22, 0x80	; 128
    1c16:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1c18:	fc 01       	movw	r30, r24
    1c1a:	37 97       	sbiw	r30, 0x07	; 7
    1c1c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1c1e:	fc 01       	movw	r30, r24
    1c20:	38 97       	sbiw	r30, 0x08	; 8
    1c22:	62 e0       	ldi	r22, 0x02	; 2
    1c24:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1c26:	fc 01       	movw	r30, r24
    1c28:	39 97       	sbiw	r30, 0x09	; 9
    1c2a:	63 e0       	ldi	r22, 0x03	; 3
    1c2c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1c2e:	fc 01       	movw	r30, r24
    1c30:	3a 97       	sbiw	r30, 0x0a	; 10
    1c32:	64 e0       	ldi	r22, 0x04	; 4
    1c34:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1c36:	fc 01       	movw	r30, r24
    1c38:	3b 97       	sbiw	r30, 0x0b	; 11
    1c3a:	65 e0       	ldi	r22, 0x05	; 5
    1c3c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1c3e:	fc 01       	movw	r30, r24
    1c40:	3c 97       	sbiw	r30, 0x0c	; 12
    1c42:	66 e0       	ldi	r22, 0x06	; 6
    1c44:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1c46:	fc 01       	movw	r30, r24
    1c48:	3d 97       	sbiw	r30, 0x0d	; 13
    1c4a:	67 e0       	ldi	r22, 0x07	; 7
    1c4c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1c4e:	fc 01       	movw	r30, r24
    1c50:	3e 97       	sbiw	r30, 0x0e	; 14
    1c52:	68 e0       	ldi	r22, 0x08	; 8
    1c54:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1c56:	fc 01       	movw	r30, r24
    1c58:	3f 97       	sbiw	r30, 0x0f	; 15
    1c5a:	69 e0       	ldi	r22, 0x09	; 9
    1c5c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1c5e:	fc 01       	movw	r30, r24
    1c60:	70 97       	sbiw	r30, 0x10	; 16
    1c62:	60 e1       	ldi	r22, 0x10	; 16
    1c64:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1c66:	fc 01       	movw	r30, r24
    1c68:	71 97       	sbiw	r30, 0x11	; 17
    1c6a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	72 97       	sbiw	r30, 0x12	; 18
    1c70:	32 e1       	ldi	r19, 0x12	; 18
    1c72:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1c74:	fc 01       	movw	r30, r24
    1c76:	73 97       	sbiw	r30, 0x13	; 19
    1c78:	33 e1       	ldi	r19, 0x13	; 19
    1c7a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	74 97       	sbiw	r30, 0x14	; 20
    1c80:	34 e1       	ldi	r19, 0x14	; 20
    1c82:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1c84:	fc 01       	movw	r30, r24
    1c86:	75 97       	sbiw	r30, 0x15	; 21
    1c88:	35 e1       	ldi	r19, 0x15	; 21
    1c8a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	76 97       	sbiw	r30, 0x16	; 22
    1c90:	36 e1       	ldi	r19, 0x16	; 22
    1c92:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1c94:	fc 01       	movw	r30, r24
    1c96:	77 97       	sbiw	r30, 0x17	; 23
    1c98:	37 e1       	ldi	r19, 0x17	; 23
    1c9a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1c9c:	fc 01       	movw	r30, r24
    1c9e:	78 97       	sbiw	r30, 0x18	; 24
    1ca0:	38 e1       	ldi	r19, 0x18	; 24
    1ca2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	79 97       	sbiw	r30, 0x19	; 25
    1ca8:	39 e1       	ldi	r19, 0x19	; 25
    1caa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1cac:	fc 01       	movw	r30, r24
    1cae:	7a 97       	sbiw	r30, 0x1a	; 26
    1cb0:	30 e2       	ldi	r19, 0x20	; 32
    1cb2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	7b 97       	sbiw	r30, 0x1b	; 27
    1cb8:	31 e2       	ldi	r19, 0x21	; 33
    1cba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	7c 97       	sbiw	r30, 0x1c	; 28
    1cc0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	7d 97       	sbiw	r30, 0x1d	; 29
    1cc6:	23 e2       	ldi	r18, 0x23	; 35
    1cc8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1cca:	fc 01       	movw	r30, r24
    1ccc:	7e 97       	sbiw	r30, 0x1e	; 30
    1cce:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	7f 97       	sbiw	r30, 0x1f	; 31
    1cd4:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1cd6:	fc 01       	movw	r30, r24
    1cd8:	b0 97       	sbiw	r30, 0x20	; 32
    1cda:	26 e2       	ldi	r18, 0x26	; 38
    1cdc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1cde:	fc 01       	movw	r30, r24
    1ce0:	b1 97       	sbiw	r30, 0x21	; 33
    1ce2:	27 e2       	ldi	r18, 0x27	; 39
    1ce4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	b2 97       	sbiw	r30, 0x22	; 34
    1cea:	28 e2       	ldi	r18, 0x28	; 40
    1cec:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1cee:	fc 01       	movw	r30, r24
    1cf0:	b3 97       	sbiw	r30, 0x23	; 35
    1cf2:	29 e2       	ldi	r18, 0x29	; 41
    1cf4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	b4 97       	sbiw	r30, 0x24	; 36
    1cfa:	20 e3       	ldi	r18, 0x30	; 48
    1cfc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1cfe:	fc 01       	movw	r30, r24
    1d00:	b5 97       	sbiw	r30, 0x25	; 37
    1d02:	21 e3       	ldi	r18, 0x31	; 49
    1d04:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1d06:	9c 01       	movw	r18, r24
    1d08:	26 52       	subi	r18, 0x26	; 38
    1d0a:	31 09       	sbc	r19, r1
}
    1d0c:	c9 01       	movw	r24, r18
    1d0e:	08 95       	ret

00001d10 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    1d10:	89 ef       	ldi	r24, 0xF9	; 249
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	90 93 89 00 	sts	0x0089, r25
    1d18:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    1d1c:	e0 e8       	ldi	r30, 0x80	; 128
    1d1e:	f0 e0       	ldi	r31, 0x00	; 0
    1d20:	80 81       	ld	r24, Z
    1d22:	8c 7f       	andi	r24, 0xFC	; 252
    1d24:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1d26:	8b e0       	ldi	r24, 0x0B	; 11
    1d28:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1d2c:	ef e6       	ldi	r30, 0x6F	; 111
    1d2e:	f0 e0       	ldi	r31, 0x00	; 0
    1d30:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1d32:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1d34:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1d36:	a0 91 36 01 	lds	r26, 0x0136
    1d3a:	b0 91 37 01 	lds	r27, 0x0137
    1d3e:	cd 91       	ld	r28, X+
    1d40:	cd bf       	out	0x3d, r28	; 61
    1d42:	dd 91       	ld	r29, X+
    1d44:	de bf       	out	0x3e, r29	; 62
    1d46:	ff 91       	pop	r31
    1d48:	ef 91       	pop	r30
    1d4a:	df 91       	pop	r29
    1d4c:	cf 91       	pop	r28
    1d4e:	bf 91       	pop	r27
    1d50:	af 91       	pop	r26
    1d52:	9f 91       	pop	r25
    1d54:	8f 91       	pop	r24
    1d56:	7f 91       	pop	r23
    1d58:	6f 91       	pop	r22
    1d5a:	5f 91       	pop	r21
    1d5c:	4f 91       	pop	r20
    1d5e:	3f 91       	pop	r19
    1d60:	2f 91       	pop	r18
    1d62:	1f 91       	pop	r17
    1d64:	0f 91       	pop	r16
    1d66:	ff 90       	pop	r15
    1d68:	ef 90       	pop	r14
    1d6a:	df 90       	pop	r13
    1d6c:	cf 90       	pop	r12
    1d6e:	bf 90       	pop	r11
    1d70:	af 90       	pop	r10
    1d72:	9f 90       	pop	r9
    1d74:	8f 90       	pop	r8
    1d76:	7f 90       	pop	r7
    1d78:	6f 90       	pop	r6
    1d7a:	5f 90       	pop	r5
    1d7c:	4f 90       	pop	r4
    1d7e:	3f 90       	pop	r3
    1d80:	2f 90       	pop	r2
    1d82:	1f 90       	pop	r1
    1d84:	0f 90       	pop	r0
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1d8a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1d8c:	81 e0       	ldi	r24, 0x01	; 1
    1d8e:	08 95       	ret

00001d90 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1d90:	08 95       	ret

00001d92 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d92:	0f 92       	push	r0
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	0f 92       	push	r0
    1d9a:	1f 92       	push	r1
    1d9c:	11 24       	eor	r1, r1
    1d9e:	2f 92       	push	r2
    1da0:	3f 92       	push	r3
    1da2:	4f 92       	push	r4
    1da4:	5f 92       	push	r5
    1da6:	6f 92       	push	r6
    1da8:	7f 92       	push	r7
    1daa:	8f 92       	push	r8
    1dac:	9f 92       	push	r9
    1dae:	af 92       	push	r10
    1db0:	bf 92       	push	r11
    1db2:	cf 92       	push	r12
    1db4:	df 92       	push	r13
    1db6:	ef 92       	push	r14
    1db8:	ff 92       	push	r15
    1dba:	0f 93       	push	r16
    1dbc:	1f 93       	push	r17
    1dbe:	2f 93       	push	r18
    1dc0:	3f 93       	push	r19
    1dc2:	4f 93       	push	r20
    1dc4:	5f 93       	push	r21
    1dc6:	6f 93       	push	r22
    1dc8:	7f 93       	push	r23
    1dca:	8f 93       	push	r24
    1dcc:	9f 93       	push	r25
    1dce:	af 93       	push	r26
    1dd0:	bf 93       	push	r27
    1dd2:	cf 93       	push	r28
    1dd4:	df 93       	push	r29
    1dd6:	ef 93       	push	r30
    1dd8:	ff 93       	push	r31
    1dda:	a0 91 36 01 	lds	r26, 0x0136
    1dde:	b0 91 37 01 	lds	r27, 0x0137
    1de2:	0d b6       	in	r0, 0x3d	; 61
    1de4:	0d 92       	st	X+, r0
    1de6:	0e b6       	in	r0, 0x3e	; 62
    1de8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1dea:	0e 94 16 04 	call	0x82c	; 0x82c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1dee:	a0 91 36 01 	lds	r26, 0x0136
    1df2:	b0 91 37 01 	lds	r27, 0x0137
    1df6:	cd 91       	ld	r28, X+
    1df8:	cd bf       	out	0x3d, r28	; 61
    1dfa:	dd 91       	ld	r29, X+
    1dfc:	de bf       	out	0x3e, r29	; 62
    1dfe:	ff 91       	pop	r31
    1e00:	ef 91       	pop	r30
    1e02:	df 91       	pop	r29
    1e04:	cf 91       	pop	r28
    1e06:	bf 91       	pop	r27
    1e08:	af 91       	pop	r26
    1e0a:	9f 91       	pop	r25
    1e0c:	8f 91       	pop	r24
    1e0e:	7f 91       	pop	r23
    1e10:	6f 91       	pop	r22
    1e12:	5f 91       	pop	r21
    1e14:	4f 91       	pop	r20
    1e16:	3f 91       	pop	r19
    1e18:	2f 91       	pop	r18
    1e1a:	1f 91       	pop	r17
    1e1c:	0f 91       	pop	r16
    1e1e:	ff 90       	pop	r15
    1e20:	ef 90       	pop	r14
    1e22:	df 90       	pop	r13
    1e24:	cf 90       	pop	r12
    1e26:	bf 90       	pop	r11
    1e28:	af 90       	pop	r10
    1e2a:	9f 90       	pop	r9
    1e2c:	8f 90       	pop	r8
    1e2e:	7f 90       	pop	r7
    1e30:	6f 90       	pop	r6
    1e32:	5f 90       	pop	r5
    1e34:	4f 90       	pop	r4
    1e36:	3f 90       	pop	r3
    1e38:	2f 90       	pop	r2
    1e3a:	1f 90       	pop	r1
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e42:	08 95       	ret

00001e44 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e44:	0f 92       	push	r0
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	0f 92       	push	r0
    1e4c:	1f 92       	push	r1
    1e4e:	11 24       	eor	r1, r1
    1e50:	2f 92       	push	r2
    1e52:	3f 92       	push	r3
    1e54:	4f 92       	push	r4
    1e56:	5f 92       	push	r5
    1e58:	6f 92       	push	r6
    1e5a:	7f 92       	push	r7
    1e5c:	8f 92       	push	r8
    1e5e:	9f 92       	push	r9
    1e60:	af 92       	push	r10
    1e62:	bf 92       	push	r11
    1e64:	cf 92       	push	r12
    1e66:	df 92       	push	r13
    1e68:	ef 92       	push	r14
    1e6a:	ff 92       	push	r15
    1e6c:	0f 93       	push	r16
    1e6e:	1f 93       	push	r17
    1e70:	2f 93       	push	r18
    1e72:	3f 93       	push	r19
    1e74:	4f 93       	push	r20
    1e76:	5f 93       	push	r21
    1e78:	6f 93       	push	r22
    1e7a:	7f 93       	push	r23
    1e7c:	8f 93       	push	r24
    1e7e:	9f 93       	push	r25
    1e80:	af 93       	push	r26
    1e82:	bf 93       	push	r27
    1e84:	cf 93       	push	r28
    1e86:	df 93       	push	r29
    1e88:	ef 93       	push	r30
    1e8a:	ff 93       	push	r31
    1e8c:	a0 91 36 01 	lds	r26, 0x0136
    1e90:	b0 91 37 01 	lds	r27, 0x0137
    1e94:	0d b6       	in	r0, 0x3d	; 61
    1e96:	0d 92       	st	X+, r0
    1e98:	0e b6       	in	r0, 0x3e	; 62
    1e9a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1e9c:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <xTaskIncrementTick>
    1ea0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1ea2:	0e 94 16 04 	call	0x82c	; 0x82c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1ea6:	a0 91 36 01 	lds	r26, 0x0136
    1eaa:	b0 91 37 01 	lds	r27, 0x0137
    1eae:	cd 91       	ld	r28, X+
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	dd 91       	ld	r29, X+
    1eb4:	de bf       	out	0x3e, r29	; 62
    1eb6:	ff 91       	pop	r31
    1eb8:	ef 91       	pop	r30
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	bf 91       	pop	r27
    1ec0:	af 91       	pop	r26
    1ec2:	9f 91       	pop	r25
    1ec4:	8f 91       	pop	r24
    1ec6:	7f 91       	pop	r23
    1ec8:	6f 91       	pop	r22
    1eca:	5f 91       	pop	r21
    1ecc:	4f 91       	pop	r20
    1ece:	3f 91       	pop	r19
    1ed0:	2f 91       	pop	r18
    1ed2:	1f 91       	pop	r17
    1ed4:	0f 91       	pop	r16
    1ed6:	ff 90       	pop	r15
    1ed8:	ef 90       	pop	r14
    1eda:	df 90       	pop	r13
    1edc:	cf 90       	pop	r12
    1ede:	bf 90       	pop	r11
    1ee0:	af 90       	pop	r10
    1ee2:	9f 90       	pop	r9
    1ee4:	8f 90       	pop	r8
    1ee6:	7f 90       	pop	r7
    1ee8:	6f 90       	pop	r6
    1eea:	5f 90       	pop	r5
    1eec:	4f 90       	pop	r4
    1eee:	3f 90       	pop	r3
    1ef0:	2f 90       	pop	r2
    1ef2:	1f 90       	pop	r1
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1efa:	08 95       	ret

00001efc <__vector_11>:
	 * count is incremented after the context is saved.
	 */
    void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
    void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1efc:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f00:	18 95       	reti

00001f02 <uart_init>:
#endif
#include <util/setbaud.h>


void uart_init(void) {
UBRR0H = UBRRH_VALUE;
    1f02:	10 92 c5 00 	sts	0x00C5, r1
UBRR0L = UBRRL_VALUE;
    1f06:	87 e6       	ldi	r24, 0x67	; 103
    1f08:	80 93 c4 00 	sts	0x00C4, r24
#if USE_2X
UCSR0A |= _BV(U2X0);
#else
UCSR0A &= ~(_BV(U2X0));
    1f0c:	e0 ec       	ldi	r30, 0xC0	; 192
    1f0e:	f0 e0       	ldi	r31, 0x00	; 0
    1f10:	80 81       	ld	r24, Z
    1f12:	8d 7f       	andi	r24, 0xFD	; 253
    1f14:	80 83       	st	Z, r24
#endif
UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
    1f16:	86 e0       	ldi	r24, 0x06	; 6
    1f18:	80 93 c2 00 	sts	0x00C2, r24
UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
    1f1c:	88 e1       	ldi	r24, 0x18	; 24
    1f1e:	80 93 c1 00 	sts	0x00C1, r24
    1f22:	08 95       	ret

00001f24 <uart_putchar>:
}

void uart_putchar(char c, FILE *stream) {
    1f24:	cf 93       	push	r28
    1f26:	c8 2f       	mov	r28, r24
if (c == '\n') {
    1f28:	8a 30       	cpi	r24, 0x0A	; 10
    1f2a:	19 f4       	brne	.+6      	; 0x1f32 <uart_putchar+0xe>
uart_putchar('\r', stream);
    1f2c:	8d e0       	ldi	r24, 0x0D	; 13
    1f2e:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <uart_putchar>
}
loop_until_bit_is_set(UCSR0A, UDRE0);
    1f32:	80 91 c0 00 	lds	r24, 0x00C0
    1f36:	85 ff       	sbrs	r24, 5
    1f38:	fc cf       	rjmp	.-8      	; 0x1f32 <uart_putchar+0xe>
UDR0 = c;
    1f3a:	c0 93 c6 00 	sts	0x00C6, r28
}
    1f3e:	cf 91       	pop	r28
    1f40:	08 95       	ret

00001f42 <uart_getchar>:
    1f42:	80 91 c0 00 	lds	r24, 0x00C0
    1f46:	87 ff       	sbrs	r24, 7
    1f48:	fc cf       	rjmp	.-8      	; 0x1f42 <uart_getchar>
    1f4a:	80 91 c6 00 	lds	r24, 0x00C6
    1f4e:	08 95       	ret

00001f50 <main>:
    1f50:	af 92       	push	r10
    1f52:	bf 92       	push	r11
    1f54:	cf 92       	push	r12
    1f56:	df 92       	push	r13
    1f58:	ef 92       	push	r14
    1f5a:	ff 92       	push	r15
    1f5c:	0f 93       	push	r16
    1f5e:	cf 93       	push	r28
    1f60:	df 93       	push	r29
    1f62:	00 d0       	rcall	.+0      	; 0x1f64 <main+0x14>
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <main+0x16>
    1f66:	cd b7       	in	r28, 0x3d	; 61
    1f68:	de b7       	in	r29, 0x3e	; 62
    1f6a:	a1 2c       	mov	r10, r1
    1f6c:	b1 2c       	mov	r11, r1
    1f6e:	c1 2c       	mov	r12, r1
    1f70:	d1 2c       	mov	r13, r1
    1f72:	83 e0       	ldi	r24, 0x03	; 3
    1f74:	e8 2e       	mov	r14, r24
    1f76:	f1 2c       	mov	r15, r1
    1f78:	ec 0e       	add	r14, r28
    1f7a:	fd 1e       	adc	r15, r29
    1f7c:	00 e0       	ldi	r16, 0x00	; 0
    1f7e:	20 e0       	ldi	r18, 0x00	; 0
    1f80:	30 e0       	ldi	r19, 0x00	; 0
    1f82:	45 e5       	ldi	r20, 0x55	; 85
    1f84:	50 e0       	ldi	r21, 0x00	; 0
    1f86:	64 e2       	ldi	r22, 0x24	; 36
    1f88:	71 e0       	ldi	r23, 0x01	; 1
    1f8a:	8a e6       	ldi	r24, 0x6A	; 106
    1f8c:	90 e0       	ldi	r25, 0x00	; 0
    1f8e:	0e 94 c4 00 	call	0x188	; 0x188 <xTaskGenericCreate>
    1f92:	ee 24       	eor	r14, r14
    1f94:	e3 94       	inc	r14
    1f96:	f1 2c       	mov	r15, r1
    1f98:	ec 0e       	add	r14, r28
    1f9a:	fd 1e       	adc	r15, r29
    1f9c:	02 e0       	ldi	r16, 0x02	; 2
    1f9e:	20 e0       	ldi	r18, 0x00	; 0
    1fa0:	30 e0       	ldi	r19, 0x00	; 0
    1fa2:	45 e5       	ldi	r20, 0x55	; 85
    1fa4:	50 e0       	ldi	r21, 0x00	; 0
    1fa6:	6a e2       	ldi	r22, 0x2A	; 42
    1fa8:	71 e0       	ldi	r23, 0x01	; 1
    1faa:	83 e5       	ldi	r24, 0x53	; 83
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	0e 94 c4 00 	call	0x188	; 0x188 <xTaskGenericCreate>
    1fb2:	0e 94 0b 02 	call	0x416	; 0x416 <vTaskStartScheduler>
    1fb6:	80 e0       	ldi	r24, 0x00	; 0
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	0f 90       	pop	r0
    1fbc:	0f 90       	pop	r0
    1fbe:	0f 90       	pop	r0
    1fc0:	0f 90       	pop	r0
    1fc2:	df 91       	pop	r29
    1fc4:	cf 91       	pop	r28
    1fc6:	0f 91       	pop	r16
    1fc8:	ff 90       	pop	r15
    1fca:	ef 90       	pop	r14
    1fcc:	df 90       	pop	r13
    1fce:	cf 90       	pop	r12
    1fd0:	bf 90       	pop	r11
    1fd2:	af 90       	pop	r10
    1fd4:	08 95       	ret

00001fd6 <memcpy>:
    1fd6:	fb 01       	movw	r30, r22
    1fd8:	dc 01       	movw	r26, r24
    1fda:	02 c0       	rjmp	.+4      	; 0x1fe0 <memcpy+0xa>
    1fdc:	01 90       	ld	r0, Z+
    1fde:	0d 92       	st	X+, r0
    1fe0:	41 50       	subi	r20, 0x01	; 1
    1fe2:	50 40       	sbci	r21, 0x00	; 0
    1fe4:	d8 f7       	brcc	.-10     	; 0x1fdc <memcpy+0x6>
    1fe6:	08 95       	ret

00001fe8 <puts>:
    1fe8:	0f 93       	push	r16
    1fea:	1f 93       	push	r17
    1fec:	cf 93       	push	r28
    1fee:	df 93       	push	r29
    1ff0:	8c 01       	movw	r16, r24
    1ff2:	e0 91 ab 07 	lds	r30, 0x07AB
    1ff6:	f0 91 ac 07 	lds	r31, 0x07AC
    1ffa:	83 81       	ldd	r24, Z+3	; 0x03
    1ffc:	81 ff       	sbrs	r24, 1
    1ffe:	1b c0       	rjmp	.+54     	; 0x2036 <puts+0x4e>
    2000:	c0 e0       	ldi	r28, 0x00	; 0
    2002:	d0 e0       	ldi	r29, 0x00	; 0
    2004:	05 c0       	rjmp	.+10     	; 0x2010 <puts+0x28>
    2006:	09 95       	icall
    2008:	89 2b       	or	r24, r25
    200a:	11 f0       	breq	.+4      	; 0x2010 <puts+0x28>
    200c:	cf ef       	ldi	r28, 0xFF	; 255
    200e:	df ef       	ldi	r29, 0xFF	; 255
    2010:	f8 01       	movw	r30, r16
    2012:	81 91       	ld	r24, Z+
    2014:	8f 01       	movw	r16, r30
    2016:	60 91 ab 07 	lds	r22, 0x07AB
    201a:	70 91 ac 07 	lds	r23, 0x07AC
    201e:	db 01       	movw	r26, r22
    2020:	18 96       	adiw	r26, 0x08	; 8
    2022:	ed 91       	ld	r30, X+
    2024:	fc 91       	ld	r31, X
    2026:	19 97       	sbiw	r26, 0x09	; 9
    2028:	81 11       	cpse	r24, r1
    202a:	ed cf       	rjmp	.-38     	; 0x2006 <puts+0x1e>
    202c:	8a e0       	ldi	r24, 0x0A	; 10
    202e:	09 95       	icall
    2030:	89 2b       	or	r24, r25
    2032:	09 f4       	brne	.+2      	; 0x2036 <puts+0x4e>
    2034:	02 c0       	rjmp	.+4      	; 0x203a <puts+0x52>
    2036:	cf ef       	ldi	r28, 0xFF	; 255
    2038:	df ef       	ldi	r29, 0xFF	; 255
    203a:	ce 01       	movw	r24, r28
    203c:	df 91       	pop	r29
    203e:	cf 91       	pop	r28
    2040:	1f 91       	pop	r17
    2042:	0f 91       	pop	r16
    2044:	08 95       	ret

00002046 <_exit>:
    2046:	f8 94       	cli

00002048 <__stop_program>:
    2048:	ff cf       	rjmp	.-2      	; 0x2048 <__stop_program>
